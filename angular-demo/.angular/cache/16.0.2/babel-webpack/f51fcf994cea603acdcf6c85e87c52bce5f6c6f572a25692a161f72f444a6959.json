{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { NoSheetWithIdError } from '../../errors';\nimport { EmptyValue } from '../../interpreter/InterpreterValue';\nimport { ArrayVertex, ValueCellVertex } from '../index';\nexport class AddressMapping {\n  constructor(policy) {\n    this.policy = policy;\n    this.mapping = new Map();\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    const sheetMapping = this.mapping.get(address.sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(address.sheet);\n    }\n    return sheetMapping.getCell(address);\n  }\n  fetchCell(address) {\n    const sheetMapping = this.mapping.get(address.sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(address.sheet);\n    }\n    const vertex = sheetMapping.getCell(address);\n    if (!vertex) {\n      throw Error('Vertex for address missing in AddressMapping');\n    }\n    return vertex;\n  }\n  strategyFor(sheetId) {\n    const strategy = this.mapping.get(sheetId);\n    if (strategy === undefined) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return strategy;\n  }\n  addSheet(sheetId, strategy) {\n    if (this.mapping.has(sheetId)) {\n      throw Error('Sheet already added');\n    }\n    this.mapping.set(sheetId, strategy);\n  }\n  autoAddSheet(sheetId, sheet, sheetBoundaries) {\n    const {\n      height,\n      width,\n      fill\n    } = sheetBoundaries;\n    const strategyConstructor = this.policy.call(fill);\n    this.addSheet(sheetId, new strategyConstructor(width, height));\n  }\n  getCellValue(address) {\n    const vertex = this.getCell(address);\n    if (vertex === undefined) {\n      return EmptyValue;\n    } else if (vertex instanceof ArrayVertex) {\n      return vertex.getArrayCellValue(address);\n    } else {\n      return vertex.getCellValue();\n    }\n  }\n  getRawValue(address) {\n    const vertex = this.getCell(address);\n    if (vertex instanceof ValueCellVertex) {\n      return vertex.getValues().rawValue;\n    } else if (vertex instanceof ArrayVertex) {\n      return vertex.getArrayCellRawValue(address);\n    } else {\n      return null;\n    }\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    const sheetMapping = this.mapping.get(address.sheet);\n    if (!sheetMapping) {\n      throw Error('Sheet not initialized');\n    }\n    sheetMapping.setCell(address, newVertex);\n  }\n  moveCell(source, destination) {\n    const sheetMapping = this.mapping.get(source.sheet);\n    if (!sheetMapping) {\n      throw Error('Sheet not initialized.');\n    }\n    if (source.sheet !== destination.sheet) {\n      throw Error('Cannot move cells between sheets.');\n    }\n    if (sheetMapping.has(destination)) {\n      throw new Error('Cannot move cell. Destination already occupied.');\n    }\n    const vertex = sheetMapping.getCell(source);\n    if (vertex === undefined) {\n      throw new Error('Cannot move cell. No cell with such address.');\n    }\n    this.setCell(destination, vertex);\n    this.removeCell(source);\n  }\n  removeCell(address) {\n    const sheetMapping = this.mapping.get(address.sheet);\n    if (!sheetMapping) {\n      throw Error('Sheet not initialized');\n    }\n    sheetMapping.removeCell(address);\n  }\n  /** @inheritDoc */\n  has(address) {\n    const sheetMapping = this.mapping.get(address.sheet);\n    if (sheetMapping === undefined) {\n      return false;\n    }\n    return sheetMapping.has(address);\n  }\n  /** @inheritDoc */\n  getHeight(sheetId) {\n    const sheetMapping = this.mapping.get(sheetId);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return sheetMapping.getHeight();\n  }\n  /** @inheritDoc */\n  getWidth(sheetId) {\n    const sheetMapping = this.mapping.get(sheetId);\n    if (!sheetMapping) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return sheetMapping.getWidth();\n  }\n  addRows(sheet, row, numberOfRows) {\n    const sheetMapping = this.mapping.get(sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    sheetMapping.addRows(row, numberOfRows);\n  }\n  removeRows(removedRows) {\n    const sheetMapping = this.mapping.get(removedRows.sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(removedRows.sheet);\n    }\n    sheetMapping.removeRows(removedRows);\n  }\n  removeSheet(sheetId) {\n    this.mapping.delete(sheetId);\n  }\n  addColumns(sheet, column, numberOfColumns) {\n    const sheetMapping = this.mapping.get(sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    sheetMapping.addColumns(column, numberOfColumns);\n  }\n  removeColumns(removedColumns) {\n    const sheetMapping = this.mapping.get(removedColumns.sheet);\n    if (sheetMapping === undefined) {\n      throw new NoSheetWithIdError(removedColumns.sheet);\n    }\n    sheetMapping.removeColumns(removedColumns);\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    yield* this.mapping.get(rowsSpan.sheet).verticesFromRowsSpan(rowsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n  }\n\n  *verticesFromColumnsSpan(columnsSpan) {\n    yield* this.mapping.get(columnsSpan.sheet).verticesFromColumnsSpan(columnsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n  }\n\n  *entriesFromRowsSpan(rowsSpan) {\n    yield* this.mapping.get(rowsSpan.sheet).entriesFromRowsSpan(rowsSpan);\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    yield* this.mapping.get(columnsSpan.sheet).entriesFromColumnsSpan(columnsSpan);\n  }\n  *entries() {\n    for (const [sheet, mapping] of this.mapping.entries()) {\n      yield* mapping.getEntries(sheet);\n    }\n  }\n  *sheetEntries(sheet) {\n    const sheetMapping = this.mapping.get(sheet);\n    if (sheetMapping !== undefined) {\n      yield* sheetMapping.getEntries(sheet);\n    } else {\n      throw new NoSheetWithIdError(sheet);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}