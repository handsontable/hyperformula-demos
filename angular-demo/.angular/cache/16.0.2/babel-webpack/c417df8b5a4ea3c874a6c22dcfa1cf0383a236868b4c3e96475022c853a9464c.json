{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { Condition, CriterionFunctionCompute } from '../CriterionFunctionCompute';\nimport { getRawValue, isExtendedNumber } from '../InterpreterValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nclass AverageResult {\n  constructor(sum, count) {\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new AverageResult(arg, 1);\n  }\n  compose(other) {\n    return new AverageResult(this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nAverageResult.empty = new AverageResult(0, 0);\n/** Computes key for criterion function cache */\nfunction conditionalAggregationFunctionCacheKey(functionName) {\n  return conditions => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const conditionsStrings = conditions.map(c => `${c.conditionRange.range.sheet},${c.conditionRange.range.start.col},${c.conditionRange.range.start.row}`);\n    return [functionName, ...conditionsStrings].join(',');\n  };\n}\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nfunction mapToRawScalarValue(arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  }\n  if (isExtendedNumber(arg)) {\n    return getRawValue(arg);\n  }\n  return undefined;\n}\nexport class ConditionalAggregationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to SUMIF(Range, Criterion, SumRange)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   * SumRange is the range on which adding will be performed.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sumif(ast, state) {\n    const functionName = 'SUMIF';\n    const computeFn = (conditionRange, criterion, values) => this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  sumifs(ast, state) {\n    const functionName = 'SUMIFS';\n    const computeFn = (values, ...args) => this.computeConditionalAggregationFunction(values, args, functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  averageif(ast, state) {\n    const functionName = 'AVERAGEIF';\n    const computeFn = (conditionRange, criterion, values) => {\n      const averageResult = this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, AverageResult.empty, (left, right) => left.compose(right), arg => isExtendedNumber(arg) ? AverageResult.single(getRawValue(arg)) : AverageResult.empty);\n      if (averageResult instanceof CellError) {\n        return averageResult;\n      } else {\n        return averageResult.averageValue() || new CellError(ErrorType.DIV_BY_ZERO);\n      }\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  /**\r\n   * Corresponds to COUNTIF(Range, Criterion)\r\n   *\r\n   * Range is the range to which criterion is to be applied.\r\n   * Criterion is the criteria used to choose which cells will be included in sum.\r\n   *\r\n   * Returns number of cells on which criteria evaluate to true.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  countif(ast, state) {\n    const functionName = 'COUNTIF';\n    const computeFn = (conditionRange, criterion) => this.computeConditionalAggregationFunction(conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  countifs(ast, state) {\n    const functionName = 'COUNTIFS';\n    const computeFn = (...args) => this.computeConditionalAggregationFunction(args[0], args, functionName, 0, (left, right) => left + right, () => 1);\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  minifs(ast, state) {\n    const functionName = 'MINIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.min(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const minResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.POSITIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(minResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  maxifs(ast, state) {\n    const functionName = 'MAXIFS';\n    const composeFunction = (left, right) => {\n      if (right === undefined || left === undefined) {\n        return right === undefined ? left : right;\n      }\n      return Math.max(left, right);\n    };\n    const computeFn = (values, ...args) => {\n      const maxResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.NEGATIVE_INFINITY, composeFunction, mapToRawScalarValue);\n      return zeroForInfinite(maxResult);\n    };\n    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);\n  }\n  computeConditionalAggregationFunction(valuesRange, conditionArgs, functionName, reduceInitialValue, composeFunction, mapFunction) {\n    const conditions = [];\n    for (let i = 0; i < conditionArgs.length; i += 2) {\n      const conditionArg = conditionArgs[i];\n      const criterionPackage = this.interpreter.criterionBuilder.fromCellValue(conditionArgs[i + 1], this.arithmeticHelper);\n      if (criterionPackage === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadCriterion);\n      }\n      conditions.push(new Condition(conditionArg, criterionPackage));\n    }\n    return new CriterionFunctionCompute(this.interpreter, conditionalAggregationFunctionCacheKey(functionName), reduceInitialValue, composeFunction, mapFunction).compute(valuesRange, conditions);\n  }\n}\nConditionalAggregationPlugin.implementedFunctions = {\n  SUMIF: {\n    method: 'sumif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  COUNTIF: {\n    method: 'countif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }]\n  },\n  AVERAGEIF: {\n    method: 'averageif',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  SUMIFS: {\n    method: 'sumifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  COUNTIFS: {\n    method: 'countifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MINIFS: {\n    method: 'minifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  },\n  MAXIFS: {\n    method: 'maxifs',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    repeatLastArgs: 2\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}