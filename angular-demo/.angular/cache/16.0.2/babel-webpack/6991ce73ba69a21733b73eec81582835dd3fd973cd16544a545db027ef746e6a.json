{"ast":null,"code":"import { compact, contains, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map } from \"../../utils/utils\";\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\";\nimport { validTermsPattern } from \"../grammar/checks\";\nexport function defaultVisit(ctx, param) {\n  var childrenNames = keys(ctx);\n  var childrenNamesLength = childrenNames.length;\n  for (var i = 0; i < childrenNamesLength; i++) {\n    var currChildName = childrenNames[i];\n    var currChildArray = ctx[currChildName];\n    var currChildArrayLength = currChildArray.length;\n    for (var j = 0; j < currChildArrayLength; j++) {\n      var currChild = currChildArray[j];\n      // distinction between Tokens Children and CstNode children\n      if (currChild.tokenTypeIdx === undefined) {\n        if (currChild.fullName !== undefined) {\n          this[currChild.fullName](currChild.children, param);\n        } else {\n          this[currChild.name](currChild.children, param);\n        }\n      }\n    }\n  }\n  // defaultVisit does not support generic out param\n  return undefined;\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  var derivedConstructor = function () {};\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  var semanticProto = {\n    visit: function (cstNode, param) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      }\n      // enables passing optional CstNodes concisely.\n      if (isUndefined(cstNode)) {\n        return undefined;\n      }\n      if (cstNode.fullName !== undefined) {\n        return this[cstNode.fullName](cstNode.children, param);\n      } else {\n        return this[cstNode.name](cstNode.children, param);\n      }\n    },\n    validateVisitor: function () {\n      var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n      if (!isEmpty(semanticDefinitionErrors)) {\n        var errorMessages = map(semanticDefinitionErrors, function (currDefError) {\n          return currDefError.msg;\n        });\n        throw Error(\"Errors Detected in CST Visitor <\" + functionName(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  var derivedConstructor = function () {};\n  // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  var withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, function (ruleName) {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\nexport var CstVisitorDefinitionError = /*#__PURE__*/(() => {\n  CstVisitorDefinitionError = CstVisitorDefinitionError || {};\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n  return CstVisitorDefinitionError;\n})();\nexport function validateVisitor(visitorInstance, ruleNames) {\n  var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n  return missingErrors.concat(redundantErrors);\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n  var errors = map(ruleNames, function (currRuleName) {\n    if (!isFunction(visitorInstance[currRuleName])) {\n      return {\n        msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor.\",\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      };\n    }\n  });\n  return compact(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nexport function validateRedundantMethods(visitorInstance, ruleNames) {\n  var errors = [];\n  for (var prop in visitorInstance) {\n    if (validTermsPattern.test(prop) && isFunction(visitorInstance[prop]) && !contains(VALID_PROP_NAMES, prop) && !contains(ruleNames, prop)) {\n      errors.push({\n        msg: \"Redundant visitor method: <\" + prop + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor\\n\" + \"There is no Grammar Rule corresponding to this method's name.\\n\" + (\"For utility methods on visitor classes use methods names that do not match /\" + validTermsPattern.source + \"/.\"),\n        type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n        methodName: prop\n      });\n    }\n  }\n  return errors;\n}\n//# sourceMappingURL=cst_visitor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}