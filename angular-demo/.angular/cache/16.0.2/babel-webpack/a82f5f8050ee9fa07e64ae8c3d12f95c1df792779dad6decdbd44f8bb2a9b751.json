{"ast":null,"code":"import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset } from \"../../cst/cst\";\nimport { has, isUndefined, NOOP } from \"../../../utils/utils\";\nimport { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults } from \"../../cst/cst_visitor\";\nimport { getKeyForAltIndex } from \"../../grammar/keys\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */function () {\n  function TreeBuilder() {}\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.LAST_EXPLICIT_RULE_STACK = [];\n    this.CST_STACK = [];\n    this.outputCst = has(config, \"outputCst\") ? config.outputCst : DEFAULT_PARSER_CONFIG.outputCst;\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = NOOP;\n      this.cstFinallyStateUpdate = NOOP;\n      this.cstPostTerminal = NOOP;\n      this.cstPostNonTerminal = NOOP;\n      this.cstPostRule = NOOP;\n      this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;\n      this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;\n      this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;\n      this.manyInternal = this.manyInternalNoCst;\n      this.orInternal = this.orInternalNoCst;\n      this.optionInternal = this.optionInternalNoCst;\n      this.atLeastOneInternal = this.atLeastOneInternalNoCst;\n      this.manySepFirstInternal = this.manySepFirstInternalNoCst;\n      this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationFull;\n          this.setNodeLocationFromNode = setNodeLocationFull;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n          this.cstPostRule = NOOP;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = NOOP;\n          this.setNodeLocationFromNode = NOOP;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = NOOP;\n        this.setNodeLocationFromNode = NOOP;\n        this.cstPostRule = NOOP;\n        this.setInitialNodeLocation = NOOP;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n      }\n    }\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\n   *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n    * @param cstNode\n   */\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  // CST\n  TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {\n    var cstNode = {\n      name: nestedName,\n      fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] + nestedName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n    this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);\n    var cstNode = {\n      name: fullRuleName,\n      children: {}\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.LAST_EXPLICIT_RULE_STACK.pop();\n    this.CST_STACK.pop();\n  };\n  TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {\n    var lastCstNode = this.CST_STACK.pop();\n    // TODO: the naming is bad, this should go directly to the\n    //       (correct) cstLocation update method\n    //       e.g if we put other logic in postRule...\n    this.cstPostRule(lastCstNode);\n  };\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location;\n    // If this condition is true it means we consumed at least one Token\n    // In this CstNode or its nested children.\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    }\n    // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    addTerminalToCst(rootCst, consumedToken, key);\n    // This is only used when **both** error recovery and CST Output are enabled.\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    // Avoid side effects due to back tracking\n    // TODO: This costs a 2-3% in performance, A flag on IParserConfig\n    //   could be used to get rid of this conditional, but not sure its worth the effort\n    //   and API complexity.\n    if (this.isBackTracking() !== true) {\n      var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if (isUndefined(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, this.allRuleNames);\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n    return this.baseCstVisitorConstructor;\n  };\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n  TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {\n    var nestedName;\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, laKey);\n      return nestedName;\n    } else {\n      return undefined;\n    }\n  };\n  TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {\n    var ruleIdx = this.getLastExplicitRuleShortName();\n    var shortName = getKeyForAltIndex(ruleIdx, methodKeyIdx, occurrence, altIdx);\n    var nestedName;\n    if (methodOpts.NAME !== undefined) {\n      nestedName = methodOpts.NAME;\n      this.nestedRuleInvocationStateUpdate(nestedName, shortName);\n      return {\n        shortName: shortName,\n        nestedName: nestedName\n      };\n    } else {\n      return undefined;\n    }\n  };\n  TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {\n    var cstStack = this.CST_STACK;\n    var nestedRuleCst = cstStack[cstStack.length - 1];\n    this.nestedRuleFinallyStateUpdate();\n    // this return a different result than the previous invocation because \"nestedRuleFinallyStateUpdate\" pops the cst stack\n    var parentCstNode = cstStack[cstStack.length - 1];\n    addNoneTerminalToCst(parentCstNode, nestedName, nestedRuleCst);\n    this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_STACK[lastExplictIndex];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];\n    return this.RULE_STACK[lastExplicitIndex];\n  };\n  TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];\n    return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];\n  };\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n  TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {\n    this.RULE_OCCURRENCE_STACK.push(1);\n    this.RULE_STACK.push(shortNameKey);\n    this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);\n  };\n  TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {\n    this.RULE_STACK.pop();\n    this.RULE_OCCURRENCE_STACK.pop();\n    // NOOP when cst is disabled\n    this.cstNestedFinallyStateUpdate();\n  };\n  return TreeBuilder;\n}();\nexport { TreeBuilder };\n//# sourceMappingURL=tree_builder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}