{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from '../Cell';\nimport { Transformer } from './Transformer';\nexport class RemoveRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed row in same sheet where dependency is but formula in different\n    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n      if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n      }\n    }\n    // Case 2 -- removed row in same sheet where formula but dependency in different sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        if (dependencyAddress.row < this.rowsSpan.rowStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.row > this.rowsSpan.rowEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n        if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n          }\n        } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {\n          if (formulaAddress.row < this.rowsSpan.rowStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row - this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.rowsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleRowAddress(formulaAddress);\n      const endSCA = end.toSimpleRowAddress(formulaAddress);\n      if (this.rowsSpan.rowStart <= startSCA.row && this.rowsSpan.rowEnd >= endSCA.row) {\n        return ErrorType.REF;\n      }\n      if (startSCA.row >= this.rowsSpan.rowStart && startSCA.row <= this.rowsSpan.rowEnd) {\n        actualStart = start.shiftedByRows(this.rowsSpan.rowEnd - startSCA.row + 1);\n      }\n      if (endSCA.row >= this.rowsSpan.rowStart && endSCA.row <= this.rowsSpan.rowEnd) {\n        actualEnd = end.shiftedByRows(-(endSCA.row - this.rowsSpan.rowStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}