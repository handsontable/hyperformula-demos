{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellRange } from '../AbsoluteCellRange';\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from './CellAddress';\nimport { ColumnAddress } from './ColumnAddress';\nimport { ABSOLUTE_OPERATOR, RANGE_OPERATOR, SHEET_NAME_PATTERN, UNQUOTED_SHEET_NAME_PATTERN } from './parser-consts';\nimport { RowAddress } from './RowAddress';\nconst addressRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst columnRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([A-Za-z]+)$`);\nconst rowRegex = new RegExp(`^(${SHEET_NAME_PATTERN})?(\\\\${ABSOLUTE_OPERATOR}?)([0-9]+)$`);\nconst simpleSheetNameRegex = new RegExp(`^${UNQUOTED_SHEET_NAME_PATTERN}$`);\n/**\r\n * Computes R0C0 representation of cell address based on it's string representation and base address.\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g. 'C64'\r\n * @param baseAddress - base address for R0C0 conversion\r\n * @returns object representation of address\r\n */\nexport const cellAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = addressRegex.exec(stringAddress);\n  const col = columnLabelToIndex(result[6]);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[8]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR && result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absolute(col, row, sheet);\n  } else if (result[5] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteCol(col, row - baseAddress.row, sheet);\n  } else if (result[7] === ABSOLUTE_OPERATOR) {\n    return CellAddress.absoluteRow(col - baseAddress.col, row, sheet);\n  } else {\n    return CellAddress.relative(col - baseAddress.col, row - baseAddress.row, sheet);\n  }\n};\nexport const columnAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = columnRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const col = columnLabelToIndex(result[6]);\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return ColumnAddress.absolute(col, sheet);\n  } else {\n    return ColumnAddress.relative(col - baseAddress.col, sheet);\n  }\n};\nexport const rowAddressFromString = (sheetMapping, stringAddress, baseAddress) => {\n  const result = rowRegex.exec(stringAddress);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = undefined;\n  }\n  const row = Number(result[6]) - 1;\n  if (result[5] === ABSOLUTE_OPERATOR) {\n    return RowAddress.absolute(row, sheet);\n  } else {\n    return RowAddress.relative(row - baseAddress.row, sheet);\n  }\n};\n/**\r\n * Computes simple (absolute) address of a cell address based on its string representation.\r\n * If sheet name present in string representation but is not present in sheet mapping, returns undefined.\r\n * If sheet name is not present in string representation, returns {@param sheetContext} as sheet number\r\n *\r\n * @param sheetMapping - mapping function needed to change name of a sheet to index\r\n * @param stringAddress - string representation of cell address, e.g. 'C64'\r\n * @param sheetContext - sheet in context of which we should parse the address\r\n * @returns absolute representation of address, e.g. { sheet: 0, col: 1, row: 1 }\r\n */\nexport const simpleCellAddressFromString = (sheetMapping, stringAddress, sheetContext) => {\n  const result = addressRegex.exec(stringAddress);\n  const col = columnLabelToIndex(result[6]);\n  let sheet = extractSheetNumber(result, sheetMapping);\n  if (sheet === undefined) {\n    return undefined;\n  }\n  if (sheet === null) {\n    sheet = sheetContext;\n  }\n  const row = Number(result[8]) - 1;\n  return simpleCellAddress(sheet, col, row);\n};\nexport const simpleCellRangeFromString = (sheetMapping, stringAddress, sheetContext) => {\n  const split = stringAddress.split(RANGE_OPERATOR);\n  if (split.length !== 2) {\n    return undefined;\n  }\n  const [startString, endString] = split;\n  const start = simpleCellAddressFromString(sheetMapping, startString, sheetContext);\n  if (start === undefined) {\n    return undefined;\n  }\n  const end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);\n  if (end === undefined) {\n    return undefined;\n  }\n  if (start.sheet !== end.sheet) {\n    return undefined;\n  }\n  return simpleCellRange(start, end);\n};\n/**\r\n * Returns string representation of absolute address\r\n * If sheet index is not present in sheet mapping, returns undefined\r\n *\r\n * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name\r\n * @param address - object representation of absolute address\r\n * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name\r\n */\nexport const simpleCellAddressToString = (sheetIndexMapping, address, sheetIndex) => {\n  const column = columnIndexToLabel(address.col);\n  const sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (sheetIndex !== address.sheet) {\n    return `${sheetName}!${column}${address.row + 1}`;\n  } else {\n    return `${column}${address.row + 1}`;\n  }\n};\nexport const simpleCellRangeToString = (sheetIndexMapping, address, sheetIndex) => {\n  const startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);\n  const endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);\n  if (startString === undefined || endString === undefined) {\n    return undefined;\n  } else {\n    return `${startString}${RANGE_OPERATOR}${endString}`;\n  }\n};\n/**\r\n * Convert column label to index\r\n *\r\n * @param columnStringRepresentation - column label (e.g. 'AAB')\r\n * @returns column index\r\n */\nfunction columnLabelToIndex(columnStringRepresentation) {\n  if (columnStringRepresentation.length === 1) {\n    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;\n  } else {\n    return columnStringRepresentation.split('').reduce((currentColumn, nextLetter) => {\n      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);\n    }, 0) - 1;\n  }\n}\n/**\r\n * Converts column index to label\r\n *\r\n * @param column - address to convert\r\n * @returns string representation, e.g. 'AAB'\r\n */\nexport function columnIndexToLabel(column) {\n  let result = '';\n  while (column >= 0) {\n    result = String.fromCharCode(column % 26 + 97) + result;\n    column = Math.floor(column / 26) - 1;\n  }\n  return result.toUpperCase();\n}\nexport function sheetIndexToString(sheetId, sheetMappingFn) {\n  let sheetName = sheetMappingFn(sheetId);\n  if (sheetName === undefined) {\n    return undefined;\n  }\n  if (simpleSheetNameRegex.test(sheetName)) {\n    return sheetName;\n  } else {\n    sheetName = sheetName.replace(/'/g, \"''\");\n    return `'${sheetName}'`;\n  }\n}\nfunction extractSheetNumber(regexResult, sheetMapping) {\n  var _a;\n  let maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];\n  if (maybeSheetName) {\n    maybeSheetName = maybeSheetName.replace(/''/g, \"'\");\n    return sheetMapping(maybeSheetName);\n  } else {\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}