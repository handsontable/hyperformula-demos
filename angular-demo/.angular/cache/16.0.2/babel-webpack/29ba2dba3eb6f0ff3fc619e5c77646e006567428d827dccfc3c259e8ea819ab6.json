{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from '../AbsoluteCellRange';\nimport { ArraySize } from '../ArraySize';\nimport { ArrayValue, ErroredArray, NotComputedArray } from '../ArrayValue';\nimport { CellError, equalSimpleCellAddress, ErrorType } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { EmptyValue, getRawValue } from '../interpreter/InterpreterValue';\nimport { ColumnsSpan, RowsSpan } from '../Span';\nexport class FormulaVertex {\n  constructor(formula, cellAddress, version) {\n    this.formula = formula;\n    this.cellAddress = cellAddress;\n    this.version = version;\n  }\n  get width() {\n    return 1;\n  }\n  get height() {\n    return 1;\n  }\n  static fromAst(formula, address, size, version) {\n    if (size.isScalar()) {\n      return new FormulaCellVertex(formula, address, version);\n    } else {\n      return new ArrayVertex(formula, address, size, version);\n    }\n  }\n  /**\r\n   * Returns formula stored in this vertex\r\n   */\n  getFormula(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.formula;\n  }\n  ensureRecentData(updatingService) {\n    if (this.version != updatingService.version()) {\n      const [newAst, newAddress, newVersion] = updatingService.applyTransformations(this.formula, this.cellAddress, this.version);\n      this.formula = newAst;\n      this.cellAddress = newAddress;\n      this.version = newVersion;\n    }\n  }\n  /**\r\n   * Returns address of the cell associated with vertex\r\n   */\n  getAddress(updatingService) {\n    this.ensureRecentData(updatingService);\n    return this.cellAddress;\n  }\n}\nexport class ArrayVertex extends FormulaVertex {\n  constructor(formula, cellAddress, size, version = 0) {\n    super(formula, cellAddress, version);\n    if (size.isRef) {\n      this.array = new ErroredArray(new CellError(ErrorType.REF, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    } else {\n      this.array = new NotComputedArray(size);\n    }\n  }\n  get width() {\n    return this.array.width();\n  }\n  get height() {\n    return this.array.height();\n  }\n  get sheet() {\n    return this.cellAddress.sheet;\n  }\n  get leftCorner() {\n    return this.cellAddress;\n  }\n  setCellValue(value) {\n    if (value instanceof CellError) {\n      this.setErrorValue(value);\n      return value;\n    }\n    const array = ArrayValue.fromInterpreterValue(value);\n    array.resize(this.array.size);\n    this.array = array;\n    return value;\n  }\n  getCellValue() {\n    if (this.array instanceof NotComputedArray) {\n      throw Error('Array not computed yet.');\n    }\n    return this.array.simpleRangeValue();\n  }\n  valueOrUndef() {\n    if (this.array instanceof NotComputedArray) {\n      return undefined;\n    }\n    return this.array.simpleRangeValue();\n  }\n  getArrayCellValue(address) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    try {\n      return this.array.get(col, row);\n    } catch (e) {\n      return new CellError(ErrorType.REF);\n    }\n  }\n  getArrayCellRawValue(address) {\n    const val = this.getArrayCellValue(address);\n    if (val instanceof CellError || val === EmptyValue) {\n      return undefined;\n    } else {\n      return getRawValue(val);\n    }\n  }\n  setArrayCellValue(address, value) {\n    const col = address.col - this.cellAddress.col;\n    const row = address.row - this.cellAddress.row;\n    if (this.array instanceof ArrayValue) {\n      this.array.set(col, row, value);\n    }\n  }\n  setNoSpace() {\n    this.array = new ErroredArray(new CellError(ErrorType.SPILL, ErrorMessage.NoSpaceForArrayResult), ArraySize.error());\n    return this.getCellValue();\n  }\n  getRange() {\n    return AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);\n  }\n  getRangeOrUndef() {\n    return AbsoluteCellRange.spanFromOrUndef(this.cellAddress, this.width, this.height);\n  }\n  setAddress(address) {\n    this.cellAddress = address;\n  }\n  setFormula(newFormula) {\n    this.formula = newFormula;\n  }\n  spansThroughSheetRows(sheet, startRow, endRow = startRow) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;\n  }\n  spansThroughSheetColumn(sheet, col, columnEnd = col) {\n    return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;\n  }\n  isComputed() {\n    return !(this.array instanceof NotComputedArray);\n  }\n  columnsFromArray() {\n    return ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);\n  }\n  rowsFromArray() {\n    return RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);\n  }\n  /**\r\n   * No-op as array vertices are transformed eagerly.\r\n   */\n  ensureRecentData(_updatingService) {}\n  isLeftCorner(address) {\n    return equalSimpleCellAddress(this.cellAddress, address);\n  }\n  setErrorValue(error) {\n    this.array = new ErroredArray(error, this.array.size);\n  }\n}\n/**\r\n * Represents vertex which keeps formula\r\n */\nexport class FormulaCellVertex extends FormulaVertex {\n  constructor( /** Formula in AST format */\n  formula, /** Address which this vertex represents */\n  address, version) {\n    super(formula, address, version);\n  }\n  valueOrUndef() {\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Sets computed cell value stored in this vertex\r\n   */\n  setCellValue(cellValue) {\n    this.cachedCellValue = cellValue;\n    return this.cachedCellValue;\n  }\n  /**\r\n   * Returns cell value stored in vertex\r\n   */\n  getCellValue() {\n    if (this.cachedCellValue !== undefined) {\n      return this.cachedCellValue;\n    } else {\n      throw Error('Value of the formula cell is not computed.');\n    }\n  }\n  isComputed() {\n    return this.cachedCellValue !== undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}