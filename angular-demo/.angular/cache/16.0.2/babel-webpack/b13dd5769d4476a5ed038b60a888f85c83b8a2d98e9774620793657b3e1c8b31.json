{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../Cell';\nimport { AstNodeType, buildCellErrorAst, CellAddress } from '../parser';\nexport class Transformer {\n  performEagerTransformations(graph, parser) {\n    for (const node of graph.arrayFormulaNodes()) {\n      const [newAst, newAddress] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));\n      const cachedAst = parser.rememberNewAst(newAst);\n      node.setFormula(cachedAst);\n      node.setAddress(newAddress);\n    }\n  }\n  transformSingleAst(ast, address) {\n    const newAst = this.transformAst(ast, address);\n    const newAddress = this.fixNodeAddress(address);\n    return [newAst, newAddress];\n  }\n  transformAst(ast, address) {\n    switch (ast.type) {\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return this.transformCellReferenceAst(ast, address);\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          return this.transformCellRangeAst(ast, address);\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          return this.transformColumnRangeAst(ast, address);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          return this.transformRowRangeAst(ast, address);\n        }\n      case AstNodeType.EMPTY:\n      case AstNodeType.ERROR:\n      case AstNodeType.NUMBER:\n      case AstNodeType.NAMED_EXPRESSION:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.STRING:\n        {\n          return ast;\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            value: this.transformAst(ast.value, address)\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            procedureName: ast.procedureName,\n            args: ast.args.map(arg => this.transformAst(arg, address))\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            expression: this.transformAst(ast.expression, address)\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            args: ast.args.map(row => row.map(val => this.transformAst(val, address)))\n          });\n        }\n      default:\n        {\n          return Object.assign(Object.assign({}, ast), {\n            left: this.transformAst(ast.left, address),\n            right: this.transformAst(ast.right, address)\n          });\n        }\n    }\n  }\n  transformCellReferenceAst(ast, formulaAddress) {\n    const newCellAddress = this.transformCellAddress(ast.reference, formulaAddress);\n    if (newCellAddress instanceof CellAddress) {\n      return Object.assign(Object.assign({}, ast), {\n        reference: newCellAddress\n      });\n    } else if (newCellAddress === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformCellRangeAst(ast, formulaAddress) {\n    const newRange = this.transformCellRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformColumnRangeAst(ast, formulaAddress) {\n    const newRange = this.transformColumnRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n  transformRowRangeAst(ast, formulaAddress) {\n    const newRange = this.transformRowRange(ast.start, ast.end, formulaAddress);\n    if (Array.isArray(newRange)) {\n      return Object.assign(Object.assign({}, ast), {\n        start: newRange[0],\n        end: newRange[1]\n      });\n    } else if (newRange === ErrorType.REF) {\n      return buildCellErrorAst(new CellError(ErrorType.REF));\n    } else {\n      return ast;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}