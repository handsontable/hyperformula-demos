{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from '../../AbsoluteCellRange';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { coerceRangeToScalar, coerceScalarToBoolean, coerceScalarToString, coerceToRange } from '../ArithmeticHelper';\nimport { getRawValue, isExtendedNumber } from '../InterpreterValue';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nexport var FunctionArgumentType = /*#__PURE__*/(() => {\n  FunctionArgumentType = FunctionArgumentType || {};\n  /**\r\n   * String type.\r\n   */\n  FunctionArgumentType[\"STRING\"] = \"STRING\";\n  /**\r\n   * Floating point type.\r\n   */\n  FunctionArgumentType[\"NUMBER\"] = \"NUMBER\";\n  /**\r\n   * Boolean type.\r\n   */\n  FunctionArgumentType[\"BOOLEAN\"] = \"BOOLEAN\";\n  /**\r\n   * Any non-range value.\r\n   */\n  FunctionArgumentType[\"SCALAR\"] = \"SCALAR\";\n  /**\r\n   * Any non-range, no-error type.\r\n   */\n  FunctionArgumentType[\"NOERROR\"] = \"NOERROR\";\n  /**\r\n   * Range type.\r\n   */\n  FunctionArgumentType[\"RANGE\"] = \"RANGE\";\n  /**\r\n   * Integer type.\r\n   */\n  FunctionArgumentType[\"INTEGER\"] = \"INTEGER\";\n  /**\r\n   * String representing complex number.\r\n   */\n  FunctionArgumentType[\"COMPLEX\"] = \"COMPLEX\";\n  /**\r\n   * Range or scalar.\r\n   */\n  FunctionArgumentType[\"ANY\"] = \"ANY\";\n  return FunctionArgumentType;\n})();\n/**\r\n * Abstract class representing interpreter function plugin.\r\n * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be\r\n * included in {@link implementedFunctions}\r\n */\nexport class FunctionPlugin {\n  constructor(interpreter) {\n    this.coerceScalarToNumberOrError = arg => this.arithmeticHelper.coerceScalarToNumberOrError(arg);\n    /**\r\n     * A method that should wrap the logic of every built-in function and custom function. It:\r\n     * - Evaluates the function's arguments.\r\n     * - Validates the number of arguments against the [`parameters` array](#function-options).\r\n     * - Coerces the argument values to types set in the [`parameters` array](#argument-validation-options).\r\n     * - Handles optional arguments and default values according to options set in the [`parameters` array](#argument-validation-options).\r\n     * - Validates the function's arguments against the [argument validation options](#argument-validation-options).\r\n     * - Duplicates the arguments according to the [`repeatLastArgs` option](#function-options).\r\n     * - Handles the [array arithmetic mode](arrays.md#array-arithmetic-mode).\r\n     * - Performs [function vectorization](arrays.md#passing-arrays-to-scalar-functions-vectorization).\r\n     * - Performs [argument broadcasting](arrays.md#broadcasting).\r\n     */\n    this.runFunction = (args, state, metadata, functionImplementation) => {\n      const evaluatedArguments = this.evaluateArguments(args, state, metadata);\n      const argumentValues = evaluatedArguments.map(([value, _]) => value);\n      const argumentIgnorableFlags = evaluatedArguments.map(([_, ignorable]) => ignorable);\n      const argumentMetadata = this.buildMetadataForEachArgumentValue(argumentValues.length, metadata);\n      const isVectorizationOn = state.arraysFlag && !metadata.vectorizationForbidden;\n      if (!this.isNumberOfArgumentValuesValid(argumentMetadata, argumentValues.length)) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      const [resultArrayHeight, resultArrayWidth] = isVectorizationOn ? this.calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) : [1, 1];\n      if (resultArrayHeight === 1 && resultArrayWidth === 1) {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, 0, 0);\n        return this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n      }\n      const resultArray = [...Array(resultArrayHeight).keys()].map(row => [...Array(resultArrayWidth).keys()].map(col => {\n        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col);\n        const result = this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);\n        if (result instanceof SimpleRangeValue) {\n          throw new Error('Function returning array cannot be vectorized.');\n        }\n        return result;\n      }));\n      return SimpleRangeValue.onlyValues(resultArray);\n    };\n    this.runFunctionWithReferenceArgument = (args, state, metadata, noArgCallback, referenceCallback, nonReferenceCallback = () => new CellError(ErrorType.NA, ErrorMessage.CellRefExpected)) => {\n      if (args.length === 0) {\n        return this.returnNumberWrapper(noArgCallback(), metadata.returnNumberType);\n      } else if (args.length > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n      }\n      let arg = args[0];\n      while (arg.type === AstNodeType.PARENTHESIS) {\n        arg = arg.expression;\n      }\n      let cellReference;\n      if (arg.type === AstNodeType.CELL_REFERENCE) {\n        cellReference = arg.reference.toSimpleCellAddress(state.formulaAddress);\n      } else if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        try {\n          cellReference = AbsoluteCellRange.fromAst(arg, state.formulaAddress).start;\n        } catch (e) {\n          return new CellError(ErrorType.REF, ErrorMessage.CellRefExpected);\n        }\n      }\n      if (cellReference !== undefined) {\n        return this.returnNumberWrapper(referenceCallback(cellReference), metadata.returnNumberType);\n      }\n      return this.runFunction(args, state, metadata, nonReferenceCallback);\n    };\n    this.interpreter = interpreter;\n    this.dependencyGraph = interpreter.dependencyGraph;\n    this.columnSearch = interpreter.columnSearch;\n    this.config = interpreter.config;\n    this.serialization = interpreter.serialization;\n    this.arraySizePredictor = interpreter.arraySizePredictor;\n    this.dateTimeHelper = interpreter.dateTimeHelper;\n    this.arithmeticHelper = interpreter.arithmeticHelper;\n  }\n  evaluateAst(ast, state) {\n    return this.interpreter.evaluateAst(ast, state);\n  }\n  arraySizeForAst(ast, state) {\n    return this.arraySizePredictor.checkArraySizeForAst(ast, state);\n  }\n  listOfScalarValues(asts, state) {\n    const ret = [];\n    for (const argAst of asts) {\n      const value = this.evaluateAst(argAst, state);\n      if (value instanceof SimpleRangeValue) {\n        for (const scalarValue of value.valuesFromTopLeftCorner()) {\n          ret.push([scalarValue, true]);\n        }\n      } else {\n        ret.push([value, false]);\n      }\n    }\n    return ret;\n  }\n  coerceToType(arg, coercedType, state) {\n    let ret;\n    if (arg instanceof SimpleRangeValue) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.RANGE:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        default:\n          {\n            const coerce = coerceRangeToScalar(arg, state);\n            if (coerce === undefined) {\n              return undefined;\n            }\n            arg = coerce;\n          }\n      }\n    }\n    if (!(arg instanceof SimpleRangeValue)) {\n      switch (coercedType.argumentType) {\n        case FunctionArgumentType.INTEGER:\n        case FunctionArgumentType.NUMBER:\n          // eslint-disable-next-line no-case-declarations\n          const coerced = this.coerceScalarToNumberOrError(arg);\n          if (!isExtendedNumber(coerced)) {\n            ret = coerced;\n            break;\n          }\n          // eslint-disable-next-line no-case-declarations\n          const value = getRawValue(coerced);\n          if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.minValue !== undefined && value < coercedType.minValue) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n          }\n          if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {\n            return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n          }\n          if (coercedType.argumentType === FunctionArgumentType.INTEGER && !Number.isInteger(value)) {\n            return new CellError(ErrorType.NUM, ErrorMessage.IntegerExpected);\n          }\n          ret = coerced;\n          break;\n        case FunctionArgumentType.STRING:\n          ret = coerceScalarToString(arg);\n          break;\n        case FunctionArgumentType.BOOLEAN:\n          ret = coerceScalarToBoolean(arg);\n          break;\n        case FunctionArgumentType.SCALAR:\n        case FunctionArgumentType.NOERROR:\n        case FunctionArgumentType.ANY:\n          ret = arg;\n          break;\n        case FunctionArgumentType.RANGE:\n          if (arg instanceof CellError) {\n            return arg;\n          }\n          ret = coerceToRange(arg);\n          break;\n        case FunctionArgumentType.COMPLEX:\n          return this.arithmeticHelper.coerceScalarToComplex(getRawValue(arg));\n      }\n    }\n    if (coercedType.passSubtype || ret === undefined) {\n      return ret;\n    } else {\n      return getRawValue(ret);\n    }\n  }\n  calculateSingleCellOfResultArray(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags, functionImplementation, returnNumberType) {\n    const coercedArguments = this.coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags);\n    if (coercedArguments instanceof CellError) {\n      return coercedArguments;\n    }\n    const functionCalculationResult = functionImplementation(...coercedArguments);\n    return this.returnNumberWrapper(functionCalculationResult, returnNumberType);\n  }\n  coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags) {\n    const coercedArguments = [];\n    for (let i = 0; i < argumentsMetadata.length; i++) {\n      const argumentMetadata = argumentsMetadata[i];\n      const argumentValue = vectorizedArguments[i] !== undefined ? vectorizedArguments[i] : argumentMetadata === null || argumentMetadata === void 0 ? void 0 : argumentMetadata.defaultValue;\n      if (argumentValue === undefined) {\n        coercedArguments.push(undefined);\n        continue;\n      }\n      const coercedValue = this.coerceToType(argumentValue, argumentMetadata, state);\n      if (coercedValue === undefined && !argumentIgnorableFlags[i]) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n      if (coercedValue instanceof CellError && argumentMetadata.argumentType !== FunctionArgumentType.SCALAR) {\n        return coercedValue;\n      }\n      coercedArguments.push(coercedValue);\n    }\n    return coercedArguments;\n  }\n  vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col) {\n    return argumentValues.map((value, i) => isVectorizationOn && this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]) ? this.vectorizeAndBroadcastRangeArgument(value, row, col) : value);\n  }\n  vectorizeAndBroadcastRangeArgument(argumentValue, rowNum, colNum) {\n    var _a;\n    const targetRowNum = argumentValue.height() === 1 ? 0 : rowNum;\n    const targetColNum = argumentValue.width() === 1 ? 0 : colNum;\n    return (_a = argumentValue.data[targetRowNum]) === null || _a === void 0 ? void 0 : _a[targetColNum];\n  }\n  evaluateArguments(args, state, metadata) {\n    return metadata.expandRanges ? this.listOfScalarValues(args, state) : args.map(ast => [this.evaluateAst(ast, state), false]);\n  }\n  buildMetadataForEachArgumentValue(numberOfArgumentValuesPassed, metadata) {\n    const argumentsMetadata = metadata.parameters ? [...metadata.parameters] : [];\n    const isRepeatLastArgsValid = metadata.repeatLastArgs !== undefined && Number.isInteger(metadata.repeatLastArgs) && metadata.repeatLastArgs > 0;\n    if (isRepeatLastArgsValid) {\n      while (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n        argumentsMetadata.push(...argumentsMetadata.slice(argumentsMetadata.length - metadata.repeatLastArgs));\n      }\n    }\n    return argumentsMetadata;\n  }\n  isNumberOfArgumentValuesValid(argumentsMetadata, numberOfArgumentValuesPassed) {\n    if (numberOfArgumentValuesPassed > argumentsMetadata.length) {\n      return false;\n    }\n    if (numberOfArgumentValuesPassed < argumentsMetadata.length) {\n      const metadataForMissingArguments = argumentsMetadata.slice(numberOfArgumentValuesPassed);\n      const areMissingArgumentsOptional = metadataForMissingArguments.every(argMetadata => (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.optionalArg) || (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.defaultValue) !== undefined);\n      return areMissingArgumentsOptional;\n    }\n    return true;\n  }\n  calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) {\n    const argumentsThatRequireVectorization = argumentValues.filter((value, i) => this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]));\n    const height = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.height()));\n    const width = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.width()));\n    return [height, width];\n  }\n  isRangePassedAsAScalarArgument(argumentValue, argumentMetadata) {\n    if (argumentValue == null || argumentMetadata == null) {\n      return false;\n    }\n    return argumentValue instanceof SimpleRangeValue && ![FunctionArgumentType.RANGE, FunctionArgumentType.ANY].includes(argumentMetadata.argumentType);\n  }\n  metadata(name) {\n    const params = this.constructor.implementedFunctions[name];\n    if (params !== undefined) {\n      return params;\n    }\n    throw new Error(`No metadata for function ${name}.`);\n  }\n  returnNumberWrapper(val, type, format) {\n    if (type !== undefined && isExtendedNumber(val)) {\n      return this.arithmeticHelper.ExtendedNumberFactory(getRawValue(val), {\n        type,\n        format\n      });\n    } else {\n      return val;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}