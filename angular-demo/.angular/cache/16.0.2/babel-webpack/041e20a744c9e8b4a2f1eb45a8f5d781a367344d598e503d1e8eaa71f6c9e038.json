{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from './Cell';\nimport { timeToNumber } from './DateTimeHelper';\nimport { ErrorMessage } from './error-message';\nimport { UnableToParseError } from './errors';\nimport { fixNegativeZero, isNumberOverflow } from './interpreter/ArithmeticHelper';\nimport { cloneNumber, CurrencyNumber, DateNumber, DateTimeNumber, getRawValue, PercentNumber, TimeNumber } from './interpreter/InterpreterValue';\nexport var CellContent;\n(function (CellContent) {\n  class Number {\n    constructor(value) {\n      this.value = value;\n      this.value = cloneNumber(this.value, fixNegativeZero(getRawValue(this.value)));\n    }\n  }\n  CellContent.Number = Number;\n  class String {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n  CellContent.String = String;\n  class Boolean {\n    constructor(value) {\n      this.value = value;\n    }\n  }\n  CellContent.Boolean = Boolean;\n  class Empty {\n    static getSingletonInstance() {\n      if (!Empty.instance) {\n        Empty.instance = new Empty();\n      }\n      return Empty.instance;\n    }\n  }\n  CellContent.Empty = Empty;\n  class Formula {\n    constructor(formula) {\n      this.formula = formula;\n    }\n  }\n  CellContent.Formula = Formula;\n  class Error {\n    constructor(errorType, message) {\n      this.value = new CellError(errorType, message);\n    }\n  }\n  CellContent.Error = Error;\n})(CellContent || (CellContent = {}));\n/**\r\n * Checks whether string looks like formula or not.\r\n *\r\n * @param text - formula\r\n */\nexport function isFormula(text) {\n  return text.startsWith('=');\n}\nexport function isBoolean(text) {\n  const tl = text.toLowerCase();\n  return tl === 'true' || tl === 'false';\n}\nexport function isError(text, errorMapping) {\n  const upperCased = text.toUpperCase();\n  const errorRegex = /#[A-Za-z0-9\\/]+[?!]?/;\n  return errorRegex.test(upperCased) && Object.prototype.hasOwnProperty.call(errorMapping, upperCased);\n}\nexport class CellContentParser {\n  constructor(config, dateHelper, numberLiteralsHelper) {\n    this.config = config;\n    this.dateHelper = dateHelper;\n    this.numberLiteralsHelper = numberLiteralsHelper;\n  }\n  parse(content) {\n    if (content === undefined || content === null) {\n      return CellContent.Empty.getSingletonInstance();\n    } else if (typeof content === 'number') {\n      if (isNumberOverflow(content)) {\n        return new CellContent.Error(ErrorType.NUM, ErrorMessage.ValueLarge);\n      } else {\n        return new CellContent.Number(content);\n      }\n    } else if (typeof content === 'boolean') {\n      return new CellContent.Boolean(content);\n    } else if (content instanceof Date) {\n      const dateVal = this.dateHelper.dateToNumber({\n        day: content.getDate(),\n        month: content.getMonth() + 1,\n        year: content.getFullYear()\n      });\n      const timeVal = timeToNumber({\n        hours: content.getHours(),\n        minutes: content.getMinutes(),\n        seconds: content.getSeconds() + content.getMilliseconds() / 1000\n      });\n      const val = dateVal + timeVal;\n      if (val < 0) {\n        return new CellContent.Error(ErrorType.NUM, ErrorMessage.DateBounds);\n      }\n      if (val % 1 === 0) {\n        return new CellContent.Number(new DateNumber(val, 'Date()'));\n      } else if (val < 1) {\n        return new CellContent.Number(new TimeNumber(val, 'Date()'));\n      } else {\n        return new CellContent.Number(new DateTimeNumber(val, 'Date()'));\n      }\n    } else if (typeof content === 'string') {\n      if (isBoolean(content)) {\n        return new CellContent.Boolean(content.toLowerCase() === 'true');\n      } else if (isFormula(content)) {\n        return new CellContent.Formula(content);\n      } else if (isError(content, this.config.errorMapping)) {\n        return new CellContent.Error(this.config.errorMapping[content.toUpperCase()]);\n      } else {\n        let trimmedContent = content.trim();\n        let mode = 0;\n        let currency;\n        if (trimmedContent.endsWith('%')) {\n          mode = 1;\n          trimmedContent = trimmedContent.slice(0, trimmedContent.length - 1);\n        } else {\n          const res = this.currencyMatcher(trimmedContent);\n          if (res !== undefined) {\n            mode = 2;\n            [currency, trimmedContent] = res;\n          }\n        }\n        const val = this.numberLiteralsHelper.numericStringToMaybeNumber(trimmedContent);\n        if (val !== undefined) {\n          let parseAsNum;\n          if (mode === 1) {\n            parseAsNum = new PercentNumber(val / 100);\n          } else if (mode === 2) {\n            parseAsNum = new CurrencyNumber(val, currency);\n          } else {\n            parseAsNum = val;\n          }\n          return new CellContent.Number(parseAsNum);\n        }\n        const parsedDateNumber = this.dateHelper.dateStringToDateNumber(trimmedContent);\n        if (parsedDateNumber !== undefined) {\n          return new CellContent.Number(parsedDateNumber);\n        } else {\n          return new CellContent.String(content.startsWith('\\'') ? content.slice(1) : content);\n        }\n      }\n    } else {\n      throw new UnableToParseError(content);\n    }\n  }\n  currencyMatcher(token) {\n    for (const currency of this.config.currencySymbol) {\n      if (token.startsWith(currency)) {\n        return [currency, token.slice(currency.length)];\n      }\n      if (token.endsWith(currency)) {\n        return [currency, token.slice(0, token.length - currency.length)];\n      }\n    }\n    return undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}