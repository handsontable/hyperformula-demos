{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { getRawValue } from './interpreter/InterpreterValue';\nimport { StatType } from './statistics';\n/**\r\n * Service building the graph and mappings.\r\n */\nexport class GraphBuilder {\n  /**\r\n   * Configures the building service.\r\n   */\n  constructor(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.stats = stats;\n    this.arraySizePredictor = arraySizePredictor;\n    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);\n  }\n  /**\r\n   * Builds graph.\r\n   */\n  buildGraph(sheets, stats) {\n    const dependencies = stats.measure(StatType.COLLECT_DEPENDENCIES, () => this.buildStrategy.run(sheets));\n    this.dependencyGraph.getAndClearContentChanges();\n    stats.measure(StatType.PROCESS_DEPENDENCIES, () => this.processDependencies(dependencies));\n  }\n  processDependencies(dependencies) {\n    dependencies.forEach((cellDependencies, endVertex) => {\n      this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);\n    });\n  }\n}\nexport class SimpleStrategy {\n  constructor(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnIndex = columnIndex;\n    this.parser = parser;\n    this.stats = stats;\n    this.cellContentParser = cellContentParser;\n    this.arraySizePredictor = arraySizePredictor;\n  }\n  run(sheets) {\n    const dependencies = new Map();\n    for (const sheetName in sheets) {\n      const sheetId = this.dependencyGraph.getSheetId(sheetName);\n      const sheet = sheets[sheetName];\n      for (let i = 0; i < sheet.length; ++i) {\n        const row = sheet[i];\n        for (let j = 0; j < row.length; ++j) {\n          const cellContent = row[j];\n          const address = simpleCellAddress(sheetId, j, i);\n          const parsedCellContent = this.cellContentParser.parse(cellContent);\n          if (parsedCellContent instanceof CellContent.Formula) {\n            const parseResult = this.stats.measure(StatType.PARSER, () => this.parser.parse(parsedCellContent.formula, address));\n            if (parseResult.errors.length > 0) {\n              this.shrinkArrayIfNeeded(address);\n              const vertex = new ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);\n              this.dependencyGraph.addVertex(address, vertex);\n            } else {\n              this.shrinkArrayIfNeeded(address);\n              const size = this.arraySizePredictor.checkArraySize(parseResult.ast, address);\n              if (size.isScalar()) {\n                const vertex = new FormulaCellVertex(parseResult.ast, address, 0);\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addVertex(address, vertex);\n                if (parseResult.hasVolatileFunction) {\n                  this.dependencyGraph.markAsVolatile(vertex);\n                }\n                if (parseResult.hasStructuralChangeFunction) {\n                  this.dependencyGraph.markAsDependentOnStructureChange(vertex);\n                }\n              } else {\n                const vertex = new ArrayVertex(parseResult.ast, address, new ArraySize(size.width, size.height));\n                dependencies.set(vertex, absolutizeDependencies(parseResult.dependencies, address));\n                this.dependencyGraph.addArrayVertex(address, vertex);\n              }\n            }\n          } else if (parsedCellContent instanceof CellContent.Empty) {\n            /* we don't care about empty cells here */\n          } else {\n            this.shrinkArrayIfNeeded(address);\n            const vertex = new ValueCellVertex(parsedCellContent.value, cellContent);\n            this.columnIndex.add(getRawValue(parsedCellContent.value), address);\n            this.dependencyGraph.addVertex(address, vertex);\n          }\n        }\n      }\n    }\n    return dependencies;\n  }\n  shrinkArrayIfNeeded(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.dependencyGraph.shrinkArrayToCorner(vertex);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}