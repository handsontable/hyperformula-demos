{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from './ArraySize';\nimport { CellError, ErrorType, simpleCellAddress } from './Cell';\nimport { ErrorMessage } from './error-message';\nimport { isExtendedNumber } from './interpreter/InterpreterValue';\n/**\r\n * A class that represents a range of data.\r\n */\nexport class SimpleRangeValue {\n  /**\r\n   * In most cases, it's more convenient to create a `SimpleRangeValue` object\r\n   * by calling one of the [static factory methods](#fromrange).\r\n   */\n  constructor(_data,\n  /**\r\n   * A property that represents the address of the range.\r\n   */\n  range, dependencyGraph, _hasOnlyNumbers) {\n    this._data = _data;\n    this.range = range;\n    this.dependencyGraph = dependencyGraph;\n    this._hasOnlyNumbers = _hasOnlyNumbers;\n    this.size = _data === undefined ? new ArraySize(range.effectiveWidth(dependencyGraph), range.effectiveHeight(dependencyGraph)) : new ArraySize(_data[0].length, _data.length);\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   */\n  get data() {\n    this.ensureThatComputed();\n    return this._data;\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address and the provided data.\r\n   */\n  static fromRange(data, range, dependencyGraph) {\n    return new SimpleRangeValue(data, range, dependencyGraph, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided numeric data.\r\n   */\n  static onlyNumbers(data) {\n    return new SimpleRangeValue(data, undefined, undefined, true);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided data.\r\n   */\n  static onlyValues(data) {\n    return new SimpleRangeValue(data, undefined, undefined, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object with the provided range address.\r\n   */\n  static onlyRange(range, dependencyGraph) {\n    return new SimpleRangeValue(undefined, range, dependencyGraph, undefined);\n  }\n  /**\r\n   * A factory method. Returns a `SimpleRangeValue` object that contains a single value.\r\n   */\n  static fromScalar(scalar) {\n    return new SimpleRangeValue([[scalar]], undefined, undefined, undefined);\n  }\n  /**\r\n   * Returns `true` if and only if the `SimpleRangeValue` has no address set.\r\n   */\n  isAdHoc() {\n    return this.range === undefined;\n  }\n  /**\r\n   * Returns the number of columns contained in the range.\r\n   */\n  width() {\n    return this.size.width;\n  }\n  /**\r\n   * Returns the number of rows contained in the range.\r\n   */\n  height() {\n    return this.size.height;\n  }\n  /**\r\n   * Returns the range data as a 1D array.\r\n   */\n  valuesFromTopLeftCorner() {\n    this.ensureThatComputed();\n    const ret = [];\n    for (let i = 0; i < this._data.length; i++) {\n      for (let j = 0; j < this._data[0].length; j++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        ret.push(this._data[i][j]);\n      }\n    }\n    return ret;\n  }\n  /**\r\n   * Generates the addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *effectiveAddressesFromData(leftCorner) {\n    for (let row = 0; row < this.data.length; ++row) {\n      const rowData = this.data[row];\n      for (let col = 0; col < rowData.length; ++col) {\n        yield simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row);\n      }\n    }\n  }\n  /**\r\n   * Generates values and addresses of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   *\r\n   * This method combines the functionalities of [`iterateValuesFromTopLeftCorner()`](#iteratevaluesfromtopleftcorner) and [`effectiveAddressesFromData()`](#effectiveaddressesfromdata).\r\n   */\n  *entriesFromTopLeftCorner(leftCorner) {\n    this.ensureThatComputed();\n    for (let row = 0; row < this.size.height; ++row) {\n      for (let col = 0; col < this.size.width; ++col) {\n        yield [this._data[row][col], simpleCellAddress(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row)];\n      }\n    }\n  }\n  /**\r\n   * Generates the values of the cells contained in the range assuming the provided address is the left corner of the range.\r\n   */\n  *iterateValuesFromTopLeftCorner() {\n    yield* this.valuesFromTopLeftCorner();\n  }\n  /**\r\n   * Returns the number of cells contained in the range.\r\n   */\n  numberOfElements() {\n    return this.size.width * this.size.height;\n  }\n  /**\r\n   * Returns `true` if and only if the range contains only numeric values.\r\n   */\n  hasOnlyNumbers() {\n    if (this._hasOnlyNumbers === undefined) {\n      this._hasOnlyNumbers = true;\n      for (const row of this.data) {\n        for (const v of row) {\n          if (typeof v !== 'number') {\n            this._hasOnlyNumbers = false;\n            return false;\n          }\n        }\n      }\n    }\n    return this._hasOnlyNumbers;\n  }\n  /**\r\n   * Returns the range data as a 2D array of numbers.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawNumbers() {\n    return this._data;\n  }\n  /**\r\n   * Returns the range data as a 2D array.\r\n   *\r\n   * Internal use only.\r\n   */\n  rawData() {\n    var _a;\n    this.ensureThatComputed();\n    return (_a = this._data) !== null && _a !== void 0 ? _a : [];\n  }\n  /**\r\n   * Returns `true` if and only if the range has the same width and height as the `other` range object.\r\n   */\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  /**\r\n   * Computes the range data if it is not computed yet.\r\n   */\n  ensureThatComputed() {\n    if (this._data !== undefined) {\n      return;\n    }\n    this._hasOnlyNumbers = true;\n    this._data = this.range.addressesArrayMap(this.dependencyGraph, cellFromRange => {\n      const value = this.dependencyGraph.getCellValue(cellFromRange);\n      if (value instanceof SimpleRangeValue) {\n        this._hasOnlyNumbers = false;\n        return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n      } else if (isExtendedNumber(value)) {\n        return value;\n      } else {\n        this._hasOnlyNumbers = false;\n        return value;\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}