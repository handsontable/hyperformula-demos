{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { DateNumber, DateTimeNumber, TimeNumber } from './interpreter/InterpreterValue';\nconst numDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst prefSumDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\nconst SECONDS_PER_MINUTE = 60;\nconst MINUTES_PER_HOUR = 60;\nconst HOURS_PER_DAY = 24;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function instanceOfSimpleDate(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'year' in obj && typeof obj.year === 'number' && 'month' in obj && typeof obj.month === 'number' && 'day' in obj && typeof obj.day === 'number';\n  } else {\n    return false;\n  }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function instanceOfSimpleTime(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'hours' in obj && typeof obj.hours === 'number' && 'minutes' in obj && typeof obj.minutes === 'number' && 'seconds' in obj && typeof obj.seconds === 'number';\n  } else {\n    return false;\n  }\n}\nexport const maxDate = {\n  year: 9999,\n  month: 12,\n  day: 31\n};\nexport class DateTimeHelper {\n  constructor(config) {\n    this.config = config;\n    this.minDateAbsoluteValue = this.dateToNumberFromZero(config.nullDate);\n    this.maxDateValue = this.dateToNumber(maxDate);\n    this.leapYear1900 = config.leapYear1900;\n    // code below fixes epochYearStart while being leapYear1900 sensitive\n    // if nullDate is earlier than fateful 28 Feb 1900 and 1900 is not supposed to be leap year, then we should\n    // add two days (this is the config default)\n    // otherwise only one day\n    if (!this.leapYear1900 && 0 <= this.dateToNumber({\n      year: 1900,\n      month: 2,\n      day: 28\n    })) {\n      this.epochYearZero = this.numberToSimpleDate(2).year;\n    } else {\n      this.epochYearZero = this.numberToSimpleDate(1).year;\n    }\n    this.parseDateTime = config.parseDateTime;\n  }\n  getWithinBounds(dayNumber) {\n    return dayNumber <= this.maxDateValue && dayNumber >= 0 ? dayNumber : undefined;\n  }\n  dateStringToDateNumber(dateTimeString) {\n    const {\n      dateTime,\n      dateFormat = '',\n      timeFormat = ''\n    } = this.parseDateTimeFromConfigFormats(dateTimeString);\n    if (dateTime === undefined) {\n      return undefined;\n    }\n    if (instanceOfSimpleTime(dateTime)) {\n      if (instanceOfSimpleDate(dateTime)) {\n        return new DateTimeNumber(timeToNumber(dateTime) + this.dateToNumber(dateTime), dateFormat + ' ' + timeFormat);\n      } else {\n        return new TimeNumber(timeToNumber(dateTime), timeFormat);\n      }\n    } else {\n      if (instanceOfSimpleDate(dateTime)) {\n        return new DateNumber(this.dateToNumber(dateTime), dateFormat);\n      } else {\n        return 0;\n      }\n    }\n  }\n  parseDateTimeFromConfigFormats(dateTimeString) {\n    return this.parseDateTimeFromFormats(dateTimeString, this.config.dateFormats, this.config.timeFormats);\n  }\n  getNullYear() {\n    return this.config.nullYear;\n  }\n  getEpochYearZero() {\n    return this.epochYearZero;\n  }\n  isValidDate(date) {\n    if (isNaN(date.year) || isNaN(date.month) || isNaN(date.day)) {\n      return false;\n    } else if (date.day !== Math.round(date.day) || date.month !== Math.round(date.month) || date.year !== Math.round(date.year)) {\n      return false;\n    } else if (date.year < 1582) {\n      // Gregorian calendar start\n      return false;\n    } else if (date.month < 1 || date.month > 12) {\n      return false;\n    } else if (date.day < 1) {\n      return false;\n    } else if (this.isLeapYear(date.year) && date.month === 2) {\n      return date.day <= 29;\n    } else {\n      return date.day <= numDays[date.month - 1];\n    }\n  }\n  dateToNumber(date) {\n    return this.dateToNumberFromZero(date) - this.minDateAbsoluteValue;\n  }\n  relativeNumberToAbsoluteNumber(arg) {\n    return arg + this.minDateAbsoluteValue - (this.leapYear1900 ? 1 : 0);\n  }\n  numberToSimpleDate(arg) {\n    const dateNumber = Math.floor(arg) + this.minDateAbsoluteValue;\n    let year = Math.floor(dateNumber / 365.2425);\n    if (this.dateToNumberFromZero({\n      year: year + 1,\n      month: 1,\n      day: 1\n    }) <= dateNumber) {\n      year++;\n    } else if (this.dateToNumberFromZero({\n      year: year - 1,\n      month: 1,\n      day: 1\n    }) > dateNumber) {\n      year--;\n    }\n    const dayOfYear = dateNumber - this.dateToNumberFromZero({\n      year,\n      month: 1,\n      day: 1\n    });\n    const month = dayToMonth(dayOfYear - (this.isLeapYear(year) && dayOfYear >= 59 ? 1 : 0));\n    const day = dayOfYear - prefSumDays[month] - (this.isLeapYear(year) && month > 1 ? 1 : 0);\n    return {\n      year,\n      month: month + 1,\n      day: day + 1\n    };\n  }\n  numberToSimpleDateTime(arg) {\n    const time = numberToSimpleTime(arg % 1);\n    const carryDays = Math.floor(time.hours / HOURS_PER_DAY);\n    time.hours = time.hours % HOURS_PER_DAY;\n    const date = this.numberToSimpleDate(Math.floor(arg) + carryDays);\n    return Object.assign(Object.assign({}, date), time);\n  }\n  leapYearsCount(year) {\n    return Math.floor(year / 4) - Math.floor(year / 100) + Math.floor(year / 400) + (this.config.leapYear1900 && year >= 1900 ? 1 : 0);\n  }\n  daysInMonth(year, month) {\n    if (this.isLeapYear(year) && month === 2) {\n      return 29;\n    } else {\n      return numDays[month - 1];\n    }\n  }\n  endOfMonth(date) {\n    return {\n      year: date.year,\n      month: date.month,\n      day: this.daysInMonth(date.year, date.month)\n    };\n  }\n  toBasisUS(start, end) {\n    if (start.day === 31) {\n      start.day = 30;\n    }\n    if (start.day === 30 && end.day === 31) {\n      end.day = 30;\n    }\n    if (start.month === 2 && start.day === this.daysInMonth(start.year, start.month)) {\n      start.day = 30;\n      if (end.month === 2 && end.day === this.daysInMonth(end.year, end.month)) {\n        end.day = 30;\n      }\n    }\n    return [start, end];\n  }\n  yearLengthForBasis(start, end) {\n    if (start.year !== end.year) {\n      if (start.year + 1 !== end.year || start.month < end.month || start.month === end.month && start.day < end.day) {\n        // this is true IFF at least one year of gap between dates\n        return (this.leapYearsCount(end.year) - this.leapYearsCount(start.year - 1)) / (end.year - start.year + 1) + 365;\n      }\n      if (this.countLeapDays(end) !== this.countLeapDays({\n        year: start.year,\n        month: start.month,\n        day: start.day - 1\n      })) {\n        return 366;\n      } else {\n        return 365;\n      }\n    }\n    if (this.isLeapYear(start.year)) {\n      return 366;\n    } else {\n      return 365;\n    }\n  }\n  parseSingleFormat(dateString, dateFormat, timeFormat) {\n    const dateTime = this.parseDateTime(dateString, dateFormat, timeFormat);\n    if (instanceOfSimpleDate(dateTime)) {\n      if (dateTime.year >= 0 && dateTime.year < 100) {\n        if (dateTime.year < this.getNullYear()) {\n          dateTime.year += 2000;\n        } else {\n          dateTime.year += 1900;\n        }\n      }\n      if (!this.isValidDate(dateTime)) {\n        return undefined;\n      }\n    }\n    return dateTime;\n  }\n  parseDateTimeFromFormats(dateTimeString, dateFormats, timeFormats) {\n    const dateFormatsIterate = dateFormats.length === 0 ? [undefined] : dateFormats;\n    const timeFormatsIterate = timeFormats.length === 0 ? [undefined] : timeFormats;\n    for (const dateFormat of dateFormatsIterate) {\n      for (const timeFormat of timeFormatsIterate) {\n        const dateTime = this.parseSingleFormat(dateTimeString, dateFormat, timeFormat);\n        if (dateTime !== undefined) {\n          return {\n            dateTime,\n            timeFormat,\n            dateFormat\n          };\n        }\n      }\n    }\n    return {};\n  }\n  countLeapDays(date) {\n    if (date.month > 2 || date.month === 2 && date.day >= 29) {\n      return this.leapYearsCount(date.year);\n    } else {\n      return this.leapYearsCount(date.year - 1);\n    }\n  }\n  dateToNumberFromZero(date) {\n    return 365 * date.year + prefSumDays[date.month - 1] + date.day - 1 + (date.month <= 2 ? this.leapYearsCount(date.year - 1) : this.leapYearsCount(date.year));\n  }\n  isLeapYear(year) {\n    if (year % 4) {\n      return false;\n    } else if (year % 100) {\n      return true;\n    } else if (year % 400) {\n      return year === 1900 && this.config.leapYear1900;\n    } else {\n      return true;\n    }\n  }\n}\nfunction dayToMonth(dayOfYear) {\n  let month = 0;\n  if (prefSumDays[month + 6] <= dayOfYear) {\n    month += 6;\n  }\n  if (prefSumDays[month + 3] <= dayOfYear) {\n    month += 3;\n  }\n  if (prefSumDays[month + 2] <= dayOfYear) {\n    month += 2;\n  } else if (prefSumDays[month + 1] <= dayOfYear) {\n    month += 1;\n  }\n  return month;\n}\nexport function offsetMonth(date, offset) {\n  const totalM = 12 * date.year + date.month - 1 + offset;\n  return {\n    year: Math.floor(totalM / 12),\n    month: totalM % 12 + 1,\n    day: date.day\n  };\n}\nexport function truncateDayInMonth(date) {\n  return {\n    year: date.year,\n    month: date.month,\n    day: Math.min(date.day, numDays[date.month - 1])\n  };\n}\nexport function roundToNearestSecond(arg) {\n  return Math.round(arg * 3600 * 24) / (3600 * 24);\n}\nfunction roundToEpsilon(arg, epsilon = 1) {\n  return Math.round(arg * epsilon) / epsilon;\n}\n// Note: The result of this function might be { hours = 24, minutes = 0, seconds = 0 } if arg < 1 but arg â‰ˆ 1\nexport function numberToSimpleTime(arg) {\n  const argAsSeconds = arg * HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE;\n  const seconds = roundToEpsilon(argAsSeconds % SECONDS_PER_MINUTE, 100000) % SECONDS_PER_MINUTE;\n  const argAsMinutes = (argAsSeconds - seconds) / SECONDS_PER_MINUTE;\n  const minutes = Math.round(argAsMinutes % MINUTES_PER_HOUR) % MINUTES_PER_HOUR;\n  const argAsHours = (argAsMinutes - minutes) / MINUTES_PER_HOUR;\n  const hours = Math.round(argAsHours);\n  return {\n    hours,\n    minutes,\n    seconds\n  };\n}\nexport function timeToNumber(time) {\n  return ((time.seconds / 60 + time.minutes) / 60 + time.hours) / 24;\n}\nexport function toBasisEU(date) {\n  return {\n    year: date.year,\n    month: date.month,\n    day: Math.min(30, date.day)\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}