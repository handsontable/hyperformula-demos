{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, simpleCellAddress } from '../Cell';\nimport { EmptyValue, getRawValue } from './InterpreterValue';\nconst NOT_FOUND = -1;\n/*\r\n * Searches for the searchKey in a sorted 1-D range.\r\n *\r\n * Options:\r\n * - searchCoordinate - must be set to either 'row' or 'col' to indicate the dimension of the search,\r\n * - orderingDirection - must be set to either 'asc' or 'desc' to indicate the ordering direction for the search range,\r\n * - matchExactly - when set to false, searches for the lower/upper bound.\r\n *\r\n * Semantics:\r\n * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value (unless marchExactly === true).\r\n * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value (unless marchExactly === true).\r\n * - If the search range contains duplicates, returns the last matching value.\r\n * - If no value in the range satisfies the above, returns -1.\r\n *\r\n * Note: this function does not normalize input strings.\r\n */\nexport function findLastOccurrenceInOrderedRange(searchKey, range, {\n  searchCoordinate,\n  orderingDirection,\n  matchExactly\n}, dependencyGraph) {\n  const start = range.start[searchCoordinate];\n  const end = searchCoordinate === 'col' ? range.effectiveEndColumn(dependencyGraph) : range.effectiveEndRow(dependencyGraph);\n  const getValueFromIndexFn = searchCoordinate === 'col' ? index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, index, range.start.row))) : index => getRawValue(dependencyGraph.getCellValue(simpleCellAddress(range.sheet, range.start.col, index)));\n  const compareFn = orderingDirection === 'asc' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);\n  const foundIndex = findLastMatchingIndex(index => compareFn(searchKey, getValueFromIndexFn(index)) >= 0, start, end);\n  const foundValue = getValueFromIndexFn(foundIndex);\n  if (foundIndex === NOT_FOUND || typeof foundValue !== typeof searchKey) {\n    return NOT_FOUND;\n  }\n  if (matchExactly && foundValue !== searchKey) {\n    return NOT_FOUND;\n  }\n  return foundIndex - start;\n}\n/*\r\n * Searches for the searchKey in a sorted array.\r\n * Param orderingDirection must be set to either 'asc' or 'desc' to indicate the ordering direction of the array.\r\n *\r\n * Semantics:\r\n * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value.\r\n * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value.\r\n * - If the array contains duplicates, returns the last matching value.\r\n * - If no value in the range satisfies the above, returns -1.\r\n */\nexport function findLastOccurrenceInOrderedArray(searchKey, array, orderingDirection = 'asc') {\n  const predicate = orderingDirection === 'asc' ? index => compare(searchKey, array[index]) >= 0 : index => -compare(searchKey, array[index]) >= 0;\n  return findLastMatchingIndex(predicate, 0, array.length - 1);\n}\n/*\r\n * Returns:\r\n *   - the last element in the range for which predicate === true or,\r\n *   - value -1 if predicate === false for all elements.\r\n * Assumption: All elements for which predicate === true are before the elements for which predicate === false.\r\n */\nexport function findLastMatchingIndex(predicate, startRange, endRange) {\n  let start = startRange;\n  let end = endRange;\n  while (start < end) {\n    const pivot = Math.ceil((start + end) / 2);\n    if (predicate(pivot)) {\n      start = pivot;\n    } else {\n      end = pivot - 1;\n    }\n  }\n  if (start === end && predicate(start)) {\n    return start;\n  }\n  return NOT_FOUND;\n}\n/*\r\n * numbers < strings < false < true\r\n */\nexport function compare(left, right) {\n  if (typeof left === typeof right) {\n    if (left === EmptyValue) {\n      return 0;\n    }\n    return left < right ? -1 : left > right ? 1 : 0;\n  }\n  if (left === EmptyValue) {\n    return -1;\n  }\n  if (right === EmptyValue) {\n    return 1;\n  }\n  if (right instanceof CellError) {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'string') {\n    return -1;\n  }\n  if (typeof left === 'number' && typeof right === 'boolean') {\n    return -1;\n  }\n  if (typeof left === 'string' && typeof right === 'number') {\n    return 1;\n  }\n  if (typeof left === 'string' && typeof right === 'boolean') {\n    return -1;\n  }\n  return 1;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}