{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nvar NodeVisitStatus = /*#__PURE__*/(() => {\n  NodeVisitStatus = NodeVisitStatus || {};\n  NodeVisitStatus[NodeVisitStatus[\"ON_STACK\"] = 0] = \"ON_STACK\";\n  NodeVisitStatus[NodeVisitStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  NodeVisitStatus[NodeVisitStatus[\"POPPED\"] = 2] = \"POPPED\";\n  return NodeVisitStatus;\n})();\n/**\r\n * Provides graph directed structure\r\n *\r\n * Invariants:\r\n * - this.edges(node) exists if and only if node is in the graph\r\n * - this.specialNodes* are always subset of this.nodes\r\n * - this.edges(node) is subset of this.nodes (i.e. it does not contain nodes not present in graph) -- this invariant DOES NOT HOLD right now\r\n */\nexport class Graph {\n  constructor(dependencyQuery) {\n    this.dependencyQuery = dependencyQuery;\n    /** Set with nodes in graph. */\n    this.nodes = new Set();\n    this.specialNodes = new Set();\n    this.specialNodesStructuralChanges = new Set();\n    this.specialNodesRecentlyChanged = new Set();\n    this.infiniteRanges = new Set();\n    /** Nodes adjacency mapping. */\n    this.edges = new Map();\n  }\n  /**\r\n   * Adds node to a graph\r\n   *\r\n   * @param node - a node to be added\r\n   */\n  addNode(node) {\n    this.nodes.add(node);\n    if (!this.edges.has(node)) {\n      this.edges.set(node, new Set());\n    }\n  }\n  /**\r\n   * Adds edge between nodes.\r\n   *\r\n   * The nodes had to be added to the graph before, or the error will be raised\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  addEdge(fromNode, toNode) {\n    if (!this.nodes.has(fromNode)) {\n      throw new Error(`Unknown node ${fromNode}`);\n    }\n    if (!this.nodes.has(toNode)) {\n      throw new Error(`Unknown node ${toNode}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.edges.get(fromNode).add(toNode);\n  }\n  removeEdge(fromNode, toNode) {\n    if (this.existsEdge(fromNode, toNode)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.edges.get(fromNode).delete(toNode);\n    } else {\n      throw new Error('Edge does not exist');\n    }\n  }\n  softRemoveEdge(fromNode, toNode) {\n    var _a;\n    (_a = this.edges.get(fromNode)) === null || _a === void 0 ? void 0 : _a.delete(toNode);\n  }\n  removeIncomingEdges(toNode) {\n    this.edges.forEach(nodeEdges => {\n      nodeEdges.delete(toNode);\n    });\n  }\n  /**\r\n   * Returns nodes adjacent to given node\r\n   *\r\n   * @param node - node to which adjacent nodes we want to retrieve\r\n   */\n  adjacentNodes(node) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.edges.get(node);\n  }\n  adjacentNodesCount(node) {\n    return this.adjacentNodes(node).size;\n  }\n  /**\r\n   * Checks whether a node is present in graph\r\n   *\r\n   * @param node - node to check\r\n   */\n  hasNode(node) {\n    return this.nodes.has(node);\n  }\n  /**\r\n   * Returns number of nodes in graph\r\n   */\n  nodesCount() {\n    return this.nodes.size;\n  }\n  /**\r\n   * Returns number of edges in graph\r\n   */\n  edgesCount() {\n    let result = 0;\n    this.edges.forEach(edgesForNode => result += edgesForNode.size);\n    return result;\n  }\n  removeNode(node) {\n    for (const adjacentNode of this.adjacentNodes(node).values()) {\n      this.markNodeAsSpecialRecentlyChanged(adjacentNode);\n    }\n    this.edges.delete(node);\n    this.nodes.delete(node);\n    this.specialNodes.delete(node);\n    this.specialNodesRecentlyChanged.delete(node);\n    this.specialNodesStructuralChanges.delete(node);\n    this.infiniteRanges.delete(node);\n    return this.removeDependencies(node);\n  }\n  markNodeAsSpecial(node) {\n    this.specialNodes.add(node);\n  }\n  markNodeAsSpecialRecentlyChanged(node) {\n    if (this.nodes.has(node)) {\n      this.specialNodesRecentlyChanged.add(node);\n    }\n  }\n  markNodeAsChangingWithStructure(node) {\n    this.specialNodesStructuralChanges.add(node);\n  }\n  clearSpecialNodesRecentlyChanged() {\n    this.specialNodesRecentlyChanged.clear();\n  }\n  markNodeAsInfiniteRange(node) {\n    this.infiniteRanges.add(node);\n  }\n  /**\r\n   * Checks whether exists edge between nodes\r\n   *\r\n   * @param fromNode - node from which edge is outcoming\r\n   * @param toNode - node to which edge is incoming\r\n   */\n  existsEdge(fromNode, toNode) {\n    var _a, _b;\n    return (_b = (_a = this.edges.get(fromNode)) === null || _a === void 0 ? void 0 : _a.has(toNode)) !== null && _b !== void 0 ? _b : false;\n  }\n  /*\r\n   * return a topological sort order, but separates vertices that exist in some cycle\r\n   */\n  topSortWithScc() {\n    return this.getTopSortedWithSccSubgraphFrom(Array.from(this.nodes), () => true, () => {});\n  }\n  /**\r\n   *\r\n   * an iterative implementation of Tarjan's algorithm for finding strongly connected compontents\r\n   * returns vertices in order of topological sort, but vertices that are on cycles are kept separate\r\n   *\r\n   * @param modifiedNodes - seed for computation. During engine init run, all of the vertices of grap. In recomputation run, changed vertices.\r\n   * @param operatingFunction - recomputes value of a node, and returns whether a change occured\r\n   * @param onCycle - action to be performed when node is on cycle\r\n   */\n  getTopSortedWithSccSubgraphFrom(modifiedNodes, operatingFunction, onCycle) {\n    const entranceTime = new Map();\n    const low = new Map();\n    const parent = new Map();\n    const inSCC = new Set();\n    // node status life cycle:\n    // undefined -> ON_STACK -> PROCESSED -> POPPED\n    const nodeStatus = new Map();\n    const order = [];\n    let time = 0;\n    const sccNonSingletons = new Set();\n    modifiedNodes.reverse();\n    modifiedNodes.forEach(v => {\n      if (nodeStatus.get(v) !== undefined) {\n        return;\n      }\n      const DFSstack = [v];\n      const SCCstack = [];\n      nodeStatus.set(v, NodeVisitStatus.ON_STACK);\n      while (DFSstack.length > 0) {\n        const u = DFSstack[DFSstack.length - 1];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        switch (nodeStatus.get(u)) {\n          case NodeVisitStatus.ON_STACK:\n            {\n              entranceTime.set(u, time);\n              low.set(u, time);\n              SCCstack.push(u);\n              time++;\n              this.adjacentNodes(u).forEach(t => {\n                if (entranceTime.get(t) === undefined) {\n                  DFSstack.push(t);\n                  parent.set(t, u);\n                  nodeStatus.set(t, NodeVisitStatus.ON_STACK);\n                }\n              });\n              nodeStatus.set(u, NodeVisitStatus.PROCESSED);\n              break;\n            }\n          case NodeVisitStatus.PROCESSED:\n            {\n              // leaving this DFS subtree\n              let uLow;\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              uLow = entranceTime.get(u);\n              this.adjacentNodes(u).forEach(t => {\n                if (!inSCC.has(t)) {\n                  if (parent.get(t) === u) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    uLow = Math.min(uLow, low.get(t));\n                  } else {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    uLow = Math.min(uLow, entranceTime.get(t));\n                  }\n                }\n              });\n              low.set(u, uLow);\n              if (uLow === entranceTime.get(u)) {\n                const currentSCC = [];\n                do {\n                  currentSCC.push(SCCstack[SCCstack.length - 1]);\n                  SCCstack.pop();\n                } while (currentSCC[currentSCC.length - 1] !== u);\n                currentSCC.forEach(t => {\n                  inSCC.add(t);\n                });\n                order.push(...currentSCC);\n                if (currentSCC.length > 1) {\n                  currentSCC.forEach(t => {\n                    sccNonSingletons.add(t);\n                  });\n                }\n              }\n              DFSstack.pop();\n              nodeStatus.set(u, NodeVisitStatus.POPPED);\n              break;\n            }\n          case NodeVisitStatus.POPPED:\n            {\n              // it's a 'shadow' copy, we already processed this vertex and can ignore it\n              DFSstack.pop();\n              break;\n            }\n        }\n      }\n    });\n    const shouldBeUpdatedMapping = new Set(modifiedNodes);\n    const sorted = [];\n    const cycled = [];\n    order.reverse();\n    order.forEach(t => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (sccNonSingletons.has(t) || this.adjacentNodes(t).has(t)) {\n        cycled.push(t);\n        onCycle(t);\n        this.adjacentNodes(t).forEach(s => shouldBeUpdatedMapping.add(s));\n      } else {\n        sorted.push(t);\n        if (shouldBeUpdatedMapping.has(t) && operatingFunction(t)) {\n          this.adjacentNodes(t).forEach(s => shouldBeUpdatedMapping.add(s));\n        }\n      }\n    });\n    return {\n      sorted,\n      cycled\n    };\n  }\n  getDependencies(vertex) {\n    const result = [];\n    this.edges.forEach((adjacentNodes, sourceNode) => {\n      if (adjacentNodes.has(vertex)) {\n        result.push(sourceNode);\n      }\n    });\n    return result;\n  }\n  removeDependencies(node) {\n    const dependencies = this.dependencyQuery(node);\n    for (const [_, dependency] of dependencies) {\n      this.softRemoveEdge(dependency, node);\n    }\n    return dependencies;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}