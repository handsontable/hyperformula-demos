{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, AbsoluteColumnRange, AbsoluteRowRange } from '../AbsoluteCellRange';\nimport { ArrayValue, NotComputedArray } from '../ArrayValue';\nimport { CellError, ErrorType, invalidSimpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\n// noinspection TypeScriptPreferShortImport\nimport { AstNodeType } from '../parser/Ast';\nimport { coerceRangeToScalar, coerceScalarToString, coerceToRange, fixNegativeZero, isNumberOverflow } from './ArithmeticHelper';\nimport { CriterionBuilder } from './Criterion';\nimport { FunctionRegistry } from './FunctionRegistry';\nimport { InterpreterState } from './InterpreterState';\nimport { cloneNumber, EmptyValue, getRawValue, isExtendedNumber } from './InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nexport class Interpreter {\n  constructor(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {\n    this.config = config;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.stats = stats;\n    this.arithmeticHelper = arithmeticHelper;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.serialization = serialization;\n    this.arraySizePredictor = arraySizePredictor;\n    this.dateTimeHelper = dateTimeHelper;\n    this.equalOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.eq, arg1, arg2);\n    this.notEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.neq, arg1, arg2);\n    this.greaterThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.gt, arg1, arg2);\n    this.lessThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.lt, arg1, arg2);\n    this.greaterThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.geq, arg1, arg2);\n    this.lessThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.leq, arg1, arg2);\n    this.concatOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.concat, coerceScalarToString(arg1), coerceScalarToString(arg2));\n    this.plusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.minusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.timesOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.powerOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.divOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));\n    this.unaryMinusOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.percentOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(arg));\n    this.unaryPlusOp = arg => this.arithmeticHelper.unaryPlus(arg);\n    this.functionRegistry.initializePlugins(this);\n    this.criterionBuilder = new CriterionBuilder(config);\n  }\n  evaluateAst(ast, state) {\n    let val = this.evaluateAstWithoutPostprocessing(ast, state);\n    if (isExtendedNumber(val)) {\n      if (isNumberOverflow(getRawValue(val))) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n      } else {\n        val = cloneNumber(val, fixNegativeZero(getRawValue(val)));\n      }\n    }\n    if (val instanceof SimpleRangeValue && val.height() === 1 && val.width() === 1) {\n      [[val]] = val.data;\n    }\n    return wrapperForRootVertex(val, state.formulaVertex);\n  }\n  /**\r\n   * Calculates cell value from formula abstract syntax tree\r\n   *\r\n   * @param formula - abstract syntax tree of formula\r\n   * @param formulaAddress - address of the cell in which formula is located\r\n   */\n  evaluateAstWithoutPostprocessing(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return EmptyValue;\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          const address = ast.reference.toSimpleCellAddress(state.formulaAddress);\n          if (invalidSimpleCellAddress(address)) {\n            return new CellError(ErrorType.REF, ErrorMessage.BadRef);\n          }\n          return this.dependencyGraph.getCellValue(address);\n        }\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n        {\n          return ast.value;\n        }\n      case AstNodeType.CONCATENATE_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.EQUALS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.equalOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.NOT_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.notEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.greaterThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.lessThanOrEqualOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.plusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.MINUS_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.minusOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.TIMES_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.timesOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.POWER_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.powerOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.DIV_OP:\n        {\n          const leftResult = this.evaluateAst(ast.left, state);\n          const rightResult = this.evaluateAst(ast.right, state);\n          return this.binaryRangeWrapper(this.divOp, leftResult, rightResult, state);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryPlusOp, result, state);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.unaryMinusOp, result, state);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          const result = this.evaluateAst(ast.value, state);\n          return this.unaryRangeWrapper(this.percentOp, result, state);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          if (this.config.licenseKeyValidityState !== \"valid\" /* VALID */ && !FunctionRegistry.functionIsProtected(ast.procedureName)) {\n            return new CellError(ErrorType.LIC, ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));\n          }\n          const pluginFunction = this.functionRegistry.getFunction(ast.procedureName);\n          if (pluginFunction !== undefined) {\n            return pluginFunction(ast, new InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.FunctionName(ast.procedureName));\n          }\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);\n          if (namedExpression) {\n            return this.dependencyGraph.getCellValue(namedExpression.address);\n          } else {\n            return new CellError(ErrorType.NAME, ErrorMessage.NamedExpressionName(ast.expressionName));\n          }\n        }\n      case AstNodeType.CELL_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);\n          const arrayVertex = this.dependencyGraph.getArray(range);\n          if (arrayVertex) {\n            const array = arrayVertex.array;\n            if (array instanceof NotComputedArray) {\n              throw new Error('Array should be already computed');\n            } else if (array instanceof CellError) {\n              return array;\n            } else if (array instanceof ArrayValue) {\n              return SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);\n            } else {\n              throw new Error('Unknown array');\n            }\n          } else {\n            return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n          }\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          if (!this.rangeSpansOneSheet(ast)) {\n            return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n          }\n          const range = AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);\n          return SimpleRangeValue.onlyRange(range, this.dependencyGraph);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.evaluateAst(ast.expression, state);\n        }\n      case AstNodeType.ARRAY:\n        {\n          let totalWidth = undefined;\n          const ret = [];\n          for (const astRow of ast.args) {\n            let rowHeight = undefined;\n            const rowRet = [];\n            for (const astIt of astRow) {\n              const arr = coerceToRange(this.evaluateAst(astIt, state));\n              const height = arr.height();\n              if (rowHeight === undefined) {\n                rowHeight = height;\n                rowRet.push(...arr.data);\n              } else if (rowHeight === height) {\n                for (let i = 0; i < height; i++) {\n                  rowRet[i].push(...arr.data[i]);\n                }\n              } else {\n                return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n              }\n            }\n            const width = rowRet[0].length;\n            if (totalWidth === undefined) {\n              totalWidth = width;\n              ret.push(...rowRet);\n            } else if (totalWidth === width) {\n              ret.push(...rowRet);\n            } else {\n              return new CellError(ErrorType.REF, ErrorMessage.SizeMismatch);\n            }\n          }\n          return SimpleRangeValue.onlyValues(ret);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.ERROR:\n        {\n          return ast.error;\n        }\n    }\n  }\n  rangeSpansOneSheet(ast) {\n    return ast.start.sheet === ast.end.sheet;\n  }\n  unaryRangeWrapper(op, arg, state) {\n    var _a;\n    if (arg instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg = (_a = coerceRangeToScalar(arg, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    if (arg instanceof SimpleRangeValue) {\n      const newRaw = arg.data.map(row => row.map(op));\n      return SimpleRangeValue.onlyValues(newRaw);\n    }\n    return op(arg);\n  }\n  binaryRangeWrapper(op, arg1, arg2, state) {\n    var _a, _b;\n    if (arg1 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg1 = (_a = coerceRangeToScalar(arg1, state)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg1 instanceof CellError) {\n      return arg1;\n    }\n    if (arg2 instanceof SimpleRangeValue && !state.arraysFlag) {\n      arg2 = (_b = coerceRangeToScalar(arg2, state)) !== null && _b !== void 0 ? _b : new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    if (arg2 instanceof CellError) {\n      return arg2;\n    }\n    if (arg1 instanceof SimpleRangeValue || arg2 instanceof SimpleRangeValue) {\n      if (!(arg1 instanceof SimpleRangeValue)) {\n        if (arg2.isAdHoc()) {\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw2.length; i++) {\n            for (let j = 0; j < raw2[0].length; j++) {\n              raw2[i][j] = op(arg1, raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        } else {\n          arg1 = SimpleRangeValue.fromScalar(arg1);\n        }\n      }\n      if (!(arg2 instanceof SimpleRangeValue)) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], arg2);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        } else {\n          arg2 = SimpleRangeValue.fromScalar(arg2);\n        }\n      }\n      if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {\n        if (arg1.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw1[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw1);\n        }\n        if (arg2.isAdHoc()) {\n          const raw1 = arg1.data;\n          const raw2 = arg2.data;\n          for (let i = 0; i < raw1.length; i++) {\n            for (let j = 0; j < raw1[0].length; j++) {\n              raw2[i][j] = op(raw1[i][j], raw2[i][j]);\n            }\n          }\n          return SimpleRangeValue.onlyValues(raw2);\n        }\n      }\n      const width = Math.max(arg1.width(), arg2.width());\n      const height = Math.max(arg1.height(), arg2.height());\n      const ret = Array(height);\n      for (let i = 0; i < height; i++) {\n        ret[i] = Array(width);\n      }\n      for (let i = 0; i < height; i++) {\n        const i1 = arg1.height() !== 1 ? i : 0;\n        const i2 = arg2.height() !== 1 ? i : 0;\n        for (let j = 0; j < width; j++) {\n          const j1 = arg1.width() !== 1 ? j : 0;\n          const j2 = arg2.width() !== 1 ? j : 0;\n          if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {\n            ret[i][j] = op(arg1.data[i1][j1], arg2.data[i2][j2]);\n          } else {\n            ret[i][j] = new CellError(ErrorType.NA);\n          }\n        }\n      }\n      return SimpleRangeValue.onlyValues(ret);\n    }\n    return op(arg1, arg2);\n  }\n}\nfunction unaryErrorWrapper(op, arg) {\n  if (arg instanceof CellError) {\n    return arg;\n  } else {\n    return op(arg);\n  }\n}\nfunction binaryErrorWrapper(op, arg1, arg2) {\n  if (arg1 instanceof CellError) {\n    return arg1;\n  } else if (arg2 instanceof CellError) {\n    return arg2;\n  } else {\n    return op(arg1, arg2);\n  }\n}\nfunction wrapperForRootVertex(val, vertex) {\n  if (val instanceof CellError && vertex !== undefined) {\n    return val.attachRootVertex(vertex);\n  }\n  return val;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}