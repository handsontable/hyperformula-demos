{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies, filterDependenciesOutOfScope } from './absolutizeDependencies';\nimport { ArraySize } from './ArraySize';\nimport { equalSimpleCellAddress, invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { ClipboardCellType } from './ClipboardOperations';\nimport { ContentChanges } from './ContentChanges';\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, ParsingErrorVertex, SparseStrategy, ValueCellVertex } from './DependencyGraph';\nimport { FormulaVertex } from './DependencyGraph/FormulaCellVertex';\nimport { AddColumnsTransformer } from './dependencyTransformers/AddColumnsTransformer';\nimport { AddRowsTransformer } from './dependencyTransformers/AddRowsTransformer';\nimport { CleanOutOfScopeDependenciesTransformer } from './dependencyTransformers/CleanOutOfScopeDependenciesTransformer';\nimport { MoveCellsTransformer } from './dependencyTransformers/MoveCellsTransformer';\nimport { RemoveColumnsTransformer } from './dependencyTransformers/RemoveColumnsTransformer';\nimport { RemoveRowsTransformer } from './dependencyTransformers/RemoveRowsTransformer';\nimport { RemoveSheetTransformer } from './dependencyTransformers/RemoveSheetTransformer';\nimport { InvalidArgumentsError, NamedExpressionDoesNotExistError, NoRelativeAddressesAllowedError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from './errors';\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { doesContainRelativeReferences, NamedExpressions } from './NamedExpressions';\nimport { NamedExpressionDependency } from './parser';\nimport { findBoundaries } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { StatType } from './statistics';\nexport class RemoveRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddRowsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  rowsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class AddColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeAddedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class RemoveColumnsCommand {\n  constructor(sheet, indexes) {\n    this.sheet = sheet;\n    this.indexes = indexes;\n  }\n  normalizedIndexes() {\n    return normalizeRemovedIndexes(this.indexes);\n  }\n  columnsSpans() {\n    return this.normalizedIndexes().map(normalizedIndex => ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));\n  }\n}\nexport class Operations {\n  constructor(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.cellContentParser = cellContentParser;\n    this.parser = parser;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.arraySizePredictor = arraySizePredictor;\n    this.changes = ContentChanges.empty();\n    this.allocateNamedExpressionAddressSpace();\n    this.maxColumns = config.maxColumns;\n    this.maxRows = config.maxRows;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  get addressMapping() {\n    return this.dependencyGraph.addressMapping;\n  }\n  removeRows(cmd) {\n    const rowsRemovals = [];\n    for (const rowsToRemove of cmd.rowsSpans()) {\n      const rowsRemoval = this.doRemoveRows(rowsToRemove);\n      if (rowsRemoval) {\n        rowsRemovals.push(rowsRemoval);\n      }\n    }\n    return rowsRemovals;\n  }\n  addRows(cmd) {\n    for (const addedRows of cmd.rowsSpans()) {\n      this.doAddRows(addedRows);\n    }\n  }\n  addColumns(cmd) {\n    for (const addedColumns of cmd.columnsSpans()) {\n      this.doAddColumns(addedColumns);\n    }\n  }\n  removeColumns(cmd) {\n    const columnsRemovals = [];\n    for (const columnsToRemove of cmd.columnsSpans()) {\n      const columnsRemoval = this.doRemoveColumns(columnsToRemove);\n      if (columnsRemoval) {\n        columnsRemovals.push(columnsRemoval);\n      }\n    }\n    return columnsRemovals;\n  }\n  removeSheet(sheetId) {\n    this.dependencyGraph.removeSheet(sheetId);\n    let version;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveSheetTransformer(sheetId);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.sheetMapping.removeSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n    const scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(namedexpression => this.removeNamedExpression(namedexpression.normalizeExpressionName(), sheetId));\n    return {\n      version: version,\n      scopedNamedExpressions\n    };\n  }\n  removeSheetByName(sheetName) {\n    const sheetId = this.sheetMapping.fetch(sheetName);\n    return this.removeSheet(sheetId);\n  }\n  clearSheet(sheetId) {\n    this.dependencyGraph.clearSheet(sheetId);\n    this.columnSearch.removeSheet(sheetId);\n  }\n  addSheet(name) {\n    const sheetId = this.sheetMapping.addSheet(name);\n    const sheet = [];\n    this.dependencyGraph.addressMapping.autoAddSheet(sheetId, sheet, findBoundaries(sheet));\n    return this.sheetMapping.fetchDisplayName(sheetId);\n  }\n  renameSheet(sheetId, newName) {\n    return this.sheetMapping.renameSheet(sheetId, newName);\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    const rowsToAdd = RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddRows(rowsToAdd);\n    if (targetRow < startRow) {\n      startRow += numberOfRows;\n    }\n    const startAddress = simpleCellAddress(sheet, 0, startRow);\n    const targetAddress = simpleCellAddress(sheet, 0, targetRow);\n    this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);\n    const rowsToRemove = RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);\n    this.doRemoveRows(rowsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    const columnsToAdd = ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);\n    this.lazilyTransformingAstService.beginCombinedMode(sheet);\n    this.doAddColumns(columnsToAdd);\n    if (targetColumn < startColumn) {\n      startColumn += numberOfColumns;\n    }\n    const startAddress = simpleCellAddress(sheet, startColumn, 0);\n    const targetAddress = simpleCellAddress(sheet, targetColumn, 0);\n    this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);\n    const columnsToRemove = ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);\n    this.doRemoveColumns(columnsToRemove);\n    return this.lazilyTransformingAstService.commitCombinedMode();\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    const toRight = destinationLeftCorner.col - sourceLeftCorner.col;\n    const toBottom = destinationLeftCorner.row - sourceLeftCorner.row;\n    const toSheet = destinationLeftCorner.sheet;\n    const currentDataAtTarget = this.getRangeClipboardCells(targetRange);\n    const valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);\n    this.columnSearch.removeValues(valuesToRemove);\n    const valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);\n    this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);\n    let version;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);\n    const addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    return {\n      version: version,\n      overwrittenCellsData: currentDataAtTarget,\n      addedGlobalNamedExpressions: addedGlobalNamedExpressions\n    };\n  }\n  setRowOrder(sheetId, rowMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        const row = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(row);\n        buffer.push(row.map(([{\n          sheet,\n          col\n        }, cell]) => [{\n          sheet,\n          col,\n          row: target\n        }, cell]));\n      }\n    }\n    buffer.forEach(row => this.restoreClipboardCells(sheetId, row.values()));\n    return oldContent;\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    const buffer = [];\n    let oldContent = [];\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        const column = this.getRangeClipboardCells(rowRange);\n        oldContent = oldContent.concat(column);\n        buffer.push(column.map(([{\n          sheet,\n          col: _col,\n          row\n        }, cell]) => [{\n          sheet,\n          col: target,\n          row\n        }, cell]));\n      }\n    }\n    buffer.forEach(column => this.restoreClipboardCells(sheetId, column.values()));\n    return oldContent;\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    const namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);\n    this.storeNamedExpressionInCell(namedExpression.address, expression);\n    this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);\n  }\n  restoreNamedExpression(namedExpression, content, sheetId) {\n    const expressionName = namedExpression.displayName;\n    this.restoreCell(namedExpression.address, content);\n    const restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);\n    this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);\n  }\n  changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    const oldNamedExpression = namedExpression.copy();\n    namedExpression.options = options;\n    const content = this.getClipboardCell(namedExpression.address);\n    this.storeNamedExpressionInCell(namedExpression.address, newExpression);\n    return [oldNamedExpression, content];\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);\n    if (!namedExpression) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.namedExpressions.remove(namedExpression.displayName, sheetId);\n    const content = this.getClipboardCell(namedExpression.address);\n    if (sheetId !== undefined) {\n      const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n      this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);\n    } else {\n      this.dependencyGraph.setCellEmpty(namedExpression.address);\n    }\n    return [namedExpression, content];\n  }\n  ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (invalidSimpleCellAddress(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || invalidSimpleCellAddress(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {\n      throw new InvalidArgumentsError('a valid range of cells to move.');\n    }\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  restoreClipboardCells(sourceSheetId, cells) {\n    const addedNamedExpressions = [];\n    for (const [address, clipboardCell] of cells) {\n      this.restoreCell(address, clipboardCell);\n      if (clipboardCell.type === ClipboardCellType.FORMULA) {\n        const {\n          dependencies\n        } = this.parser.fetchCachedResult(clipboardCell.hash);\n        addedNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies));\n      }\n    }\n    return addedNamedExpressions;\n  }\n  restoreCell(address, clipboardCell) {\n    switch (clipboardCell.type) {\n      case ClipboardCellType.VALUE:\n        {\n          this.setValueToCell(clipboardCell, address);\n          break;\n        }\n      case ClipboardCellType.FORMULA:\n        {\n          this.setFormulaToCellFromCache(clipboardCell.hash, address);\n          break;\n        }\n      case ClipboardCellType.EMPTY:\n        {\n          this.setCellEmpty(address);\n          break;\n        }\n      case ClipboardCellType.PARSING_ERROR:\n        {\n          this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);\n          break;\n        }\n    }\n  }\n  getOldContent(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return [address, {\n        type: ClipboardCellType.EMPTY\n      }];\n    } else if (vertex instanceof ValueCellVertex) {\n      return [address, Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues())];\n    } else if (vertex instanceof FormulaVertex) {\n      return [vertex.getAddress(this.lazilyTransformingAstService), {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      }];\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return [address, {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      }];\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getClipboardCell(address) {\n    const vertex = this.dependencyGraph.getCell(address);\n    if (vertex === undefined || vertex instanceof EmptyCellVertex) {\n      return {\n        type: ClipboardCellType.EMPTY\n      };\n    } else if (vertex instanceof ValueCellVertex) {\n      return Object.assign({\n        type: ClipboardCellType.VALUE\n      }, vertex.getValues());\n    } else if (vertex instanceof ArrayVertex) {\n      const val = vertex.getArrayCellValue(address);\n      if (val === EmptyValue) {\n        return {\n          type: ClipboardCellType.EMPTY\n        };\n      }\n      return {\n        type: ClipboardCellType.VALUE,\n        parsedValue: val,\n        rawValue: vertex.getArrayCellRawValue(address)\n      };\n    } else if (vertex instanceof FormulaCellVertex) {\n      return {\n        type: ClipboardCellType.FORMULA,\n        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))\n      };\n    } else if (vertex instanceof ParsingErrorVertex) {\n      return {\n        type: ClipboardCellType.PARSING_ERROR,\n        rawInput: vertex.rawInput,\n        errors: vertex.errors\n      };\n    }\n    throw Error('Trying to copy unsupported type');\n  }\n  getSheetClipboardCells(sheet) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = this.getClipboardCell(address);\n      }\n    }\n    return arr;\n  }\n  getRangeClipboardCells(range) {\n    const result = [];\n    for (const address of range.addresses(this.dependencyGraph)) {\n      result.push([address, this.getClipboardCell(address)]);\n    }\n    return result;\n  }\n  setCellContent(address, newCellContent) {\n    const parsedCellContent = this.cellContentParser.parse(newCellContent);\n    const oldContent = this.getOldContent(address);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parserResult = this.parser.parse(parsedCellContent.formula, address);\n      const {\n        ast,\n        errors\n      } = parserResult;\n      if (errors.length > 0) {\n        this.setParsingErrorToCell(parsedCellContent.formula, errors, address);\n      } else {\n        const size = this.arraySizePredictor.checkArraySize(ast, address);\n        this.setFormulaToCell(address, size, parserResult);\n      }\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: newCellContent\n      }, address);\n    }\n    return oldContent;\n  }\n  setSheetContent(sheetId, newSheetContent) {\n    this.clearSheet(sheetId);\n    for (let i = 0; i < newSheetContent.length; i++) {\n      for (let j = 0; j < newSheetContent[i].length; j++) {\n        const address = simpleCellAddress(sheetId, j, i);\n        this.setCellContent(address, newSheetContent[i][j]);\n      }\n    }\n  }\n  setParsingErrorToCell(rawInput, errors, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const vertex = new ParsingErrorVertex(errors, rawInput);\n    const arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(vertex.getCellValue(), address);\n  }\n  setFormulaToCell(address, size, {\n    ast,\n    hasVolatileFunction,\n    hasStructuralChangeFunction,\n    dependencies\n  }) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n  }\n  setValueToCell(value, address) {\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setValueToCell(address, value);\n    this.columnSearch.change(getRawValue(oldValue), getRawValue(value.parsedValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges().filter(change => !equalSimpleCellAddress(change.address, address)));\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(value.parsedValue, address);\n  }\n  setCellEmpty(address) {\n    if (this.dependencyGraph.isArrayInternalCell(address)) {\n      return;\n    }\n    const oldValue = this.dependencyGraph.getCellValue(address);\n    const arrayChanges = this.dependencyGraph.setCellEmpty(address);\n    this.columnSearch.remove(getRawValue(oldValue), address);\n    this.columnSearch.applyChanges(arrayChanges.getChanges());\n    this.changes.addAll(arrayChanges);\n    this.changes.addChange(EmptyValue, address);\n  }\n  setFormulaToCellFromCache(formulaHash, address) {\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    } = this.parser.fetchCachedResult(formulaHash);\n    const absoluteDependencies = absolutizeDependencies(dependencies, address);\n    const [cleanedAst] = new CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address);\n    this.parser.rememberNewAst(cleanedAst);\n    const cleanedDependencies = filterDependenciesOutOfScope(absoluteDependencies);\n    const size = this.arraySizePredictor.checkArraySize(ast, address);\n    this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   *\r\n   * @param row - row number\r\n   * @param sheet - sheet id number\r\n   */\n  rowEffectivelyNotInSheet(row, sheet) {\n    const height = this.dependencyGraph.addressMapping.getHeight(sheet);\n    return row >= height;\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  forceApplyPostponedTransformations() {\n    this.dependencyGraph.forceApplyPostponedTransformations();\n  }\n  /**\r\n   * Removes multiple rows from sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   *\r\n   * @param sheet - sheet id from which rows will be removed\r\n   * @param rowStart - number of the first row to be deleted\r\n   * @param rowEnd - number of the last row to be deleted\r\n   */\n  doRemoveRows(rowsToRemove) {\n    if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeRows(rowsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    let version;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveRowsTransformer(rowsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      rowFrom: rowsToRemove.rowStart,\n      rowCount: rowsToRemove.numberOfRows\n    };\n  }\n  /**\r\n   * Removes multiple columns from sheet. </br>\r\n   * Does nothing if columns are outside of effective sheet size.\r\n   *\r\n   * @param sheet - sheet id from which columns will be removed\r\n   * @param columnStart - number of the first column to be deleted\r\n   * @param columnEnd - number of the last row to be deleted\r\n   */\n  doRemoveColumns(columnsToRemove) {\n    if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {\n      return;\n    }\n    const removedCells = [];\n    for (const [address] of this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)) {\n      removedCells.push({\n        address,\n        cellType: this.getClipboardCell(address)\n      });\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.removeColumns(columnsToRemove);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.columnSearch.removeColumns(columnsToRemove);\n    let version;\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new RemoveColumnsTransformer(columnsToRemove);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      version = this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n    return {\n      version: version,\n      removedCells,\n      columnFrom: columnsToRemove.columnStart,\n      columnCount: columnsToRemove.numberOfColumns\n    };\n  }\n  /**\r\n   * Add multiple rows to sheet. </br>\r\n   * Does nothing if rows are outside of effective sheet size.\r\n   *\r\n   * @param sheet - sheet id in which rows will be added\r\n   * @param row - row number above which the rows will be added\r\n   * @param numberOfRowsToAdd - number of rows to add\r\n   */\n  doAddRows(addedRows) {\n    if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays\n    } = this.dependencyGraph.addRows(addedRows);\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddRowsTransformer(addedRows);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  rewriteAffectedArrays(affectedArrays) {\n    for (const arrayVertex of affectedArrays.values()) {\n      if (arrayVertex.array.size.isRef) {\n        continue;\n      }\n      const ast = arrayVertex.getFormula(this.lazilyTransformingAstService);\n      const address = arrayVertex.getAddress(this.lazilyTransformingAstService);\n      const hash = this.parser.computeHashFromAst(ast);\n      this.setFormulaToCellFromCache(hash, address);\n    }\n  }\n  /**\r\n   * Add multiple columns to sheet </br>\r\n   * Does nothing if columns are outside of effective sheet size\r\n   *\r\n   * @param sheet - sheet id in which columns will be added\r\n   * @param column - column number above which the columns will be added\r\n   * @param numberOfColumns - number of columns to add\r\n   */\n  doAddColumns(addedColumns) {\n    if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {\n      return;\n    }\n    const {\n      affectedArrays,\n      contentChanges\n    } = this.dependencyGraph.addColumns(addedColumns);\n    this.columnSearch.addColumns(addedColumns);\n    this.columnSearch.applyChanges(contentChanges.getChanges());\n    this.stats.measure(StatType.TRANSFORM_ASTS, () => {\n      const transformation = new AddColumnsTransformer(addedColumns);\n      transformation.performEagerTransformations(this.dependencyGraph, this.parser);\n      this.lazilyTransformingAstService.addTransformation(transformation);\n    });\n    this.rewriteAffectedArrays(affectedArrays);\n  }\n  /**\r\n   * Returns true if row number is outside of given sheet.\r\n   *\r\n   * @param column - row number\r\n   * @param sheet - sheet id number\r\n   */\n  columnEffectivelyNotInSheet(column, sheet) {\n    const width = this.dependencyGraph.addressMapping.getWidth(sheet);\n    return column >= width;\n  }\n  adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {\n    if (sheetId === undefined) {\n      return;\n    }\n    const localVertex = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);\n    const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);\n    const globalVertex = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);\n    for (const adjacentNode of this.dependencyGraph.graph.adjacentNodes(globalVertex)) {\n      if (adjacentNode instanceof FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {\n        const ast = adjacentNode.getFormula(this.lazilyTransformingAstService);\n        const formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        for (const dependency of absolutizeDependencies(dependencies, formulaAddress)) {\n          if (dependency instanceof NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {\n            this.dependencyGraph.graph.removeEdge(globalVertex, adjacentNode);\n            this.dependencyGraph.graph.addEdge(localVertex, adjacentNode);\n          }\n        }\n      }\n    }\n  }\n  storeNamedExpressionInCell(address, expression) {\n    const parsedCellContent = this.cellContentParser.parse(expression);\n    if (parsedCellContent instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedCellContent.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies\n      } = parsingResult;\n      this.dependencyGraph.setFormulaToCell(address, ast, absolutizeDependencies(dependencies, address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n    } else if (parsedCellContent instanceof CellContent.Empty) {\n      this.setCellEmpty(address);\n    } else {\n      this.setValueToCell({\n        parsedValue: parsedCellContent.value,\n        rawValue: expression\n      }, address);\n    }\n  }\n  updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const targetRange = AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);\n    for (const formulaAddress of targetRange.addresses(this.dependencyGraph)) {\n      const vertex = this.addressMapping.fetchCell(formulaAddress);\n      if (vertex instanceof FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {\n        const ast = vertex.getFormula(this.lazilyTransformingAstService);\n        const {\n          dependencies\n        } = this.parser.fetchCachedResultForAst(ast);\n        addedGlobalNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies));\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {\n    if (sourceSheet === targetAddress.sheet) {\n      return [];\n    }\n    const addedGlobalNamedExpressions = [];\n    const vertex = this.addressMapping.fetchCell(targetAddress);\n    for (const namedExpressionDependency of absolutizeDependencies(dependencies, targetAddress)) {\n      if (!(namedExpressionDependency instanceof NamedExpressionDependency)) {\n        continue;\n      }\n      const expressionName = namedExpressionDependency.name;\n      const sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet);\n      const namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);\n      const targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet) : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);\n      if (targetScopeExpressionVertex !== sourceVertex) {\n        this.dependencyGraph.graph.softRemoveEdge(sourceVertex, vertex);\n        this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);\n      }\n    }\n    return addedGlobalNamedExpressions;\n  }\n  allocateNamedExpressionAddressSpace() {\n    this.dependencyGraph.addressMapping.addSheet(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, new SparseStrategy(0, 0));\n  }\n  copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {\n    let expression = this.namedExpressions.namedExpressionForScope(expressionName);\n    if (expression === undefined) {\n      expression = this.namedExpressions.addNamedExpression(expressionName);\n      addedNamedExpressions.push(expression.normalizeExpressionName());\n      if (sourceVertex instanceof FormulaCellVertex) {\n        const parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));\n        const {\n          ast,\n          hasVolatileFunction,\n          hasStructuralChangeFunction,\n          dependencies\n        } = parsingResult;\n        this.dependencyGraph.setFormulaToCell(expression.address, ast, absolutizeDependencies(dependencies, expression.address), ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);\n      } else if (sourceVertex instanceof EmptyCellVertex) {\n        this.setCellEmpty(expression.address);\n      } else if (sourceVertex instanceof ValueCellVertex) {\n        this.setValueToCell(sourceVertex.getValues(), expression.address);\n      }\n    }\n    return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address);\n  }\n}\nexport function normalizeRemovedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge overlapping and adjacent indexes */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    const lastIndex = previous[0] + previous[1];\n    if (startIndex <= lastIndex) {\n      previous[1] += Math.max(0, amount - (lastIndex - startIndex));\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] -= shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nexport function normalizeAddedIndexes(indexes) {\n  if (indexes.length <= 1) {\n    return indexes;\n  }\n  const sorted = [...indexes].sort(([a], [b]) => a - b);\n  /* merge indexes with same start */\n  const merged = sorted.reduce((acc, [startIndex, amount]) => {\n    const previous = acc[acc.length - 1];\n    if (startIndex === previous[0]) {\n      previous[1] = Math.max(previous[1], amount);\n    } else {\n      acc.push([startIndex, amount]);\n    }\n    return acc;\n  }, [sorted[0]]);\n  /* shift further indexes */\n  let shift = 0;\n  for (let i = 0; i < merged.length; ++i) {\n    merged[i][0] += shift;\n    shift += merged[i][1];\n  }\n  return merged;\n}\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\nfunction isRowOrColumnRange(leftCorner, width, height) {\n  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}