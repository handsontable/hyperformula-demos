{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleRowAddress, simpleRowAddress } from '../Cell';\nimport { ReferenceType } from './ColumnAddress';\nexport class RowAddress {\n  constructor(type, row, sheet) {\n    this.type = type;\n    this.row = row;\n    this.sheet = sheet;\n  }\n  static absolute(row, sheet) {\n    return new RowAddress(ReferenceType.ABSOLUTE, row, sheet);\n  }\n  static relative(row, sheet) {\n    return new RowAddress(ReferenceType.RELATIVE, row, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (rowA, rowB) => rowA.toSimpleRowAddress(baseAddress).row - rowB.toSimpleRowAddress(baseAddress).row;\n  }\n  isRowAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isRowRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new RowAddress(this.type, this.row + toBottom, newSheet);\n  }\n  shiftedByRows(numberOfColumns) {\n    return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row = baseAddress.row + this.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const row = this.isRowRelative() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const row = this.isRowAbsolute() ? this.row + toBottom : this.row;\n    return new RowAddress(this.type, row, this.sheet);\n  }\n  withSheet(sheet) {\n    return new RowAddress(this.type, this.row, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleRowAddress(baseAddress).row < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#ROWR${this.row}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#ROWA${this.row}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleRowAddress(baseAddress);\n    if (invalidSimpleRowAddress(simpleAddress)) {\n      return undefined;\n    }\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxRows) {\n    return this.row >= maxRows;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}