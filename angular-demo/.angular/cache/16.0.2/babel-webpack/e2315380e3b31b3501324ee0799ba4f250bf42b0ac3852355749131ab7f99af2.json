{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from '../AbsoluteCellRange';\nimport { simpleCellAddress } from '../Cell';\n/**\r\n * Mapping from address ranges to range vertices\r\n */\nexport class RangeMapping {\n  constructor() {\n    /** Map in which actual data is stored. */\n    this.rangeMapping = new Map();\n  }\n  getMappingSize(sheet) {\n    var _a, _b;\n    return (_b = (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;\n  }\n  /**\r\n   * Saves range vertex\r\n   *\r\n   * @param vertex - vertex to save\r\n   */\n  setRange(vertex) {\n    let sheetMap = this.rangeMapping.get(vertex.getStart().sheet);\n    if (sheetMap === undefined) {\n      sheetMap = new Map();\n      this.rangeMapping.set(vertex.getStart().sheet, sheetMap);\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.set(key, vertex);\n  }\n  removeRange(vertex) {\n    const sheet = vertex.getStart().sheet;\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (sheetMap === undefined) {\n      return;\n    }\n    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());\n    sheetMap.delete(key);\n    if (sheetMap.size === 0) {\n      this.rangeMapping.delete(sheet);\n    }\n  }\n  /**\r\n   * Returns associated vertex for given range\r\n   *\r\n   * @param start - top-left corner of the range\r\n   * @param end - bottom-right corner of the range\r\n   */\n  getRange(start, end) {\n    const sheetMap = this.rangeMapping.get(start.sheet);\n    const key = keyFromAddresses(start, end);\n    return sheetMap === null || sheetMap === void 0 ? void 0 : sheetMap.get(key);\n  }\n  fetchRange(start, end) {\n    const maybeRange = this.getRange(start, end);\n    if (!maybeRange) {\n      throw Error('Range does not exist');\n    }\n    return maybeRange;\n  }\n  truncateRanges(span, coordinate) {\n    const verticesToRemove = Array();\n    const updated = Array();\n    const verticesWithChangedSize = Array();\n    const sheet = span.sheet;\n    for (const [key, vertex] of this.entriesFromSheet(span.sheet)) {\n      const range = vertex.range;\n      if (span.start <= coordinate(vertex.range.end)) {\n        range.removeSpan(span);\n        if (range.shouldBeRemoved()) {\n          this.removeByKey(sheet, key);\n          verticesToRemove.push(vertex);\n        } else {\n          updated.push([key, vertex]);\n        }\n        verticesWithChangedSize.push(vertex);\n      }\n    }\n    const verticesToMerge = [];\n    updated.sort((left, right) => compareBy(left[1], right[1], coordinate));\n    for (const [oldKey, vertex] of updated) {\n      const newKey = keyFromRange(vertex.range);\n      if (newKey === oldKey) {\n        continue;\n      }\n      const existingVertex = this.getByKey(sheet, newKey);\n      this.removeByKey(sheet, oldKey);\n      if (existingVertex !== undefined && vertex != existingVertex) {\n        verticesToMerge.push([existingVertex, vertex]);\n      } else {\n        this.setRange(vertex);\n      }\n    }\n    return {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    };\n  }\n  moveAllRangesInSheetAfterRowByRows(sheet, row, numberOfRows) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (row <= vertex.start.row) {\n        vertex.range.shiftByRows(numberOfRows);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (row > vertex.start.row && row <= vertex.end.row) {\n        vertex.range.expandByRows(numberOfRows);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveAllRangesInSheetAfterColumnByColumns(sheet, column, numberOfColumns) {\n    return this.updateVerticesFromSheet(sheet, (key, vertex) => {\n      if (column <= vertex.start.col) {\n        vertex.range.shiftByColumns(numberOfColumns);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else if (column > vertex.start.col && column <= vertex.end.col) {\n        vertex.range.expandByColumns(numberOfColumns);\n        return {\n          changedSize: true,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet) {\n    this.updateVerticesFromSheet(sourceRange.sheet, (key, vertex) => {\n      if (sourceRange.containsRange(vertex.range)) {\n        vertex.range.shiftByColumns(toRight);\n        vertex.range.shiftByRows(toBottom);\n        vertex.range.moveToSheet(toSheet);\n        return {\n          changedSize: false,\n          vertex: vertex\n        };\n      } else {\n        return undefined;\n      }\n    });\n  }\n  removeRangesInSheet(sheet) {\n    if (this.rangeMapping.has(sheet)) {\n      const ranges = this.rangeMapping.get(sheet).values();\n      this.rangeMapping.delete(sheet);\n      return ranges;\n    }\n    return [][Symbol.iterator]();\n  }\n  *rangesInSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.values();\n  }\n  *rangeVerticesContainedInRange(sourceRange) {\n    for (const rangeVertex of this.rangesInSheet(sourceRange.sheet)) {\n      if (sourceRange.containsRange(rangeVertex.range)) {\n        yield rangeVertex;\n      }\n    }\n  }\n  /**\r\n   * Finds smaller range does have own vertex.\r\n   *\r\n   * @param range\r\n   */\n  findSmallerRange(range) {\n    if (range.height() > 1 && Number.isFinite(range.height())) {\n      const valuesRangeEndRowLess = simpleCellAddress(range.end.sheet, range.end.col, range.end.row - 1);\n      const rowLessVertex = this.getRange(range.start, valuesRangeEndRowLess);\n      if (rowLessVertex !== undefined) {\n        const restRange = AbsoluteCellRange.fromSimpleCellAddresses(simpleCellAddress(range.start.sheet, range.start.col, range.end.row), range.end);\n        return {\n          smallerRangeVertex: rowLessVertex,\n          restRange\n        };\n      }\n    }\n    return {\n      restRange: range\n    };\n  }\n  *entriesFromSheet(sheet) {\n    const sheetMap = this.rangeMapping.get(sheet);\n    if (!sheetMap) {\n      return;\n    }\n    yield* sheetMap.entries();\n  }\n  removeByKey(sheet, key) {\n    this.rangeMapping.get(sheet).delete(key);\n  }\n  getByKey(sheet, key) {\n    var _a;\n    return (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.get(key);\n  }\n  updateVerticesFromSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.entriesFromSheet(sheet)) {\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeByKey(sheet, key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(entry => {\n      this.setRange(entry.vertex);\n    });\n    return {\n      verticesWithChangedSize: updated.filter(entry => entry.changedSize).map(entry => entry.vertex)\n    };\n  }\n}\nfunction keyFromAddresses(start, end) {\n  return `${start.col},${start.row},${end.col},${end.row}`;\n}\nfunction keyFromRange(range) {\n  return keyFromAddresses(range.start, range.end);\n}\nconst compareBy = (left, right, coordinate) => {\n  const leftStart = coordinate(left.range.start);\n  const rightStart = coordinate(left.range.start);\n  if (leftStart === rightStart) {\n    const leftEnd = coordinate(left.range.end);\n    const rightEnd = coordinate(right.range.end);\n    return leftEnd - rightEnd;\n  } else {\n    return leftStart - rightStart;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}