{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from './Cell';\nimport { DetailedCellError } from './CellValue';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getRawValue, isExtendedNumber } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './SimpleRangeValue';\nimport { NamedExpressions } from './NamedExpressions';\nimport { simpleCellAddressToString } from './parser/addressRepresentationConverters';\n/**\r\n * A list of cells which values changed after the operation, their absolute addresses and new values.\r\n */\nexport class ExportedCellChange {\n  constructor(address, newValue) {\n    this.address = address;\n    this.newValue = newValue;\n  }\n  get col() {\n    return this.address.col;\n  }\n  get row() {\n    return this.address.row;\n  }\n  get sheet() {\n    return this.address.sheet;\n  }\n  get value() {\n    return this.newValue;\n  }\n}\nexport class ExportedNamedExpressionChange {\n  constructor(name, newValue) {\n    this.name = name;\n    this.newValue = newValue;\n  }\n}\nexport class Exporter {\n  constructor(config, namedExpressions, sheetIndexMapping, lazilyTransformingService) {\n    this.config = config;\n    this.namedExpressions = namedExpressions;\n    this.sheetIndexMapping = sheetIndexMapping;\n    this.lazilyTransformingService = lazilyTransformingService;\n  }\n  exportChange(change) {\n    const value = change.value;\n    const address = change.address;\n    if (address.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n      const namedExpression = this.namedExpressions.namedExpressionInAddress(address.row);\n      if (!namedExpression) {\n        throw new Error('Missing named expression');\n      }\n      return new ExportedNamedExpressionChange(namedExpression.displayName, this.exportScalarOrRange(value));\n    } else if (value instanceof SimpleRangeValue) {\n      const result = [];\n      for (const [cellValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        result.push(new ExportedCellChange(cellAddress, this.exportValue(cellValue)));\n      }\n      return result;\n    } else {\n      return new ExportedCellChange(address, this.exportValue(value));\n    }\n  }\n  exportValue(value) {\n    if (value instanceof SimpleRangeValue) {\n      return this.detailedError(new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected));\n    } else if (this.config.smartRounding && isExtendedNumber(value)) {\n      return this.cellValueRounding(getRawValue(value));\n    } else if (value instanceof CellError) {\n      return this.detailedError(value);\n    } else if (value === EmptyValue) {\n      return null;\n    } else {\n      return getRawValue(value);\n    }\n  }\n  exportScalarOrRange(value) {\n    if (value instanceof SimpleRangeValue) {\n      return value.rawData().map(row => row.map(v => this.exportValue(v)));\n    } else {\n      return this.exportValue(value);\n    }\n  }\n  detailedError(error) {\n    var _a, _b;\n    let address = undefined;\n    const originAddress = (_a = error.root) === null || _a === void 0 ? void 0 : _a.getAddress(this.lazilyTransformingService);\n    if (originAddress !== undefined) {\n      if (originAddress.sheet === NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {\n        address = (_b = this.namedExpressions.namedExpressionInAddress(originAddress.row)) === null || _b === void 0 ? void 0 : _b.displayName;\n      } else {\n        address = simpleCellAddressToString(this.sheetIndexMapping, originAddress, -1);\n      }\n    }\n    return new DetailedCellError(error, this.config.translationPackage.getErrorTranslation(error.type), address);\n  }\n  cellValueRounding(value) {\n    if (value === 0) {\n      return value;\n    }\n    const magnitudeMultiplierExponent = Math.floor(Math.log10(Math.abs(value)));\n    const placesMultiplier = Math.pow(10, this.config.precisionRounding - magnitudeMultiplierExponent);\n    if (value < 0) {\n      return -Math.round(-value * placesMultiplier) / placesMultiplier;\n    } else {\n      return Math.round(value * placesMultiplier) / placesMultiplier;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}