{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { tokenMatcher } from 'chevrotain';\nimport { ErrorType } from '../Cell';\nimport { AstNodeType, buildParsingErrorAst, CellAddress, collectDependencies } from './';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { imageWithWhitespace, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { binaryOpTokenMap } from './binaryOpTokenMap';\nimport { Cache } from './Cache';\nimport { FormulaLexer, FormulaParser } from './FormulaParser';\nimport { buildLexerConfig, CellReference, ColumnRange, ProcedureName, RowRange } from './LexerConfig';\nimport { formatNumber } from './Unparser';\nimport { ColumnAddress } from './ColumnAddress';\nimport { RowAddress } from './RowAddress';\n/**\r\n * Parses formula using caching if feasible.\r\n */\nexport class ParserWithCaching {\n  constructor(config, functionRegistry, sheetMapping) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n    this.sheetMapping = sheetMapping;\n    this.statsCacheUsed = 0;\n    this.lexerConfig = buildLexerConfig(config);\n    this.lexer = new FormulaLexer(this.lexerConfig);\n    this.formulaParser = new FormulaParser(this.lexerConfig, this.sheetMapping);\n    this.cache = new Cache(this.functionRegistry);\n  }\n  /**\r\n   * Parses a formula.\r\n   *\r\n   * @param text - formula to parse\r\n   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.\r\n   */\n  parse(text, formulaAddress) {\n    this.formulaAddress = formulaAddress;\n    const lexerResult = this.tokenizeFormula(text);\n    if (lexerResult.errors.length > 0) {\n      const errors = lexerResult.errors.map(e => ({\n        type: ParsingErrorType.LexingError,\n        message: e.message\n      }));\n      return {\n        ast: buildParsingErrorAst(),\n        errors,\n        hasVolatileFunction: false,\n        hasStructuralChangeFunction: false,\n        dependencies: []\n      };\n    }\n    const hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);\n    let cacheResult = this.cache.get(hash);\n    if (cacheResult !== undefined) {\n      ++this.statsCacheUsed;\n    } else {\n      const processedTokens = this.bindWhitespacesToTokens(lexerResult.tokens);\n      const parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);\n      if (parsingResult.errors.length > 0) {\n        return Object.assign(Object.assign({}, parsingResult), {\n          hasVolatileFunction: false,\n          hasStructuralChangeFunction: false,\n          dependencies: []\n        });\n      } else {\n        cacheResult = this.cache.set(hash, parsingResult.ast);\n      }\n    }\n    const {\n      ast,\n      hasVolatileFunction,\n      hasStructuralChangeFunction\n    } = cacheResult;\n    const astWithNoReversedRanges = this.convertReversedRangesToRegularRanges(ast);\n    const dependencies = collectDependencies(astWithNoReversedRanges, this.functionRegistry);\n    return {\n      ast: astWithNoReversedRanges,\n      errors: [],\n      hasVolatileFunction,\n      hasStructuralChangeFunction,\n      dependencies\n    };\n  }\n  convertReversedRangesToRegularRanges(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n      case AstNodeType.NUMBER:\n      case AstNodeType.STRING:\n      case AstNodeType.ERROR:\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n      case AstNodeType.CELL_REFERENCE:\n      case AstNodeType.NAMED_EXPRESSION:\n        return ast;\n      case AstNodeType.CELL_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderCellRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.COLUMN_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderColumnRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.ROW_RANGE:\n        {\n          const {\n            start,\n            end\n          } = ast;\n          const orderedEnds = this.orderRowRangeEnds(start, end);\n          return Object.assign(Object.assign({}, ast), {\n            start: orderedEnds.start,\n            end: orderedEnds.end\n          });\n        }\n      case AstNodeType.PERCENT_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const valueFixed = this.convertReversedRangesToRegularRanges(ast.value);\n          return Object.assign(Object.assign({}, ast), {\n            value: valueFixed\n          });\n        }\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.TIMES_OP:\n      case AstNodeType.DIV_OP:\n      case AstNodeType.POWER_OP:\n        {\n          const leftFixed = this.convertReversedRangesToRegularRanges(ast.left);\n          const rightFixed = this.convertReversedRangesToRegularRanges(ast.right);\n          return Object.assign(Object.assign({}, ast), {\n            left: leftFixed,\n            right: rightFixed\n          });\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const exprFixed = this.convertReversedRangesToRegularRanges(ast.expression);\n          return Object.assign(Object.assign({}, ast), {\n            expression: exprFixed\n          });\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const argsFixed = ast.args.map(arg => this.convertReversedRangesToRegularRanges(arg));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n      case AstNodeType.ARRAY:\n        {\n          const argsFixed = ast.args.map(argsRow => argsRow.map(arg => this.convertReversedRangesToRegularRanges(arg)));\n          return Object.assign(Object.assign({}, ast), {\n            args: argsFixed\n          });\n        }\n    }\n  }\n  orderCellRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.map(e => e.toColumnAddress()).sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startRow, endRow] = ends.map(e => e.toRowAddress()).sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: CellAddress.fromColAndRow(startCol, startRow, startSheet),\n      end: CellAddress.fromColAndRow(endCol, endRow, endSheet)\n    };\n  }\n  orderColumnRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startCol, endCol] = ends.sort(ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new ColumnAddress(startCol.type, startCol.col, startSheet),\n      end: new ColumnAddress(endCol.type, endCol.col, endSheet)\n    };\n  }\n  orderRowRangeEnds(endA, endB) {\n    const ends = [endA, endB];\n    const [startRow, endRow] = ends.sort(RowAddress.compareByAbsoluteAddress(this.formulaAddress));\n    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));\n    return {\n      start: new RowAddress(startRow.type, startRow.row, startSheet),\n      end: new RowAddress(endRow.type, endRow.row, endSheet)\n    };\n  }\n  static compareSheetIds(sheetA, sheetB) {\n    sheetA = sheetA != null ? sheetA : Infinity;\n    sheetB = sheetB != null ? sheetB : Infinity;\n    return sheetA - sheetB;\n  }\n  fetchCachedResultForAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.fetchCachedResult(hash);\n  }\n  fetchCachedResult(hash) {\n    const cacheResult = this.cache.get(hash);\n    if (cacheResult === undefined) {\n      throw new Error('There is no AST with such key in the cache');\n    } else {\n      const {\n        ast,\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        relativeDependencies\n      } = cacheResult;\n      return {\n        ast,\n        errors: [],\n        hasVolatileFunction,\n        hasStructuralChangeFunction,\n        dependencies: relativeDependencies\n      };\n    }\n  }\n  computeHashFromTokens(tokens, baseAddress) {\n    var _a;\n    let hash = '';\n    let idx = 0;\n    while (idx < tokens.length) {\n      const token = tokens[idx];\n      if (tokenMatcher(token, CellReference)) {\n        const cellAddress = cellAddressFromString(this.sheetMapping, token.image, baseAddress);\n        if (cellAddress === undefined) {\n          hash = hash.concat(token.image);\n        } else {\n          hash = hash.concat(cellAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, ProcedureName)) {\n        const procedureName = token.image.toUpperCase().slice(0, -1);\n        const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n        hash = hash.concat(canonicalProcedureName, '(');\n      } else if (tokenMatcher(token, ColumnRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = columnAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = columnAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else if (tokenMatcher(token, RowRange)) {\n        const [start, end] = token.image.split(':');\n        const startAddress = rowAddressFromString(this.sheetMapping, start, baseAddress);\n        const endAddress = rowAddressFromString(this.sheetMapping, end, baseAddress);\n        if (startAddress === undefined || endAddress === undefined) {\n          hash = hash.concat('!REF');\n        } else {\n          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));\n        }\n      } else {\n        hash = hash.concat(token.image);\n      }\n      idx++;\n    }\n    return hash;\n  }\n  rememberNewAst(ast) {\n    const hash = this.computeHashFromAst(ast);\n    return this.cache.maybeSetAndThenGet(hash, ast);\n  }\n  computeHashFromAst(ast) {\n    return '=' + this.computeHashOfAstNode(ast);\n  }\n  computeHashOfAstNode(ast) {\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return ast.leadingWhitespace || '';\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          return imageWithWhitespace(ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => this.computeHashOfAstNode(arg)).join(this.config.functionArgSeparator);\n          const rightPart = ast.procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          return imageWithWhitespace(ast.reference.hash(true), ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const start = ast.start.hash(ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE);\n          const end = ast.end.hash(ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE);\n          return imageWithWhitespace(start + ':' + end, ast.leadingWhitespace);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          return imageWithWhitespace('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          return imageWithWhitespace('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.computeHashOfAstNode(ast.value) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const args = ast.args.map(row => row.map(val => this.computeHashOfAstNode(val)).join(',')).join(';');\n          return imageWithWhitespace('{' + args + imageWithWhitespace('}', ast.internalWhitespace), ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.computeHashOfAstNode(ast.expression);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      default:\n        {\n          return this.computeHashOfAstNode(ast.left) + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);\n        }\n    }\n  }\n  bindWhitespacesToTokens(tokens) {\n    const processedTokens = [];\n    const first = tokens[0];\n    if (!tokenMatcher(first, this.lexerConfig.WhiteSpace)) {\n      processedTokens.push(first);\n    }\n    for (let i = 1; i < tokens.length; ++i) {\n      const current = tokens[i];\n      if (tokenMatcher(current, this.lexerConfig.WhiteSpace)) {\n        continue;\n      }\n      const previous = tokens[i - 1];\n      if (tokenMatcher(previous, this.lexerConfig.WhiteSpace)) {\n        current.leadingWhitespace = previous;\n      }\n      processedTokens.push(current);\n    }\n    return processedTokens;\n  }\n  tokenizeFormula(text) {\n    return this.lexer.tokenizeFormula(text);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}