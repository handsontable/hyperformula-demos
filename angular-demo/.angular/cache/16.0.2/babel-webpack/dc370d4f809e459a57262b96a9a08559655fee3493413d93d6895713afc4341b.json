{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex, ValueCellVertex } from './DependencyGraph';\nimport { ErrorMessage } from './error-message';\nimport { EmptyValue, getFormatOfExtendedNumber, getTypeOfExtendedNumber, isExtendedNumber, NumberType } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './SimpleRangeValue';\n/**\r\n * Possible errors returned by our interpreter.\r\n */\nexport var ErrorType = /*#__PURE__*/(() => {\n  ErrorType = ErrorType || {};\n  /** Division by zero. */\n  ErrorType[\"DIV_BY_ZERO\"] = \"DIV_BY_ZERO\";\n  /** Unknown function name. */\n  ErrorType[\"NAME\"] = \"NAME\";\n  ErrorType[\"VALUE\"] = \"VALUE\";\n  ErrorType[\"NUM\"] = \"NUM\";\n  ErrorType[\"NA\"] = \"NA\";\n  /** Cyclic dependency. */\n  ErrorType[\"CYCLE\"] = \"CYCLE\";\n  /** Wrong address reference. */\n  ErrorType[\"REF\"] = \"REF\";\n  /** Array spill error. */\n  ErrorType[\"SPILL\"] = \"SPILL\";\n  /** Invalid/missing licence error. */\n  ErrorType[\"LIC\"] = \"LIC\";\n  /** Generic error */\n  ErrorType[\"ERROR\"] = \"ERROR\";\n  return ErrorType;\n})();\nexport var CellType = /*#__PURE__*/(() => {\n  CellType = CellType || {};\n  CellType[\"FORMULA\"] = \"FORMULA\";\n  CellType[\"VALUE\"] = \"VALUE\";\n  CellType[\"ARRAY\"] = \"ARRAY\";\n  CellType[\"EMPTY\"] = \"EMPTY\";\n  CellType[\"ARRAYFORMULA\"] = \"ARRAYFORMULA\";\n  return CellType;\n})();\nexport const getCellType = (vertex, address) => {\n  if (vertex instanceof ArrayVertex) {\n    if (vertex.isLeftCorner(address)) {\n      return CellType.ARRAYFORMULA;\n    } else {\n      return CellType.ARRAY;\n    }\n  }\n  if (vertex instanceof FormulaCellVertex || vertex instanceof ParsingErrorVertex) {\n    return CellType.FORMULA;\n  }\n  if (vertex instanceof ValueCellVertex) {\n    return CellType.VALUE;\n  }\n  return CellType.EMPTY;\n};\nexport var CellValueNoNumber = /*#__PURE__*/(() => {\n  CellValueNoNumber = CellValueNoNumber || {};\n  CellValueNoNumber[\"EMPTY\"] = \"EMPTY\";\n  CellValueNoNumber[\"NUMBER\"] = \"NUMBER\";\n  CellValueNoNumber[\"STRING\"] = \"STRING\";\n  CellValueNoNumber[\"BOOLEAN\"] = \"BOOLEAN\";\n  CellValueNoNumber[\"ERROR\"] = \"ERROR\";\n  return CellValueNoNumber;\n})();\nexport var CellValueJustNumber = /*#__PURE__*/(() => {\n  CellValueJustNumber = CellValueJustNumber || {};\n  CellValueJustNumber[\"NUMBER\"] = \"NUMBER\";\n  return CellValueJustNumber;\n})();\nexport const CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);\nexport const CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), NumberType);\nexport const CellValueTypeOrd = arg => {\n  switch (arg) {\n    case CellValueType.EMPTY:\n      return 0;\n    case CellValueType.NUMBER:\n      return 1;\n    case CellValueType.STRING:\n      return 2;\n    case CellValueType.BOOLEAN:\n      return 3;\n    case CellValueType.ERROR:\n      return 4;\n  }\n  throw new Error('Cell value not computed');\n};\nexport const getCellValueType = cellValue => {\n  if (cellValue === EmptyValue) {\n    return CellValueType.EMPTY;\n  }\n  if (cellValue instanceof CellError || cellValue instanceof SimpleRangeValue) {\n    return CellValueType.ERROR;\n  }\n  if (typeof cellValue === 'string') {\n    return CellValueType.STRING;\n  } else if (isExtendedNumber(cellValue)) {\n    return CellValueType.NUMBER;\n  } else if (typeof cellValue === 'boolean') {\n    return CellValueType.BOOLEAN;\n  }\n  throw new Error('Cell value not computed');\n};\nexport const getCellValueDetailedType = cellValue => {\n  if (isExtendedNumber(cellValue)) {\n    return getTypeOfExtendedNumber(cellValue);\n  } else {\n    return getCellValueType(cellValue);\n  }\n};\nexport const getCellValueFormat = cellValue => {\n  if (isExtendedNumber(cellValue)) {\n    return getFormatOfExtendedNumber(cellValue);\n  } else {\n    return undefined;\n  }\n};\nexport class CellError {\n  constructor(type, message, root) {\n    this.type = type;\n    this.message = message;\n    this.root = root;\n  }\n  static parsingError() {\n    return new CellError(ErrorType.ERROR, ErrorMessage.ParseError);\n  }\n  attachRootVertex(vertex) {\n    if (this.root === undefined) {\n      return new CellError(this.type, this.message, vertex);\n    } else {\n      return this;\n    }\n  }\n}\nexport const simpleRowAddress = (sheet, row) => ({\n  sheet,\n  row\n});\nexport const invalidSimpleRowAddress = address => address.row < 0;\nexport const simpleColumnAddress = (sheet, col) => ({\n  sheet,\n  col\n});\nexport const invalidSimpleColumnAddress = address => address.col < 0;\nexport const simpleCellAddress = (sheet, col, row) => ({\n  sheet,\n  col,\n  row\n});\nexport const invalidSimpleCellAddress = address => address.col < 0 || address.row < 0;\nexport const movedSimpleCellAddress = (address, toSheet, toRight, toBottom) => {\n  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);\n};\nexport const addressKey = address => `${address.sheet},${address.row},${address.col}`;\nexport function isSimpleCellAddress(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'col' in obj && typeof obj.col === 'number' && 'row' in obj && typeof obj.row === 'number' && 'sheet' in obj && typeof obj.sheet === 'number';\n  } else {\n    return false;\n  }\n}\nexport const absoluteSheetReference = (address, baseAddress) => {\n  var _a;\n  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;\n};\nexport const equalSimpleCellAddress = (left, right) => {\n  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}