{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport function findNextOddNumber(arg) {\n  const ceiled = Math.ceil(arg);\n  return ceiled % 2 === 1 ? ceiled : ceiled + 1;\n}\nexport function findNextEvenNumber(arg) {\n  const ceiled = Math.ceil(arg);\n  return ceiled % 2 === 0 ? ceiled : ceiled + 1;\n}\nexport class RoundingPlugin extends FunctionPlugin {\n  roundup(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {\n      const placesMultiplier = Math.pow(10, places);\n      if (numberToRound < 0) {\n        return -Math.ceil(-numberToRound * placesMultiplier) / placesMultiplier;\n      } else {\n        return Math.ceil(numberToRound * placesMultiplier) / placesMultiplier;\n      }\n    });\n  }\n  rounddown(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {\n      const placesMultiplier = Math.pow(10, places);\n      if (numberToRound < 0) {\n        return -Math.floor(-numberToRound * placesMultiplier) / placesMultiplier;\n      } else {\n        return Math.floor(numberToRound * placesMultiplier) / placesMultiplier;\n      }\n    });\n  }\n  round(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ROUND'), (numberToRound, places) => {\n      const placesMultiplier = Math.pow(10, places);\n      if (numberToRound < 0) {\n        return -Math.round(-numberToRound * placesMultiplier) / placesMultiplier;\n      } else {\n        return Math.round(numberToRound * placesMultiplier) / placesMultiplier;\n      }\n    });\n  }\n  intFunc(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('INT'), coercedNumberToRound => {\n      if (coercedNumberToRound < 0) {\n        return -Math.floor(-coercedNumberToRound);\n      } else {\n        return Math.floor(coercedNumberToRound);\n      }\n    });\n  }\n  even(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EVEN'), coercedNumberToRound => {\n      if (coercedNumberToRound < 0) {\n        return -findNextEvenNumber(-coercedNumberToRound);\n      } else {\n        return findNextEvenNumber(coercedNumberToRound);\n      }\n    });\n  }\n  odd(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ODD'), coercedNumberToRound => {\n      if (coercedNumberToRound < 0) {\n        return -findNextOddNumber(-coercedNumberToRound);\n      } else {\n        return findNextOddNumber(coercedNumberToRound);\n      }\n    });\n  }\n  ceilingmath(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CEILING.MATH'), (value, significance, mode) => {\n      if (significance === 0 || value === 0) {\n        return 0;\n      }\n      significance = Math.abs(significance);\n      if (mode === 1 && value < 0) {\n        significance = -significance;\n      }\n      return Math.ceil(value / significance) * significance;\n    });\n  }\n  ceiling(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CEILING'), (value, significance) => {\n      if (value === 0) {\n        return 0;\n      }\n      if (significance === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      if (value > 0 && significance < 0) {\n        return new CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);\n      }\n      return Math.ceil(value / significance) * significance;\n    });\n  }\n  ceilingprecise(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CEILING.PRECISE'), (value, significance) => {\n      if (significance === 0 || value === 0) {\n        return 0;\n      }\n      significance = Math.abs(significance);\n      return Math.ceil(value / significance) * significance;\n    });\n  }\n  floormath(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FLOOR.MATH'), (value, significance, mode) => {\n      if (significance === 0 || value === 0) {\n        return 0;\n      }\n      significance = Math.abs(significance);\n      if (mode === 1 && value < 0) {\n        significance *= -1;\n      }\n      return Math.floor(value / significance) * significance;\n    });\n  }\n  floor(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FLOOR'), (value, significance) => {\n      if (value === 0) {\n        return 0;\n      }\n      if (significance === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      if (value > 0 && significance < 0) {\n        return new CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);\n      }\n      return Math.floor(value / significance) * significance;\n    });\n  }\n  floorprecise(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FLOOR.PRECISE'), (value, significance) => {\n      if (significance === 0 || value === 0) {\n        return 0;\n      }\n      significance = Math.abs(significance);\n      return Math.floor(value / significance) * significance;\n    });\n  }\n}\nRoundingPlugin.implementedFunctions = {\n  'ROUNDUP': {\n    method: 'roundup',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'ROUNDDOWN': {\n    method: 'rounddown',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'ROUND': {\n    method: 'round',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'INT': {\n    method: 'intFunc',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'EVEN': {\n    method: 'even',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'ODD': {\n    method: 'odd',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'CEILING.MATH': {\n    method: 'ceilingmath',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'CEILING': {\n    method: 'ceiling',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'CEILING.PRECISE': {\n    method: 'ceilingprecise',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'FLOOR.MATH': {\n    method: 'floormath',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'FLOOR': {\n    method: 'floor',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'FLOOR.PRECISE': {\n    method: 'floorprecise',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  }\n};\nRoundingPlugin.aliases = {\n  'ISO.CEILING': 'CEILING.PRECISE',\n  'TRUNC': 'ROUNDDOWN'\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}