{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { createToken, Lexer } from 'chevrotain';\nimport { ALL_WHITESPACE_PATTERN, COLUMN_REFERENCE_PATTERN, NON_RESERVED_CHARACTER_PATTERN, ODFF_WHITESPACE_PATTERN, RANGE_OPERATOR, ROW_REFERENCE_PATTERN, UNICODE_LETTER_PATTERN } from './parser-consts';\nimport { CellReferenceMatcher } from './CellReferenceMatcher';\nimport { NamedExpressionMatcher } from './NamedExpressionMatcher';\nexport const AdditionOp = createToken({\n  name: 'AdditionOp',\n  pattern: Lexer.NA\n});\nexport const PlusOp = createToken({\n  name: 'PlusOp',\n  pattern: /\\+/,\n  categories: AdditionOp\n});\nexport const MinusOp = createToken({\n  name: 'MinusOp',\n  pattern: /-/,\n  categories: AdditionOp\n});\nexport const MultiplicationOp = createToken({\n  name: 'MultiplicationOp',\n  pattern: Lexer.NA\n});\nexport const TimesOp = createToken({\n  name: 'TimesOp',\n  pattern: /\\*/,\n  categories: MultiplicationOp\n});\nexport const DivOp = createToken({\n  name: 'DivOp',\n  pattern: /\\//,\n  categories: MultiplicationOp\n});\nexport const PowerOp = createToken({\n  name: 'PowerOp',\n  pattern: /\\^/\n});\nexport const PercentOp = createToken({\n  name: 'PercentOp',\n  pattern: /%/\n});\nexport const BooleanOp = createToken({\n  name: 'BooleanOp',\n  pattern: Lexer.NA\n});\nexport const EqualsOp = createToken({\n  name: 'EqualsOp',\n  pattern: /=/,\n  categories: BooleanOp\n});\nexport const NotEqualOp = createToken({\n  name: 'NotEqualOp',\n  pattern: /<>/,\n  categories: BooleanOp\n});\nexport const GreaterThanOp = createToken({\n  name: 'GreaterThanOp',\n  pattern: />/,\n  categories: BooleanOp\n});\nexport const LessThanOp = createToken({\n  name: 'LessThanOp',\n  pattern: /</,\n  categories: BooleanOp\n});\nexport const GreaterThanOrEqualOp = createToken({\n  name: 'GreaterThanOrEqualOp',\n  pattern: />=/,\n  categories: BooleanOp\n});\nexport const LessThanOrEqualOp = createToken({\n  name: 'LessThanOrEqualOp',\n  pattern: /<=/,\n  categories: BooleanOp\n});\nexport const ConcatenateOp = createToken({\n  name: 'ConcatenateOp',\n  pattern: /&/\n});\nexport const LParen = createToken({\n  name: 'LParen',\n  pattern: /\\(/\n});\nexport const RParen = createToken({\n  name: 'RParen',\n  pattern: /\\)/\n});\nexport const ArrayLParen = createToken({\n  name: 'ArrayLParen',\n  pattern: /{/\n});\nexport const ArrayRParen = createToken({\n  name: 'ArrayRParen',\n  pattern: /}/\n});\nexport const StringLiteral = createToken({\n  name: 'StringLiteral',\n  pattern: /\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/\n});\nexport const ErrorLiteral = createToken({\n  name: 'ErrorLiteral',\n  pattern: /#[A-Za-z0-9\\/]+[?!]?/\n});\nexport const RangeSeparator = createToken({\n  name: 'RangeSeparator',\n  pattern: new RegExp(RANGE_OPERATOR)\n});\nexport const ColumnRange = createToken({\n  name: 'ColumnRange',\n  pattern: new RegExp(`${COLUMN_REFERENCE_PATTERN}${RANGE_OPERATOR}${COLUMN_REFERENCE_PATTERN}`)\n});\nexport const RowRange = createToken({\n  name: 'RowRange',\n  pattern: new RegExp(`${ROW_REFERENCE_PATTERN}${RANGE_OPERATOR}${ROW_REFERENCE_PATTERN}`)\n});\nexport const ProcedureName = createToken({\n  name: 'ProcedureName',\n  pattern: new RegExp(`([${UNICODE_LETTER_PATTERN}][${NON_RESERVED_CHARACTER_PATTERN}]*)\\\\(`)\n});\nconst cellReferenceMatcher = new CellReferenceMatcher();\nexport const CellReference = createToken({\n  name: 'CellReference',\n  pattern: cellReferenceMatcher.match.bind(cellReferenceMatcher),\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  start_chars_hint: cellReferenceMatcher.POSSIBLE_START_CHARACTERS,\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  line_breaks: false\n});\nconst namedExpressionMatcher = new NamedExpressionMatcher();\nexport const NamedExpression = createToken({\n  name: 'NamedExpression',\n  pattern: namedExpressionMatcher.match.bind(namedExpressionMatcher),\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  start_chars_hint: namedExpressionMatcher.POSSIBLE_START_CHARACTERS,\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  line_breaks: false\n});\n/**\r\n * Builds the configuration object for the lexer\r\n */\nexport const buildLexerConfig = config => {\n  const offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');\n  const errorMapping = config.errorMapping;\n  const functionMapping = config.translationPackage.buildFunctionMapping();\n  const whitespaceTokenRegexp = new RegExp(config.ignoreWhiteSpace === 'standard' ? ODFF_WHITESPACE_PATTERN : ALL_WHITESPACE_PATTERN);\n  const WhiteSpace = createToken({\n    name: 'WhiteSpace',\n    pattern: whitespaceTokenRegexp\n  });\n  const ArrayRowSeparator = createToken({\n    name: 'ArrayRowSep',\n    pattern: config.arrayRowSeparator\n  });\n  const ArrayColSeparator = createToken({\n    name: 'ArrayColSep',\n    pattern: config.arrayColumnSeparator\n  });\n  const NumberLiteral = createToken({\n    name: 'NumberLiteral',\n    pattern: new RegExp(`(([${config.decimalSeparator}]\\\\d+)|(\\\\d+([${config.decimalSeparator}]\\\\d*)?))(e[+-]?\\\\d+)?`)\n  });\n  const OffsetProcedureName = createToken({\n    name: 'OffsetProcedureName',\n    pattern: new RegExp(offsetProcedureNameLiteral, 'i')\n  });\n  let ArgSeparator;\n  let inject;\n  if (config.functionArgSeparator === config.arrayColumnSeparator) {\n    ArgSeparator = ArrayColSeparator;\n    inject = [];\n  } else if (config.functionArgSeparator === config.arrayRowSeparator) {\n    ArgSeparator = ArrayRowSeparator;\n    inject = [];\n  } else {\n    ArgSeparator = createToken({\n      name: 'ArgSeparator',\n      pattern: config.functionArgSeparator\n    });\n    inject = [ArgSeparator];\n  }\n  /* order is important, first pattern is used */\n  const allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator, ...inject, ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator];\n  return {\n    ArgSeparator,\n    NumberLiteral,\n    OffsetProcedureName,\n    ArrayRowSeparator,\n    ArrayColSeparator,\n    WhiteSpace,\n    allTokens,\n    errorMapping,\n    functionMapping,\n    decimalSeparator: config.decimalSeparator,\n    maxColumns: config.maxColumns,\n    maxRows: config.maxRows\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}