{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { padLeft } from '../../format/format';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nconst MAX_LENGTH = 10;\nconst DECIMAL_NUMBER_OF_BITS = 255;\nconst MIN_BASE = 2;\nconst MAX_BASE = 36;\nconst ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nexport class RadixConversionPlugin extends FunctionPlugin {\n  dec2bin(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DEC2BIN'), (value, places) => decimalToBaseWithExactPadding(value, 2, places));\n  }\n  dec2oct(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DEC2OCT'), (value, places) => decimalToBaseWithExactPadding(value, 8, places));\n  }\n  dec2hex(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DEC2HEX'), (value, places) => decimalToBaseWithExactPadding(value, 16, places));\n  }\n  bin2dec(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BIN2DEC'), binary => {\n      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);\n      if (binaryWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotBinary);\n      }\n      return twoComplementToDecimal(binaryWithSign, 2);\n    });\n  }\n  bin2oct(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BIN2OCT'), (binary, places) => {\n      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);\n      if (binaryWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotBinary);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 8, places);\n    });\n  }\n  bin2hex(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BIN2HEX'), (binary, places) => {\n      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);\n      if (binaryWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotBinary);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 16, places);\n    });\n  }\n  oct2dec(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('OCT2DEC'), octal => {\n      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);\n      if (octalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotOctal);\n      }\n      return twoComplementToDecimal(octalWithSign, 8);\n    });\n  }\n  oct2bin(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('OCT2BIN'), (octal, places) => {\n      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);\n      if (octalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotOctal);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 2, places);\n    });\n  }\n  oct2hex(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('OCT2HEX'), (octal, places) => {\n      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);\n      if (octalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotOctal);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 16, places);\n    });\n  }\n  hex2dec(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HEX2DEC'), hexadecimal => {\n      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);\n      if (hexadecimalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotHex);\n      }\n      return twoComplementToDecimal(hexadecimalWithSign, 16);\n    });\n  }\n  hex2bin(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HEX2BIN'), (hexadecimal, places) => {\n      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);\n      if (hexadecimalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotHex);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 2, places);\n    });\n  }\n  hex2oct(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HEX2OCT'), (hexadecimal, places) => {\n      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);\n      if (hexadecimalWithSign === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotHex);\n      }\n      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 8, places);\n    });\n  }\n  base(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BASE'), decimalToBaseWithMinimumPadding);\n  }\n  decimal(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DECIMAL'), (arg, base) => {\n      const input = coerceStringToBase(arg, base, DECIMAL_NUMBER_OF_BITS);\n      if (input === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NotHex);\n      }\n      return parseInt(input, base);\n    });\n  }\n}\nRadixConversionPlugin.implementedFunctions = {\n  'DEC2BIN': {\n    method: 'dec2bin',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 1,\n      maxValue: 10\n    }]\n  },\n  'DEC2OCT': {\n    method: 'dec2oct',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 1,\n      maxValue: 10\n    }]\n  },\n  'DEC2HEX': {\n    method: 'dec2hex',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 1,\n      maxValue: 10\n    }]\n  },\n  'BIN2DEC': {\n    method: 'bin2dec',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'BIN2OCT': {\n    method: 'bin2oct',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'BIN2HEX': {\n    method: 'bin2hex',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'OCT2DEC': {\n    method: 'oct2dec',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'OCT2BIN': {\n    method: 'oct2bin',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'OCT2HEX': {\n    method: 'oct2hex',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'HEX2DEC': {\n    method: 'hex2dec',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'HEX2BIN': {\n    method: 'hex2bin',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'HEX2OCT': {\n    method: 'hex2oct',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: MAX_LENGTH\n    }]\n  },\n  'DECIMAL': {\n    method: 'decimal',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: MIN_BASE,\n      maxValue: MAX_BASE\n    }]\n  },\n  'BASE': {\n    method: 'base',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: MIN_BASE,\n      maxValue: MAX_BASE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true,\n      minValue: 0,\n      maxValue: DECIMAL_NUMBER_OF_BITS\n    }]\n  }\n};\nfunction coerceStringToBase(value, base, maxLength) {\n  const baseAlphabet = ALPHABET.substr(0, base);\n  const regex = new RegExp(`^[${baseAlphabet}]+$`);\n  if (value.length > maxLength || !regex.test(value)) {\n    return undefined;\n  }\n  return value;\n}\nfunction decimalToBaseWithExactPadding(value, base, places) {\n  if (value > maxValFromBase(base)) {\n    return new CellError(ErrorType.NUM, ErrorMessage.ValueBaseLarge);\n  }\n  if (value < minValFromBase(base)) {\n    return new CellError(ErrorType.NUM, ErrorMessage.ValueBaseSmall);\n  }\n  const result = decimalToRadixComplement(value, base);\n  if (places === undefined || value < 0) {\n    return result;\n  } else if (result.length > places) {\n    return new CellError(ErrorType.NUM, ErrorMessage.ValueBaseLong);\n  } else {\n    return padLeft(result, places);\n  }\n}\nfunction minValFromBase(base) {\n  return -Math.pow(base, MAX_LENGTH) / 2;\n}\nfunction maxValFromBase(base) {\n  return -minValFromBase(base) - 1;\n}\nfunction decimalToBaseWithMinimumPadding(value, base, places) {\n  const result = decimalToRadixComplement(value, base);\n  if (places !== undefined && places > result.length) {\n    return padLeft(result, places);\n  } else {\n    return result;\n  }\n}\nfunction decimalToRadixComplement(value, base) {\n  const offset = value < 0 ? Math.pow(base, MAX_LENGTH) : 0;\n  return (value + offset).toString(base).toUpperCase();\n}\nfunction twoComplementToDecimal(value, base) {\n  const parsed = parseInt(value, base);\n  const offset = Math.pow(base, MAX_LENGTH);\n  return parsed >= offset / 2 ? parsed - offset : parsed;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}