{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { VERSION, BaseRegExpVisitor } from \"regexp-to-ast\";\nimport { forEach, contains, PRINT_ERROR, PRINT_WARNING, find, isArray, every, values } from \"../utils/utils\";\nimport { getRegExpAst } from \"./reg_exp_parser\";\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\";\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexport var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nexport function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n  try {\n    var ast = getRegExpAst(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\"\" + failedOptimizationPrefixMsg + (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n      PRINT_ERROR(failedOptimizationPrefixMsg + \"\\n\" + (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") + (\"\\tUsing the regexp-to-ast library version: \" + VERSION + \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n  return [];\n}\nexport function firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n      break;\n    case \"Alternative\":\n      var terms = ast.value;\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i];\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n        var atom = term;\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n            forEach(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code;\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                    var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        }\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n        if (\n        // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false ||\n        // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n      break;\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\");\n  }\n  // console.log(Object.keys(result).length)\n  return values(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = charCodeToOptimizedIndex(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n    if (lowerChar !== char) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\nfunction findCode(setNode, targetCharCodes) {\n  return find(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return contains(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return find(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\nfunction isWholeOptional(ast) {\n  if (ast.quantifier && ast.quantifier.atLeast === 0) {\n    return true;\n  }\n  if (!ast.value) {\n    return false;\n  }\n  return isArray(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */function (_super) {\n  __extends(CharCodeFinder, _super);\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    }\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n    _super.prototype.visitChildren.call(this, node);\n  };\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if (contains(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n  return CharCodeFinder;\n}(BaseRegExpVisitor);\nexport function canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = getRegExpAst(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return find(pattern, function (char) {\n      return contains(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\n//# sourceMappingURL=reg_exp.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}