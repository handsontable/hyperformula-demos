{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AddressDependency, AstNodeType, CellRangeDependency, ColumnRangeDependency, NamedExpressionDependency, RowRangeDependency } from './';\nconst collectDependenciesFn = (ast, functionRegistry, dependenciesSet, needArgument) => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n      return;\n    case AstNodeType.NAMED_EXPRESSION:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new NamedExpressionDependency(ast.expressionName));\n        }\n        return;\n      }\n    case AstNodeType.CELL_REFERENCE:\n      {\n        if (needArgument) {\n          dependenciesSet.push(new AddressDependency(ast.reference));\n        }\n        return;\n      }\n    case AstNodeType.CELL_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new CellRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.COLUMN_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new ColumnRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.ROW_RANGE:\n      {\n        if (needArgument && ast.start.sheet === ast.end.sheet) {\n          dependenciesSet.push(new RowRangeDependency(ast.start, ast.end));\n        }\n        return;\n      }\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        collectDependenciesFn(ast.value, functionRegistry, dependenciesSet, true);\n        return;\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      collectDependenciesFn(ast.left, functionRegistry, dependenciesSet, true);\n      collectDependenciesFn(ast.right, functionRegistry, dependenciesSet, true);\n      return;\n    case AstNodeType.PARENTHESIS:\n      collectDependenciesFn(ast.expression, functionRegistry, dependenciesSet, needArgument);\n      return;\n    case AstNodeType.FUNCTION_CALL:\n      {\n        const functionNeedArgument = !functionRegistry.doesFunctionNeedArgumentToBeComputed(ast.procedureName);\n        ast.args.forEach(argAst => collectDependenciesFn(argAst, functionRegistry, dependenciesSet, functionNeedArgument));\n        return;\n      }\n  }\n};\nexport const collectDependencies = (ast, functionRegistry) => {\n  const result = new Array();\n  collectDependenciesFn(ast, functionRegistry, result, true);\n  return result;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}