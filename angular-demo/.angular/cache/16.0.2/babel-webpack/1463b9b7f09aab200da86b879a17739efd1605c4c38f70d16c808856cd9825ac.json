{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { EmptyValue, getRawValue, isExtendedNumber, NumberType } from '../InterpreterValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class FinancialPlugin extends FunctionPlugin {\n  pmt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PMT'), pmtCore);\n  }\n  ipmt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IPMT'), ipmtCore);\n  }\n  ppmt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PPMT'), ppmtCore);\n  }\n  fv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FV'), fvCore);\n  }\n  cumipmt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CUMIPMT'), (rate, periods, value, start, end, type) => {\n      if (start > end) {\n        return new CellError(ErrorType.NUM, ErrorMessage.EndStartPeriod);\n      }\n      let acc = 0;\n      for (let i = start; i <= end; i++) {\n        acc += ipmtCore(rate, i, periods, value, 0, type);\n      }\n      return acc;\n    });\n  }\n  cumprinc(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CUMPRINC'), (rate, periods, value, start, end, type) => {\n      if (start > end) {\n        return new CellError(ErrorType.NUM, ErrorMessage.EndStartPeriod);\n      }\n      let acc = 0;\n      for (let i = start; i <= end; i++) {\n        acc += ppmtCore(rate, i, periods, value, 0, type);\n      }\n      return acc;\n    });\n  }\n  db(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DB'), (cost, salvage, life, period, month) => {\n      if (month === 12 && period > life || period > life + 1) {\n        return new CellError(ErrorType.NUM, ErrorMessage.PeriodLong);\n      }\n      if (salvage >= cost) {\n        return 0;\n      }\n      const rate = Math.round((1 - Math.pow(salvage / cost, 1 / life)) * 1000) / 1000;\n      const initial = cost * rate * month / 12;\n      if (period === 1) {\n        return initial;\n      }\n      let total = initial;\n      for (let i = 0; i < period - 2; i++) {\n        total += (cost - total) * rate;\n      }\n      if (period === life + 1) {\n        return (cost - total) * rate * (12 - month) / 12;\n      }\n      return (cost - total) * rate;\n    });\n  }\n  ddb(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DDB'), (cost, salvage, life, period, factor) => {\n      if (period > life) {\n        return new CellError(ErrorType.NUM);\n      }\n      let rate = factor / life;\n      let oldValue;\n      if (rate >= 1) {\n        rate = 1;\n        if (period === 1) {\n          oldValue = cost;\n        } else {\n          oldValue = 0;\n        }\n      } else {\n        oldValue = cost * Math.pow(1 - rate, period - 1);\n      }\n      const newValue = cost * Math.pow(1 - rate, period);\n      return Math.max(oldValue - Math.max(salvage, newValue), 0);\n    });\n  }\n  dollarde(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DOLLARDE'), (dollar, fraction) => {\n      if (fraction < 1) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      fraction = Math.trunc(fraction);\n      while (fraction > 10) {\n        fraction /= 10;\n      }\n      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * 10 / fraction;\n    });\n  }\n  dollarfr(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DOLLARFR'), (dollar, fraction) => {\n      if (fraction < 1) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      fraction = Math.trunc(fraction);\n      while (fraction > 10) {\n        fraction /= 10;\n      }\n      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * fraction / 10;\n    });\n  }\n  effect(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EFFECT'), (rate, periods) => {\n      periods = Math.trunc(periods);\n      return Math.pow(1 + rate / periods, periods) - 1;\n    });\n  }\n  ispmt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISPMT'), (rate, period, periods, value) => {\n      if (periods === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      return value * rate * (period / periods - 1);\n    });\n  }\n  nominal(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NOMINAL'), (rate, periods) => {\n      periods = Math.trunc(periods);\n      return (Math.pow(rate + 1, 1 / periods) - 1) * periods;\n    });\n  }\n  nper(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NPER'), (rate, payment, present, future, type) => {\n      if (rate === 0) {\n        if (payment === 0) {\n          return new CellError(ErrorType.DIV_BY_ZERO);\n        }\n        return (-present - future) / payment;\n      }\n      if (type) {\n        payment *= 1 + rate;\n      }\n      return Math.log((payment - future * rate) / (present * rate + payment)) / Math.log(1 + rate);\n    });\n  }\n  rate(ast, state) {\n    // Newton's method: https://en.wikipedia.org/wiki/Newton%27s_method\n    return this.runFunction(ast.args, state, this.metadata('RATE'), (periods, payment, present, future, type, guess) => {\n      if (guess <= -1) {\n        return new CellError(ErrorType.VALUE);\n      }\n      const epsMax = 1e-7;\n      const iterMax = 50;\n      let rate = guess;\n      type = type ? 1 : 0;\n      for (let i = 0; i < iterMax; i++) {\n        if (rate <= -1) {\n          return new CellError(ErrorType.NUM);\n        }\n        let y;\n        if (Math.abs(rate) < epsMax) {\n          y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;\n        } else {\n          const f = Math.pow(1 + rate, periods);\n          y = present * f + payment * (1 / rate + type) * (f - 1) + future;\n        }\n        if (Math.abs(y) < epsMax) {\n          return rate;\n        }\n        let dy;\n        if (Math.abs(rate) < epsMax) {\n          dy = present * periods + payment * type * periods;\n        } else {\n          const f = Math.pow(1 + rate, periods);\n          const df = periods * Math.pow(1 + rate, periods - 1);\n          dy = present * df + payment * (1 / rate + type) * df + payment * (-1 / (rate * rate)) * (f - 1);\n        }\n        rate -= y / dy;\n      }\n      return new CellError(ErrorType.NUM);\n    });\n  }\n  pv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PV'), (rate, periods, payment, future, type) => {\n      type = type ? 1 : 0;\n      if (rate === -1) {\n        if (periods === 0) {\n          return new CellError(ErrorType.NUM);\n        } else {\n          return new CellError(ErrorType.DIV_BY_ZERO);\n        }\n      }\n      if (rate === 0) {\n        return -payment * periods - future;\n      } else {\n        return ((1 - Math.pow(1 + rate, periods)) * payment * (1 + rate * type) / rate - future) / Math.pow(1 + rate, periods);\n      }\n    });\n  }\n  rri(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('RRI'), (periods, present, future) => {\n      if (present === 0 || future < 0 && present > 0 || future > 0 && present < 0) {\n        return new CellError(ErrorType.NUM);\n      }\n      return Math.pow(future / present, 1 / periods) - 1;\n    });\n  }\n  sln(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SLN'), (cost, salvage, life) => {\n      if (life === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      return (cost - salvage) / life;\n    });\n  }\n  syd(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SYD'), (cost, salvage, life, period) => {\n      if (period > life) {\n        return new CellError(ErrorType.NUM);\n      }\n      return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));\n    });\n  }\n  tbilleq(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TBILLEQ'), (settlement, maturity, discount) => {\n      settlement = Math.round(settlement);\n      maturity = Math.round(maturity);\n      if (settlement >= maturity) {\n        return new CellError(ErrorType.NUM);\n      }\n      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);\n      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);\n      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {\n        return new CellError(ErrorType.NUM);\n      }\n      const denom = 360 - discount * (maturity - settlement);\n      if (denom === 0) {\n        return 0;\n      }\n      if (denom < 0) {\n        return new CellError(ErrorType.NUM);\n      }\n      return 365 * discount / denom;\n    });\n  }\n  tbillprice(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TBILLPRICE'), (settlement, maturity, discount) => {\n      settlement = Math.round(settlement);\n      maturity = Math.round(maturity);\n      if (settlement >= maturity) {\n        return new CellError(ErrorType.NUM);\n      }\n      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);\n      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);\n      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {\n        return new CellError(ErrorType.NUM);\n      }\n      const denom = 360 - discount * (maturity - settlement);\n      if (denom === 0) {\n        return 0;\n      }\n      if (denom < 0) {\n        return new CellError(ErrorType.NUM);\n      }\n      return 100 * (1 - discount * (maturity - settlement) / 360);\n    });\n  }\n  tbillyield(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TBILLYIELD'), (settlement, maturity, price) => {\n      settlement = Math.round(settlement);\n      maturity = Math.round(maturity);\n      if (settlement >= maturity) {\n        return new CellError(ErrorType.NUM);\n      }\n      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);\n      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);\n      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {\n        return new CellError(ErrorType.NUM);\n      }\n      return (100 - price) * 360 / (price * (maturity - settlement));\n    });\n  }\n  fvschedule(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FVSCHEDULE'), (value, ratios) => {\n      const vals = ratios.valuesFromTopLeftCorner();\n      for (const val of vals) {\n        if (val instanceof CellError) {\n          return val;\n        }\n      }\n      for (const val of vals) {\n        if (isExtendedNumber(val)) {\n          value *= 1 + getRawValue(val);\n        } else if (val !== EmptyValue) {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      return value;\n    });\n  }\n  npv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NPV'), (rate, ...args) => {\n      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);\n      if (coerced instanceof CellError) {\n        return coerced;\n      }\n      return npvCore(rate, coerced);\n    });\n  }\n  mirr(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MIRR'), (range, frate, rrate) => {\n      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());\n      if (vals instanceof CellError) {\n        return vals;\n      }\n      let posFlag = false;\n      let negFlag = false;\n      const posValues = [];\n      const negValues = [];\n      for (const val of vals) {\n        if (val > 0) {\n          posFlag = true;\n          posValues.push(val);\n          negValues.push(0);\n        } else if (val < 0) {\n          negFlag = true;\n          negValues.push(val);\n          posValues.push(0);\n        } else {\n          negValues.push(0);\n          posValues.push(0);\n        }\n      }\n      if (!posFlag || !negFlag) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      const n = vals.length;\n      const nom = npvCore(rrate, posValues);\n      if (nom instanceof CellError) {\n        return nom;\n      }\n      const denom = npvCore(frate, negValues);\n      if (denom instanceof CellError) {\n        return denom;\n      }\n      return Math.pow(-nom * Math.pow(1 + rrate, n) / denom / (1 + frate), 1 / (n - 1)) - 1;\n    });\n  }\n  pduration(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PDURATION'), (rate, pv, fv) => (Math.log(fv) - Math.log(pv)) / Math.log(1 + rate));\n  }\n  xnpv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('XNPV'), (rate, values, dates) => {\n      const valArr = values.valuesFromTopLeftCorner();\n      for (const val of valArr) {\n        if (typeof val !== 'number') {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      const valArrNum = valArr;\n      const dateArr = dates.valuesFromTopLeftCorner();\n      for (const date of dateArr) {\n        if (typeof date !== 'number') {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      const dateArrNum = dateArr;\n      if (dateArrNum.length !== valArrNum.length) {\n        return new CellError(ErrorType.NUM, ErrorMessage.EqualLength);\n      }\n      const n = dateArrNum.length;\n      let ret = 0;\n      if (dateArrNum[0] < 0) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n      }\n      for (let i = 0; i < n; i++) {\n        dateArrNum[i] = Math.floor(dateArrNum[i]);\n        if (dateArrNum[i] < dateArrNum[0]) {\n          return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n        }\n        ret += valArrNum[i] / Math.pow(1 + rate, (dateArrNum[i] - dateArrNum[0]) / 365);\n      }\n      return ret;\n    });\n  }\n}\nFinancialPlugin.implementedFunctions = {\n  'PMT': {\n    method: 'pmt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'IPMT': {\n    method: 'ipmt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'PPMT': {\n    method: 'ppmt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'FV': {\n    method: 'fv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'CUMIPMT': {\n    method: 'cumipmt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 0,\n      maxValue: 1\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'CUMPRINC': {\n    method: 'cumprinc',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 0,\n      maxValue: 1\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'DB': {\n    method: 'db',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1,\n      maxValue: 12,\n      defaultValue: 12\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'DDB': {\n    method: 'ddb',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      defaultValue: 2\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'DOLLARDE': {\n    method: 'dollarde',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'DOLLARFR': {\n    method: 'dollarfr',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'EFFECT': {\n    method: 'effect',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'ISPMT': {\n    method: 'ispmt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'NOMINAL': {\n    method: 'nominal',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'NPER': {\n    method: 'nper',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }]\n  },\n  'PV': {\n    method: 'pv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'RATE': {\n    method: 'rate',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0.1\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'RRI': {\n    method: 'rri',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'SLN': {\n    method: 'sln',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'SYD': {\n    method: 'syd',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'TBILLEQ': {\n    method: 'tbilleq',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'TBILLPRICE': {\n    method: 'tbillprice',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'TBILLYIELD': {\n    method: 'tbillyield',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'FVSCHEDULE': {\n    method: 'fvschedule',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'NPV': {\n    method: 'npv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1,\n    returnNumberType: NumberType.NUMBER_CURRENCY\n  },\n  'MIRR': {\n    method: 'mirr',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_PERCENT\n  },\n  'PDURATION': {\n    method: 'pduration',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  },\n  'XNPV': {\n    method: 'xnpv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: -1\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }]\n  }\n};\nfunction pmtCore(rate, periods, present, future, type) {\n  if (rate === 0) {\n    return (-present - future) / periods;\n  } else {\n    const term = Math.pow(1 + rate, periods);\n    return (future * rate + present * rate * term) * (type ? 1 / (1 + rate) : 1) / (1 - term);\n  }\n}\nfunction ipmtCore(rate, period, periods, present, future, type) {\n  const payment = pmtCore(rate, periods, present, future, type);\n  if (period === 1) {\n    return rate * (type ? 0 : -present);\n  } else {\n    return rate * (type ? fvCore(rate, period - 2, payment, present, type) - payment : fvCore(rate, period - 1, payment, present, type));\n  }\n}\nfunction fvCore(rate, periods, payment, value, type) {\n  if (rate === 0) {\n    return -value - payment * periods;\n  } else {\n    const term = Math.pow(1 + rate, periods);\n    return payment * (type ? 1 + rate : 1) * (1 - term) / rate - value * term;\n  }\n}\nfunction ppmtCore(rate, period, periods, present, future, type) {\n  return pmtCore(rate, periods, present, future, type) - ipmtCore(rate, period, periods, present, future, type);\n}\nfunction npvCore(rate, args) {\n  let acc = 0;\n  for (let i = args.length - 1; i >= 0; i--) {\n    acc += args[i];\n    if (rate === -1) {\n      if (acc === 0) {\n        continue;\n      } else {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n    }\n    acc /= 1 + rate;\n  }\n  return acc;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}