{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { split } from '../generatorUtils';\nimport { getRawValue } from './InterpreterValue';\nconst findSmallerRangeForMany = (dependencyGraph, conditionRanges, valuesRange) => {\n  if (valuesRange.end.row > valuesRange.start.row) {\n    const valuesRangeEndRowLess = simpleCellAddress(valuesRange.end.sheet, valuesRange.end.col, valuesRange.end.row - 1);\n    const rowLessVertex = dependencyGraph.getRange(valuesRange.start, valuesRangeEndRowLess);\n    if (rowLessVertex !== undefined) {\n      return {\n        smallerRangeVertex: rowLessVertex,\n        restValuesRange: valuesRange.withStart(simpleCellAddress(valuesRange.start.sheet, valuesRange.start.col, valuesRange.end.row)),\n        restConditionRanges: conditionRanges.map(conditionRange => conditionRange.withStart(simpleCellAddress(conditionRange.start.sheet, conditionRange.start.col, conditionRange.end.row)))\n      };\n    }\n  }\n  return {\n    restValuesRange: valuesRange,\n    restConditionRanges: conditionRanges\n  };\n};\nexport class CriterionFunctionCompute {\n  constructor(interpreter, cacheKey, reduceInitialValue, composeFunction, mapFunction) {\n    this.interpreter = interpreter;\n    this.cacheKey = cacheKey;\n    this.reduceInitialValue = reduceInitialValue;\n    this.composeFunction = composeFunction;\n    this.mapFunction = mapFunction;\n    this.dependencyGraph = this.interpreter.dependencyGraph;\n  }\n  compute(simpleValuesRange, conditions) {\n    for (const condition of conditions) {\n      if (!condition.conditionRange.sameDimensionsAs(simpleValuesRange)) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.EqualLength);\n      }\n    }\n    const valuesRangeVertex = this.tryToGetRangeVertexForRangeValue(simpleValuesRange);\n    const conditionsVertices = conditions.map(c => this.tryToGetRangeVertexForRangeValue(c.conditionRange));\n    if (valuesRangeVertex && conditionsVertices.every(e => e !== undefined)) {\n      const fullCriterionString = conditions.map(c => c.criterionPackage.raw).join(',');\n      const cachedResult = this.findAlreadyComputedValueInCache(valuesRangeVertex, this.cacheKey(conditions), fullCriterionString);\n      if (cachedResult !== undefined) {\n        this.interpreter.stats.incrementCriterionFunctionFullCacheUsed();\n        return cachedResult;\n      }\n      const cache = this.buildNewCriterionCache(this.cacheKey(conditions), conditions.map(c => c.conditionRange.range), simpleValuesRange.range);\n      if (!cache.has(fullCriterionString)) {\n        cache.set(fullCriterionString, [this.evaluateRangeValue(simpleValuesRange, conditions), conditions.map(condition => condition.criterionPackage.lambda)]);\n      }\n      valuesRangeVertex.setCriterionFunctionValues(this.cacheKey(conditions), cache);\n      conditionsVertices.forEach(range => {\n        if (range !== undefined) {\n          range.addDependentCacheRange(valuesRangeVertex);\n        }\n      });\n      return cache.get(fullCriterionString)[0];\n    } else {\n      return this.evaluateRangeValue(simpleValuesRange, conditions);\n    }\n  }\n  tryToGetRangeVertexForRangeValue(rangeValue) {\n    const maybeRange = rangeValue.range;\n    if (maybeRange === undefined) {\n      return undefined;\n    } else {\n      return this.dependencyGraph.getRange(maybeRange.start, maybeRange.end);\n    }\n  }\n  reduceFunction(iterable) {\n    let acc = this.reduceInitialValue;\n    for (const val of iterable) {\n      acc = this.composeFunction(acc, val);\n    }\n    return acc;\n  }\n  findAlreadyComputedValueInCache(rangeVertex, cacheKey, criterionString) {\n    return rangeVertex.getCriterionFunctionValue(cacheKey, criterionString);\n  }\n  evaluateRangeValue(simpleValuesRange, conditions) {\n    const criterionLambdas = conditions.map(condition => condition.criterionPackage.lambda);\n    const values = Array.from(simpleValuesRange.valuesFromTopLeftCorner()).map(this.mapFunction)[Symbol.iterator]();\n    const conditionsIterators = conditions.map(condition => condition.conditionRange.iterateValuesFromTopLeftCorner());\n    const filteredValues = ifFilter(criterionLambdas, conditionsIterators, values);\n    return this.reduceFunction(filteredValues);\n  }\n  buildNewCriterionCache(cacheKey, simpleConditionRanges, simpleValuesRange) {\n    const currentRangeVertex = this.dependencyGraph.getRange(simpleValuesRange.start, simpleValuesRange.end);\n    const {\n      smallerRangeVertex,\n      restConditionRanges,\n      restValuesRange\n    } = findSmallerRangeForMany(this.dependencyGraph, simpleConditionRanges, simpleValuesRange);\n    let smallerCache;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {\n      smallerCache = smallerRangeVertex.getCriterionFunctionValues(cacheKey);\n    } else {\n      smallerCache = new Map();\n    }\n    const newCache = new Map();\n    smallerCache.forEach(([value, criterionLambdas], key) => {\n      const filteredValues = ifFilter(criterionLambdas, restConditionRanges.map(rcr => getRangeValues(this.dependencyGraph, rcr)), Array.from(getRangeValues(this.dependencyGraph, restValuesRange)).map(this.mapFunction)[Symbol.iterator]());\n      const newCacheValue = this.composeFunction(value, this.reduceFunction(filteredValues));\n      this.interpreter.stats.incrementCriterionFunctionPartialCacheUsed();\n      newCache.set(key, [newCacheValue, criterionLambdas]);\n    });\n    return newCache;\n  }\n}\nexport class Condition {\n  constructor(conditionRange, criterionPackage) {\n    this.conditionRange = conditionRange;\n    this.criterionPackage = criterionPackage;\n  }\n}\nfunction* getRangeValues(dependencyGraph, cellRange) {\n  for (const cellFromRange of cellRange.addresses(dependencyGraph)) {\n    yield getRawValue(dependencyGraph.getScalarValue(cellFromRange));\n  }\n}\nfunction* ifFilter(criterionLambdas, conditionalIterables, computableIterable) {\n  for (const computable of computableIterable) {\n    const conditionalSplits = conditionalIterables.map(conditionalIterable => split(conditionalIterable));\n    if (!conditionalSplits.every(cs => Object.prototype.hasOwnProperty.call(cs, 'value'))) {\n      return;\n    }\n    const conditionalFirsts = conditionalSplits.map(cs => getRawValue(cs.value));\n    if (zip(conditionalFirsts, criterionLambdas).every(([conditionalFirst, criterionLambda]) => criterionLambda(conditionalFirst))) {\n      yield computable;\n    }\n    conditionalIterables = conditionalSplits.map(cs => cs.rest);\n  }\n}\nfunction zip(arr1, arr2) {\n  const result = [];\n  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {\n    result.push([arr1[i], arr2[i]]);\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}