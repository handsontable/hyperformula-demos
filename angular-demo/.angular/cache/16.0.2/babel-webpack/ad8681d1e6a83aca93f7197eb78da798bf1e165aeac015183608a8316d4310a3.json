{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleColumnAddress, simpleColumnAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nexport var ReferenceType = /*#__PURE__*/(() => {\n  ReferenceType = ReferenceType || {};\n  ReferenceType[\"RELATIVE\"] = \"RELATIVE\";\n  ReferenceType[\"ABSOLUTE\"] = \"ABSOLUTE\";\n  return ReferenceType;\n})();\nexport class ColumnAddress {\n  constructor(type, col, sheet) {\n    this.type = type;\n    this.col = col;\n    this.sheet = sheet;\n  }\n  static absolute(column, sheet) {\n    return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);\n  }\n  static relative(column, sheet) {\n    return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);\n  }\n  static compareByAbsoluteAddress(baseAddress) {\n    return (colA, colB) => colA.toSimpleColumnAddress(baseAddress).col - colB.toSimpleColumnAddress(baseAddress).col;\n  }\n  isColumnAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE;\n  }\n  isColumnRelative() {\n    return this.type === ReferenceType.RELATIVE;\n  }\n  isAbsolute() {\n    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;\n  }\n  moved(toSheet, toRight, _toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new ColumnAddress(this.type, this.col + toRight, newSheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column = baseAddress.col + this.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  shiftRelativeDimensions(toRight, _toBottom) {\n    const col = this.isColumnRelative() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, _toBottom) {\n    const col = this.isColumnAbsolute() ? this.col + toRight : this.col;\n    return new ColumnAddress(this.type, col, this.sheet);\n  }\n  withSheet(sheet) {\n    return new ColumnAddress(this.type, this.col, sheet);\n  }\n  isInvalid(baseAddress) {\n    return this.toSimpleColumnAddress(baseAddress).col < 0;\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case ReferenceType.RELATIVE:\n        {\n          return `${sheetPart}#COLR${this.col}`;\n        }\n      case ReferenceType.ABSOLUTE:\n        {\n          return `${sheetPart}#COLA${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleColumnAddress(baseAddress);\n    if (invalidSimpleColumnAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';\n    return `${dollar}${column}`;\n  }\n  exceedsSheetSizeLimits(maxColumns) {\n    return this.col >= maxColumns;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}