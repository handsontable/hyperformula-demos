{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from '../../ArraySize';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { coerceScalarToBoolean } from '../ArithmeticHelper';\nimport { InterpreterState } from '../InterpreterState';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class ArrayPlugin extends FunctionPlugin {\n  arrayformula(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ARRAYFORMULA'), value => value);\n  }\n  arrayformulaArraySize(ast, state) {\n    if (ast.args.length !== 1) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('ARRAYFORMULA');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    return subChecks[0];\n  }\n  arrayconstrain(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ARRAY_CONSTRAIN'), (range, numRows, numCols) => {\n      numRows = Math.min(numRows, range.height());\n      numCols = Math.min(numCols, range.width());\n      const data = range.data;\n      const ret = [];\n      for (let i = 0; i < numRows; i++) {\n        ret.push(data[i].slice(0, numCols));\n      }\n      return SimpleRangeValue.onlyValues(ret);\n    });\n  }\n  arrayconstrainArraySize(ast, state) {\n    if (ast.args.length !== 3) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('ARRAY_CONSTRAIN');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    let {\n      height,\n      width\n    } = subChecks[0];\n    if (ast.args[1].type === AstNodeType.NUMBER) {\n      height = Math.min(height, ast.args[1].value);\n    }\n    if (ast.args[2].type === AstNodeType.NUMBER) {\n      width = Math.min(width, ast.args[2].value);\n    }\n    if (height < 1 || width < 1 || !Number.isInteger(height) || !Number.isInteger(width)) {\n      return ArraySize.error();\n    }\n    return new ArraySize(width, height);\n  }\n  filter(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FILTER'), (rangeVals, ...rangeFilters) => {\n      for (const filter of rangeFilters) {\n        if (rangeVals.width() !== filter.width() || rangeVals.height() !== filter.height()) {\n          return new CellError(ErrorType.NA, ErrorMessage.EqualLength);\n        }\n      }\n      if (rangeVals.width() > 1 && rangeVals.height() > 1) {\n        return new CellError(ErrorType.NA, ErrorMessage.WrongDimension);\n      }\n      const vals = rangeVals.data;\n      const ret = [];\n      for (let i = 0; i < rangeVals.height(); i++) {\n        const row = [];\n        for (let j = 0; j < rangeVals.width(); j++) {\n          let ok = true;\n          for (const filter of rangeFilters) {\n            const val = coerceScalarToBoolean(filter.data[i][j]);\n            if (val !== true) {\n              ok = false;\n              break;\n            }\n          }\n          if (ok) {\n            row.push(vals[i][j]);\n          }\n        }\n        if (row.length > 0) {\n          ret.push(row);\n        }\n      }\n      if (ret.length > 0) {\n        return SimpleRangeValue.onlyValues(ret);\n      } else {\n        return new CellError(ErrorType.NA, ErrorMessage.EmptyRange);\n      }\n    });\n  }\n  filterArraySize(ast, state) {\n    if (ast.args.length <= 1) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('FILTER');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const width = Math.max(...subChecks.map(val => val.width));\n    const height = Math.max(...subChecks.map(val => val.height));\n    return new ArraySize(width, height);\n  }\n}\nArrayPlugin.implementedFunctions = {\n  'ARRAYFORMULA': {\n    method: 'arrayformula',\n    arraySizeMethod: 'arrayformulaArraySize',\n    arrayFunction: true,\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }]\n  },\n  'ARRAY_CONSTRAIN': {\n    method: 'arrayconstrain',\n    arraySizeMethod: 'arrayconstrainArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }],\n    vectorizationForbidden: true\n  },\n  'FILTER': {\n    method: 'filter',\n    arraySizeMethod: 'filterArraySize',\n    arrayFunction: true,\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    repeatLastArgs: 1\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}