{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from '../Cell';\nimport { Transformer } from './Transformer';\nexport class AddRowsTransformer extends Transformer {\n  constructor(rowsSpan) {\n    super();\n    this.rowsSpan = rowsSpan;\n  }\n  get sheet() {\n    return this.rowsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformColumnRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {\n      if (this.rowsSpan.rowStart <= absolutizedDependencyAddress.row) {\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.rowsSpan.sheet && absoluteDependencySheet !== this.rowsSpan.sheet) {\n      if (dependencyAddress.isRowAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.row < this.rowsSpan.rowStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n    }\n    // Case 1\n    if (dependencyAddress.isRowAbsolute()) {\n      if (dependencyAddress.row < this.rowsSpan.rowStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n      }\n    } else {\n      if (absolutizedDependencyAddress.row < this.rowsSpan.rowStart) {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);\n        }\n      } else {\n        if (formulaAddress.row < this.rowsSpan.rowStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {\n      return Object.assign(Object.assign({}, address), {\n        row: address.row + this.rowsSpan.numberOfRows\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}