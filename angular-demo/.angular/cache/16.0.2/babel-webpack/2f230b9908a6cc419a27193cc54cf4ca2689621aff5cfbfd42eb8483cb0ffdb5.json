{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\n/*\r\n * A class representing a set of rows in specific sheet\r\n */\nexport class RowsSpan {\n  constructor(sheet, rowStart, rowEnd) {\n    this.sheet = sheet;\n    this.rowStart = rowStart;\n    this.rowEnd = rowEnd;\n    if (rowStart < 0) {\n      throw Error('Starting row cant be less than 0');\n    }\n    if (rowEnd < rowStart) {\n      throw Error('Row span cant end before start');\n    }\n  }\n  get numberOfRows() {\n    return this.rowEnd - this.rowStart + 1;\n  }\n  get start() {\n    return this.rowStart;\n  }\n  get end() {\n    return this.rowEnd;\n  }\n  static fromNumberOfRows(sheet, rowStart, numberOfRows) {\n    return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);\n  }\n  static fromRowStartAndEnd(sheet, rowStart, rowEnd) {\n    return new RowsSpan(sheet, rowStart, rowEnd);\n  }\n  *rows() {\n    for (let col = this.rowStart; col <= this.rowEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.rowStart, otherSpan.rowStart);\n    const end = Math.min(this.rowEnd, otherSpan.rowEnd);\n    if (start > end) {\n      return null;\n    }\n    return new RowsSpan(this.sheet, start, end);\n  }\n  firstRow() {\n    return new RowsSpan(this.sheet, this.rowStart, this.rowStart);\n  }\n}\n/*\r\n * A class representing a set of columns in specific sheet\r\n */\nexport class ColumnsSpan {\n  constructor(sheet, columnStart, columnEnd) {\n    this.sheet = sheet;\n    this.columnStart = columnStart;\n    this.columnEnd = columnEnd;\n    if (columnStart < 0) {\n      throw Error('Starting column cant be less than 0');\n    }\n    if (columnEnd < columnStart) {\n      throw Error('Column span cant end before start');\n    }\n  }\n  get numberOfColumns() {\n    return this.columnEnd - this.columnStart + 1;\n  }\n  get start() {\n    return this.columnStart;\n  }\n  get end() {\n    return this.columnEnd;\n  }\n  static fromNumberOfColumns(sheet, columnStart, numberOfColumns) {\n    return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);\n  }\n  static fromColumnStartAndEnd(sheet, columnStart, columnEnd) {\n    return new ColumnsSpan(sheet, columnStart, columnEnd);\n  }\n  *columns() {\n    for (let col = this.columnStart; col <= this.columnEnd; ++col) {\n      yield col;\n    }\n  }\n  intersect(otherSpan) {\n    if (this.sheet !== otherSpan.sheet) {\n      throw Error('Can\\'t intersect spans from different sheets');\n    }\n    const start = Math.max(this.columnStart, otherSpan.columnStart);\n    const end = Math.min(this.columnEnd, otherSpan.columnEnd);\n    if (start > end) {\n      return null;\n    }\n    return new ColumnsSpan(this.sheet, start, end);\n  }\n  firstColumn() {\n    return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}