{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from '../Cell';\nimport { Transformer } from './Transformer';\nexport class RemoveColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      return false;\n    }\n    // Case 3 -- removed column in same sheet where dependency is but formula in different\n    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n        // 3.ARa\n        return false;\n      } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n        // 3.ARb\n        return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n      }\n    }\n    // Case 2 -- removed column in same sheet where formula but dependency in different sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        // 2.A\n        return false;\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // 2.Ra\n          return false;\n        } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n          // 2.Rb\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        }\n      }\n    }\n    // Case 1 -- same sheet\n    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        if (dependencyAddress.col < this.columnsSpan.columnStart) {\n          // 1.Aa\n          return false;\n        } else if (dependencyAddress.col > this.columnsSpan.columnEnd) {\n          // 1.Ab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n        if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Raa\n            return false;\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rab\n            return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n          }\n        } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {\n          if (formulaAddress.col < this.columnsSpan.columnStart) {\n            // 1.Rba\n            return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {\n            // 1.Rbb\n            return false;\n          }\n        }\n      }\n    }\n    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb\n    return ErrorType.REF;\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col - this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const startSheet = absoluteSheetReference(start, formulaAddress);\n    let actualStart = start;\n    let actualEnd = end;\n    if (this.columnsSpan.sheet === startSheet) {\n      const startSCA = start.toSimpleColumnAddress(formulaAddress);\n      const endSCA = end.toSimpleColumnAddress(formulaAddress);\n      if (this.columnsSpan.columnStart <= startSCA.col && this.columnsSpan.columnEnd >= endSCA.col) {\n        return ErrorType.REF;\n      }\n      if (startSCA.col >= this.columnsSpan.columnStart && startSCA.col <= this.columnsSpan.columnEnd) {\n        actualStart = start.shiftedByColumns(this.columnsSpan.columnEnd - startSCA.col + 1);\n      }\n      if (endSCA.col >= this.columnsSpan.columnStart && endSCA.col <= this.columnsSpan.columnEnd) {\n        actualEnd = end.shiftedByColumns(-(endSCA.col - this.columnsSpan.columnStart + 1));\n      }\n    }\n    const newStart = this.transformCellAddress(actualStart, formulaAddress);\n    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);\n    if (newStart === false && newEnd === false) {\n      return [actualStart, actualEnd];\n    } else if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      throw Error('Cannot happen');\n    } else {\n      return [newStart || actualStart, newEnd || actualEnd];\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}