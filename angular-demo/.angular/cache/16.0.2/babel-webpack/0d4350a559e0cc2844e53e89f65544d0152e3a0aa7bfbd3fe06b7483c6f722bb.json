{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { instanceOfSimpleDate, instanceOfSimpleTime, numberToSimpleTime, offsetMonth, roundToNearestSecond, timeToNumber, toBasisEU, truncateDayInMonth } from '../../DateTimeHelper';\nimport { ErrorMessage } from '../../error-message';\nimport { format } from '../../format/format';\nimport { EmptyValue, getRawValue, isExtendedNumber, NumberType } from '../InterpreterValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\n/**\r\n * Interpreter plugin containing date-specific functions\r\n */\nexport class DateTimePlugin extends FunctionPlugin {\n  constructor() {\n    super(...arguments);\n    this.isoweeknumCore = day => {\n      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));\n      const date = this.dateTimeHelper.numberToSimpleDate(day);\n      const yearStart = this.dateTimeHelper.dateToNumber({\n        year: date.year,\n        month: 1,\n        day: 1\n      });\n      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);\n      const firstThursdayAbs = yearStartAbsolute + ((4 - yearStartAbsolute) % 7 + 7) % 7;\n      const ret = Math.floor((absoluteDay - 1) / 7) - Math.floor((firstThursdayAbs - 1) / 7) + 1;\n      if (ret === 0) {\n        return this.isoweeknumCore(day - 7) + 1;\n      }\n      return ret;\n    };\n    this.days360Core = (startDate, endDate, mode) => {\n      const start = this.dateTimeHelper.numberToSimpleDate(startDate);\n      const end = this.dateTimeHelper.numberToSimpleDate(endDate);\n      let nStart, nEnd;\n      if (mode) {\n        nStart = toBasisEU(start);\n        nEnd = toBasisEU(end);\n      } else {\n        [nStart, nEnd] = this.dateTimeHelper.toBasisUS(start, end);\n      }\n      return 360 * (nEnd.year - nStart.year) + 30 * (nEnd.month - nStart.month) + nEnd.day - nStart.day;\n    };\n  }\n  /**\r\n   * Corresponds to DATE(year, month, day)\r\n   *\r\n   * Converts a provided year, month and day into date\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  date(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DATE'), (year, month, day) => {\n      const d = Math.trunc(day);\n      let m = Math.trunc(month);\n      let y = Math.trunc(year);\n      if (y < this.dateTimeHelper.getEpochYearZero()) {\n        y += this.dateTimeHelper.getEpochYearZero();\n      }\n      const delta = Math.floor((m - 1) / 12);\n      y += delta;\n      m -= delta * 12;\n      const date = {\n        year: y,\n        month: m,\n        day: 1\n      };\n      if (this.dateTimeHelper.isValidDate(date)) {\n        let ret = this.dateTimeHelper.dateToNumber(date) + (d - 1);\n        ret = this.dateTimeHelper.getWithinBounds(ret);\n        if (ret === undefined) {\n          return new CellError(ErrorType.NUM, ErrorMessage.DateBounds);\n        }\n        return ret;\n      }\n      return new CellError(ErrorType.VALUE, ErrorMessage.InvalidDate);\n    });\n  }\n  time(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TIME'), (h, m, s) => {\n      const ret = timeToNumber({\n        hours: Math.trunc(h),\n        minutes: Math.trunc(m),\n        seconds: Math.trunc(s)\n      });\n      if (ret < 0) {\n        return new CellError(ErrorType.NUM, ErrorMessage.NegativeTime);\n      }\n      return ret % 1;\n    });\n  }\n  /**\r\n   * Implementation for the EOMONTH function\r\n   */\n  eomonth(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EOMONTH'), (dateNumber, numberOfMonthsToShift) => {\n      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);\n      let ret = this.dateTimeHelper.dateToNumber(this.dateTimeHelper.endOfMonth(offsetMonth(date, numberOfMonthsToShift)));\n      ret = this.dateTimeHelper.getWithinBounds(ret);\n      if (ret === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.DateBounds);\n      }\n      return ret;\n    });\n  }\n  day(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DAY'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).day);\n  }\n  days(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DAYS'), (endDate, startDate) => Math.trunc(endDate) - Math.trunc(startDate));\n  }\n  /**\r\n   * Corresponds to MONTH(date)\r\n   *\r\n   * Returns the month of the year specified by a given date\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  month(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MONTH'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).month);\n  }\n  /**\r\n   * Corresponds to YEAR(date)\r\n   *\r\n   * Returns the year specified by a given date\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  year(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('YEAR'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).year);\n  }\n  hour(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HOUR'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).hours);\n  }\n  minute(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MINUTE'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).minutes);\n  }\n  second(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SECOND'), timeNumber => numberToSimpleTime(roundToNearestSecond(timeNumber) % 1).seconds);\n  }\n  /**\r\n   * Corresponds to TEXT(number, format)\r\n   *\r\n   * Tries to convert number to specified date format.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  text(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TEXT'), (numberRepresentation, formatArg) => format(numberRepresentation, formatArg, this.config, this.dateTimeHelper));\n  }\n  weekday(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('WEEKDAY'), (day, type) => {\n      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));\n      if (type === 3) {\n        return (absoluteDay - 1) % 7;\n      }\n      const offset = weekdayOffsets.get(type);\n      if (offset === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.BadMode);\n      }\n      return (absoluteDay - offset) % 7 + 1;\n    });\n  }\n  weeknum(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('WEEKNUM'), (day, type) => {\n      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));\n      const date = this.dateTimeHelper.numberToSimpleDate(day);\n      const yearStart = this.dateTimeHelper.dateToNumber({\n        year: date.year,\n        month: 1,\n        day: 1\n      });\n      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);\n      if (type === 21) {\n        return this.isoweeknumCore(day);\n      }\n      const offset = weekdayOffsets.get(type);\n      if (offset === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.BadMode);\n      }\n      return Math.floor((absoluteDay - offset) / 7) - Math.floor((yearStartAbsolute - offset) / 7) + 1;\n    });\n  }\n  isoweeknum(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISOWEEKNUM'), this.isoweeknumCore);\n  }\n  datevalue(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DATEVALUE'), date => {\n      const {\n        dateTime\n      } = this.dateTimeHelper.parseDateTimeFromConfigFormats(date);\n      if (dateTime === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.IncorrectDateTime);\n      }\n      if (!instanceOfSimpleDate(dateTime)) {\n        return 0;\n      }\n      return (instanceOfSimpleTime(dateTime) ? Math.trunc(timeToNumber(dateTime)) : 0) + this.dateTimeHelper.dateToNumber(dateTime);\n    });\n  }\n  timevalue(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TIMEVALUE'), date => {\n      const dateNumber = this.dateTimeHelper.dateStringToDateNumber(date);\n      if (dateNumber === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.IncorrectDateTime);\n      }\n      return getRawValue(dateNumber) % 1;\n    });\n  }\n  now(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NOW'), () => {\n      const now = new Date(Date.now());\n      return timeToNumber({\n        hours: now.getHours(),\n        minutes: now.getMinutes(),\n        seconds: now.getSeconds()\n      }) + this.dateTimeHelper.dateToNumber({\n        year: now.getFullYear(),\n        month: now.getMonth() + 1,\n        day: now.getDate()\n      });\n    });\n  }\n  today(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TODAY'), () => {\n      const now = new Date(Date.now());\n      return this.dateTimeHelper.dateToNumber({\n        year: now.getFullYear(),\n        month: now.getMonth() + 1,\n        day: now.getDate()\n      });\n    });\n  }\n  edate(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EDATE'), (dateNumber, delta) => {\n      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);\n      const newDate = truncateDayInMonth(offsetMonth(date, delta));\n      let ret = this.dateTimeHelper.dateToNumber(newDate);\n      ret = this.dateTimeHelper.getWithinBounds(ret);\n      if (ret === undefined) {\n        return new CellError(ErrorType.NUM, ErrorMessage.DateBounds);\n      }\n      return ret;\n    });\n  }\n  datedif(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DATEDIF'), (startDate, endDate, unit) => {\n      if (startDate > endDate) {\n        return new CellError(ErrorType.NUM, ErrorMessage.StartEndDate);\n      }\n      if (unit === 'D') {\n        return Math.floor(endDate) - Math.floor(startDate);\n      }\n      const start = this.dateTimeHelper.numberToSimpleDate(startDate);\n      const end = this.dateTimeHelper.numberToSimpleDate(endDate);\n      switch (unit) {\n        case 'M':\n          return (end.year - start.year) * 12 + (end.month - start.month) - (end.day < start.day ? 1 : 0);\n        case 'YM':\n          return (12 + (end.month - start.month) - (end.day < start.day ? 1 : 0)) % 12;\n        case 'Y':\n          if (end.month > start.month || end.month === start.month && end.day >= start.day) {\n            return end.year - start.year;\n          } else {\n            return end.year - start.year - 1;\n          }\n        case 'MD':\n          if (end.day >= start.day) {\n            return end.day - start.day;\n          } else {\n            const m = end.month === 1 ? 12 : end.month - 1;\n            const y = end.month === 1 ? end.year - 1 : end.year;\n            return this.dateTimeHelper.daysInMonth(y, m) + end.day - start.day;\n          }\n        case 'YD':\n          if (end.month > start.month || end.month === start.month && end.day >= start.day) {\n            return Math.floor(endDate) - this.dateTimeHelper.dateToNumber({\n              year: end.year,\n              month: start.month,\n              day: start.day\n            });\n          } else {\n            return Math.floor(endDate) - Math.floor(startDate) - 365 * (end.year - start.year - 1) - this.dateTimeHelper.leapYearsCount(end.year - 1) + this.dateTimeHelper.leapYearsCount(start.year);\n          }\n        default:\n          return new CellError(ErrorType.NUM, ErrorMessage.BadMode);\n      }\n    });\n  }\n  days360(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('DAYS360'), this.days360Core);\n  }\n  yearfrac(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('YEARFRAC'), (startDate, endDate, mode) => {\n      startDate = Math.trunc(startDate);\n      endDate = Math.trunc(endDate);\n      if (startDate > endDate) {\n        [startDate, endDate] = [endDate, startDate];\n      }\n      switch (mode) {\n        case 0:\n          return this.days360Core(startDate, endDate, false) / 360;\n        case 1:\n          return (endDate - startDate) / this.dateTimeHelper.yearLengthForBasis(this.dateTimeHelper.numberToSimpleDate(startDate), this.dateTimeHelper.numberToSimpleDate(endDate));\n        case 2:\n          return (endDate - startDate) / 360;\n        case 3:\n          return (endDate - startDate) / 365;\n        case 4:\n          return this.days360Core(startDate, endDate, true) / 360;\n      }\n      throw new Error('Should not be reachable.');\n    });\n  }\n  interval(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('INTERVAL'), arg => {\n      arg = Math.trunc(arg);\n      const second = arg % 60;\n      arg = Math.trunc(arg / 60);\n      const minute = arg % 60;\n      arg = Math.trunc(arg / 60);\n      const hour = arg % 24;\n      arg = Math.trunc(arg / 24);\n      const day = arg % 30;\n      arg = Math.trunc(arg / 30);\n      const month = arg % 12;\n      const year = Math.trunc(arg / 12);\n      return 'P' + (year > 0 ? year + 'Y' : '') + (month > 0 ? month + 'M' : '') + (day > 0 ? day + 'D' : '') + 'T' + (hour > 0 ? hour + 'H' : '') + (minute > 0 ? minute + 'M' : '') + (second > 0 ? second + 'S' : '');\n    });\n  }\n  networkdays(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS'), (start, end, holidays) => this.networkdayscore(start, end, 1, holidays));\n  }\n  networkdaysintl(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS.INTL'), (start, end, weekend, holidays) => this.networkdayscore(start, end, weekend, holidays));\n  }\n  workday(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('WORKDAY'), (start, end, holidays) => this.workdaycore(start, end, 1, holidays));\n  }\n  workdayintl(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('WORKDAY.INTL'), (start, end, weekend, holidays) => this.workdaycore(start, end, weekend, holidays));\n  }\n  networkdayscore(start, end, weekend, holidays) {\n    start = Math.trunc(start);\n    end = Math.trunc(end);\n    let multiplier = 1;\n    if (start > end) {\n      [start, end] = [end, start];\n      multiplier = -1;\n    }\n    const weekendPattern = computeWeekendPattern(weekend);\n    if (weekendPattern instanceof CellError) {\n      return weekendPattern;\n    }\n    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);\n    if (filteredHolidays instanceof CellError) {\n      return filteredHolidays;\n    }\n    return multiplier * this.countWorkdays(start, end, weekendPattern, filteredHolidays);\n  }\n  workdaycore(start, delta, weekend, holidays) {\n    start = Math.trunc(start);\n    delta = Math.trunc(delta);\n    const weekendPattern = computeWeekendPattern(weekend);\n    if (weekendPattern instanceof CellError) {\n      return weekendPattern;\n    }\n    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);\n    if (filteredHolidays instanceof CellError) {\n      return filteredHolidays;\n    }\n    if (delta > 0) {\n      let upper = 1;\n      while (this.countWorkdays(start + 1, start + upper, weekendPattern, filteredHolidays) < delta) {\n        upper *= 2;\n      }\n      let lower = 1;\n      while (lower + 1 < upper) {\n        const mid = Math.trunc((lower + upper) / 2);\n        if (this.countWorkdays(start + 1, start + mid, weekendPattern, filteredHolidays) < delta) {\n          lower = mid;\n        } else {\n          upper = mid;\n        }\n      }\n      return start + upper;\n    } else if (delta < 0) {\n      delta *= -1;\n      let upper = 1;\n      while (this.countWorkdays(start - upper, start - 1, weekendPattern, filteredHolidays) < delta) {\n        upper *= 2;\n      }\n      let lower = 1;\n      while (lower + 1 < upper) {\n        const mid = Math.trunc((lower + upper) / 2);\n        if (this.countWorkdays(start - mid, start - 1, weekendPattern, filteredHolidays) < delta) {\n          lower = mid;\n        } else {\n          upper = mid;\n        }\n      }\n      return start - upper;\n    } else {\n      return start;\n    }\n  }\n  countWorkdays(start, end, weekendPattern, sortedHolidays) {\n    const absoluteEnd = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(end));\n    const absoluteStart = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(start));\n    let ans = 0;\n    for (let i = 0; i < 7; i++) {\n      if (weekendPattern.charAt(i) === '0') {\n        ans += Math.floor((absoluteEnd + 6 - i) / 7);\n        ans -= Math.floor((absoluteStart - 1 + 6 - i) / 7);\n      }\n    }\n    ans -= lowerBound(end + 1, sortedHolidays) - lowerBound(start, sortedHolidays);\n    return ans;\n  }\n  simpleRangeToFilteredHolidays(weekendPattern, holidays) {\n    var _a;\n    const holidaysArr = (_a = holidays === null || holidays === void 0 ? void 0 : holidays.valuesFromTopLeftCorner()) !== null && _a !== void 0 ? _a : [];\n    for (const val of holidaysArr) {\n      if (val instanceof CellError) {\n        return val;\n      }\n    }\n    const processedHolidays = [];\n    for (const val of holidaysArr) {\n      if (val === EmptyValue) {\n        continue;\n      }\n      if (isExtendedNumber(val)) {\n        processedHolidays.push(Math.trunc(getRawValue(val)));\n      } else {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n    }\n    return [...new Set(processedHolidays)].sort((a, b) => a - b).filter(arg => {\n      const val = this.dateTimeHelper.relativeNumberToAbsoluteNumber(arg);\n      const i = (val - 1) % 7;\n      return weekendPattern.charAt(i) === '0';\n    });\n  }\n}\nDateTimePlugin.implementedFunctions = {\n  'DATE': {\n    method: 'date',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_DATE\n  },\n  'TIME': {\n    method: 'time',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_TIME\n  },\n  'MONTH': {\n    method: 'month',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'YEAR': {\n    method: 'year',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'HOUR': {\n    method: 'hour',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'MINUTE': {\n    method: 'minute',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'SECOND': {\n    method: 'second',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'TEXT': {\n    method: 'text',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'EOMONTH': {\n    method: 'eomonth',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_DATE\n  },\n  'DAY': {\n    method: 'day',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'DAYS': {\n    method: 'days',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'WEEKDAY': {\n    method: 'weekday',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'WEEKNUM': {\n    method: 'weeknum',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'ISOWEEKNUM': {\n    method: 'isoweeknum',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'DATEVALUE': {\n    method: 'datevalue',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    returnNumberType: NumberType.NUMBER_DATE\n  },\n  'TIMEVALUE': {\n    method: 'timevalue',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    returnNumberType: NumberType.NUMBER_TIME\n  },\n  'NOW': {\n    method: 'now',\n    parameters: [],\n    isVolatile: true,\n    returnNumberType: NumberType.NUMBER_DATETIME\n  },\n  'TODAY': {\n    method: 'today',\n    parameters: [],\n    isVolatile: true,\n    returnNumberType: NumberType.NUMBER_DATE\n  },\n  'EDATE': {\n    method: 'edate',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    returnNumberType: NumberType.NUMBER_DATE\n  },\n  'DAYS360': {\n    method: 'days360',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN,\n      defaultValue: false\n    }]\n  },\n  'DATEDIF': {\n    method: 'datedif',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'YEARFRAC': {\n    method: 'yearfrac',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      defaultValue: 0,\n      minValue: 0,\n      maxValue: 4\n    }]\n  },\n  'INTERVAL': {\n    method: 'interval',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'NETWORKDAYS': {\n    method: 'networkdays',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  'NETWORKDAYS.INTL': {\n    method: 'networkdaysintl',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NOERROR,\n      defaultValue: 1\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  'WORKDAY': {\n    method: 'workday',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  },\n  'WORKDAY.INTL': {\n    method: 'workdayintl',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NOERROR,\n      defaultValue: 1\n    }, {\n      argumentType: FunctionArgumentType.RANGE,\n      optionalArg: true\n    }]\n  }\n};\n/**\r\n * Returns i such that:\r\n * sortedArray[i-1] < val <= sortedArray[i]\r\n *\r\n */\nfunction lowerBound(val, sortedArray) {\n  if (sortedArray.length === 0) {\n    return 0;\n  }\n  if (val <= sortedArray[0]) {\n    return 0;\n  }\n  if (sortedArray[sortedArray.length - 1] < val) {\n    return sortedArray.length;\n  }\n  let lower = 0; //sortedArray[lower] < val\n  let upper = sortedArray.length - 1; //sortedArray[upper] >= val\n  while (lower + 1 < upper) {\n    const mid = Math.floor((upper + lower) / 2);\n    if (sortedArray[mid] >= val) {\n      upper = mid;\n    } else {\n      lower = mid;\n    }\n  }\n  return upper;\n}\nfunction computeWeekendPattern(weekend) {\n  var _a;\n  if (typeof weekend !== 'number' && typeof weekend !== 'string') {\n    return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n  }\n  if (typeof weekend === 'string') {\n    if (weekend.length !== 7 || !/^(0|1)*$/.test(weekend) || weekend === '1111111') {\n      return new CellError(ErrorType.NUM, ErrorMessage.WeekendString);\n    } else {\n      return weekend;\n    }\n  } else {\n    return (_a = workdayPatterns.get(weekend)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.NUM, ErrorMessage.BadMode);\n  }\n}\nconst weekdayOffsets = new Map([[1, 0], [2, 1], [11, 1], [12, 2], [13, 3], [14, 4], [15, 5], [16, 6], [17, 0]]);\nconst workdayPatterns = new Map([[1, '0000011'], [2, '1000001'], [3, '1100000'], [4, '0110000'], [5, '0011000'], [6, '0001100'], [7, '0000110'], [11, '0000001'], [12, '1000000'], [13, '0100000'], [14, '0010000'], [15, '0001000'], [16, '0000100'], [17, '0000010']]);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}