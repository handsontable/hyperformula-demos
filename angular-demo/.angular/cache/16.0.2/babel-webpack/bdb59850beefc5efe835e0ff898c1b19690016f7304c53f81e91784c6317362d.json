{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange, simpleCellRange } from '../AbsoluteCellRange';\nimport { absolutizeDependencies } from '../absolutizeDependencies';\nimport { CellError, ErrorType, isSimpleCellAddress, simpleCellAddress } from '../Cell';\nimport { ContentChanges } from '../ContentChanges';\nimport { ErrorMessage } from '../error-message';\nimport { EmptyValue, getRawValue } from '../interpreter/InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nimport { collectDependencies, NamedExpressionDependency } from '../parser';\nimport { ColumnsSpan, RowsSpan } from '../Span';\nimport { StatType } from '../statistics';\nimport { ArrayVertex, EmptyCellVertex, FormulaCellVertex, RangeVertex, ValueCellVertex } from './';\nimport { AddressMapping } from './AddressMapping/AddressMapping';\nimport { ArrayMapping } from './ArrayMapping';\nimport { collectAddressesDependentToRange } from './collectAddressesDependentToRange';\nimport { FormulaVertex } from './FormulaCellVertex';\nimport { Graph } from './Graph';\nimport { RangeMapping } from './RangeMapping';\nimport { SheetMapping } from './SheetMapping';\nexport class DependencyGraph {\n  constructor(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {\n    this.addressMapping = addressMapping;\n    this.rangeMapping = rangeMapping;\n    this.sheetMapping = sheetMapping;\n    this.arrayMapping = arrayMapping;\n    this.stats = stats;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.functionRegistry = functionRegistry;\n    this.namedExpressions = namedExpressions;\n    this.changes = ContentChanges.empty();\n    this.dependencyQueryAddresses = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex).map(([address, _]) => address);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof NamedExpressionDependency) {\n              return this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;\n            } else if (isSimpleCellAddress(dependency)) {\n              return dependency;\n            } else {\n              return simpleCellRange(dependency.start, dependency.end);\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.dependencyQueryVertices = vertex => {\n      if (vertex instanceof RangeVertex) {\n        return this.rangeDependencyQuery(vertex);\n      } else {\n        const dependenciesResult = this.formulaDependencyQuery(vertex);\n        if (dependenciesResult !== undefined) {\n          const [address, dependencies] = dependenciesResult;\n          return dependencies.map(dependency => {\n            if (dependency instanceof AbsoluteCellRange) {\n              return [dependency.start, this.rangeMapping.fetchRange(dependency.start, dependency.end)];\n            } else if (dependency instanceof NamedExpressionDependency) {\n              const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);\n              return [namedExpression.address, this.addressMapping.fetchCell(namedExpression.address)];\n            } else {\n              return [dependency, this.addressMapping.fetchCell(dependency)];\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    };\n    this.rangeDependencyQuery = vertex => {\n      const allDeps = [];\n      const {\n        smallerRangeVertex,\n        restRange\n      } = this.rangeMapping.findSmallerRange(vertex.range); //checking whether this range was splitted by bruteForce or not\n      let range;\n      if (smallerRangeVertex !== undefined && this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {\n        range = restRange;\n        allDeps.push([new AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);\n      } else {\n        //did we ever need to use full range\n        range = vertex.range;\n      }\n      for (const address of range.addresses(this)) {\n        const cell = this.addressMapping.getCell(address);\n        if (cell !== undefined) {\n          allDeps.push([address, cell]);\n        }\n      }\n      return allDeps;\n    };\n    this.formulaDependencyQuery = vertex => {\n      let formula;\n      let address;\n      if (vertex instanceof FormulaVertex) {\n        address = vertex.getAddress(this.lazilyTransformingAstService);\n        formula = vertex.getFormula(this.lazilyTransformingAstService);\n      } else {\n        return undefined;\n      }\n      const deps = collectDependencies(formula, this.functionRegistry);\n      return [address, absolutizeDependencies(deps, address)];\n    };\n    this.graph = new Graph(this.dependencyQueryVertices);\n  }\n  /**\r\n   * Invariants:\r\n   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula\r\n   */\n  static buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {\n    return new DependencyGraph(new AddressMapping(config.chooseAddressMappingPolicy), new RangeMapping(), new SheetMapping(config.translationPackage), new ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);\n  }\n  setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {\n    const newVertex = FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());\n    this.exchangeOrAddFormulaVertex(newVertex);\n    this.processCellDependencies(dependencies, newVertex);\n    this.graph.markNodeAsSpecialRecentlyChanged(newVertex);\n    if (hasVolatileFunction) {\n      this.markAsVolatile(newVertex);\n    }\n    if (hasStructuralChangeFunction) {\n      this.markAsDependentOnStructureChange(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setParsingErrorToCell(address, errorVertex) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    this.exchangeOrAddGraphNode(vertex, errorVertex);\n    this.addressMapping.setCell(address, errorVertex);\n    this.graph.markNodeAsSpecialRecentlyChanged(errorVertex);\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setValueToCell(address, value) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.arrayMapping.removeArray(vertex.getRange());\n    }\n    if (vertex instanceof ValueCellVertex) {\n      const oldValues = vertex.getValues();\n      if (oldValues.rawValue !== value.rawValue) {\n        vertex.setValues(value);\n        this.graph.markNodeAsSpecialRecentlyChanged(vertex);\n      }\n    } else {\n      const newVertex = new ValueCellVertex(value.parsedValue, value.rawValue);\n      this.exchangeOrAddGraphNode(vertex, newVertex);\n      this.addressMapping.setCell(address, newVertex);\n      this.graph.markNodeAsSpecialRecentlyChanged(newVertex);\n    }\n    this.correctInfiniteRangesDependency(address);\n    return this.getAndClearContentChanges();\n  }\n  setCellEmpty(address) {\n    const vertex = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex === undefined) {\n      return ContentChanges.empty();\n    }\n    if (this.graph.adjacentNodes(vertex).size > 0) {\n      const emptyVertex = new EmptyCellVertex();\n      this.exchangeGraphNode(vertex, emptyVertex);\n      if (this.graph.adjacentNodesCount(emptyVertex) === 0) {\n        this.removeVertex(emptyVertex);\n        this.addressMapping.removeCell(address);\n      } else {\n        this.graph.markNodeAsSpecialRecentlyChanged(emptyVertex);\n        this.addressMapping.setCell(address, emptyVertex);\n      }\n    } else {\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(address);\n    }\n    return this.getAndClearContentChanges();\n  }\n  ensureThatVertexIsNonArrayCellVertex(vertex) {\n    if (vertex instanceof ArrayVertex) {\n      throw new Error('Illegal operation');\n    }\n  }\n  clearRecentlyChangedVertices() {\n    this.graph.clearSpecialNodesRecentlyChanged();\n  }\n  verticesToRecompute() {\n    return new Set([...this.graph.specialNodesRecentlyChanged, ...this.volatileVertices()]);\n  }\n  processCellDependencies(cellDependencies, endVertex) {\n    cellDependencies.forEach(dep => {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        let rangeVertex = this.getRange(range.start, range.end);\n        if (rangeVertex === undefined) {\n          rangeVertex = new RangeVertex(range);\n          this.rangeMapping.setRange(rangeVertex);\n        }\n        this.graph.addNode(rangeVertex);\n        if (!range.isFinite()) {\n          this.graph.markNodeAsInfiniteRange(rangeVertex);\n        }\n        const {\n          smallerRangeVertex,\n          restRange\n        } = this.rangeMapping.findSmallerRange(range);\n        if (smallerRangeVertex !== undefined) {\n          this.graph.addEdge(smallerRangeVertex, rangeVertex);\n          if (rangeVertex.bruteForce) {\n            rangeVertex.bruteForce = false;\n            for (const cellFromRange of range.addresses(this)) {\n              //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary\n              this.graph.removeEdge(this.fetchCell(cellFromRange), rangeVertex);\n            }\n          }\n        } else {\n          rangeVertex.bruteForce = true;\n        }\n        const array = this.arrayMapping.getArray(restRange);\n        if (array !== undefined) {\n          this.graph.addEdge(array, rangeVertex);\n        } else {\n          for (const cellFromRange of restRange.addresses(this)) {\n            this.graph.addEdge(this.fetchCellOrCreateEmpty(cellFromRange), rangeVertex);\n          }\n        }\n        this.graph.addEdge(rangeVertex, endVertex);\n        if (range.isFinite()) {\n          this.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);\n        }\n      } else if (dep instanceof NamedExpressionDependency) {\n        const sheetOfVertex = endVertex.getAddress(this.lazilyTransformingAstService).sheet;\n        const namedExpressionVertex = this.fetchNamedExpressionVertex(dep.name, sheetOfVertex);\n        this.graph.addEdge(namedExpressionVertex, endVertex);\n      } else {\n        this.graph.addEdge(this.fetchCellOrCreateEmpty(dep), endVertex);\n      }\n    });\n  }\n  fetchNamedExpressionVertex(expressionName, sheetId) {\n    const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);\n    return this.fetchCellOrCreateEmpty(namedExpression.address);\n  }\n  exchangeNode(addressFrom, addressTo) {\n    const vertexFrom = this.fetchCellOrCreateEmpty(addressFrom);\n    const vertexTo = this.fetchCellOrCreateEmpty(addressTo);\n    this.addressMapping.removeCell(addressFrom);\n    this.exchangeGraphNode(vertexFrom, vertexTo);\n  }\n  correctInfiniteRangesDependency(address) {\n    let vertex = undefined;\n    for (const range of this.graph.infiniteRanges) {\n      const infiniteRangeVertex = range;\n      if (infiniteRangeVertex.range.addressInRange(address)) {\n        vertex = vertex !== null && vertex !== void 0 ? vertex : this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(vertex, infiniteRangeVertex);\n      }\n    }\n  }\n  fetchCellOrCreateEmpty(address) {\n    let vertex = this.addressMapping.getCell(address);\n    if (vertex === undefined) {\n      vertex = new EmptyCellVertex();\n      this.graph.addNode(vertex);\n      this.addressMapping.setCell(address, vertex);\n    }\n    return vertex;\n  }\n  removeRows(removedRows) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromRowsSpan(removedRows)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeRows(removedRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedRows, address => address.row);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  removeSheet(removedSheetId) {\n    this.clearSheet(removedSheetId);\n    for (const [adr, vertex] of this.addressMapping.sheetEntries(removedSheetId)) {\n      for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n        this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);\n      }\n      this.removeVertex(vertex);\n      this.addressMapping.removeCell(adr);\n    }\n    this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const rangesToRemove = this.rangeMapping.removeRangesInSheet(removedSheetId);\n      for (const range of rangesToRemove) {\n        this.removeVertex(range);\n      }\n      this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n        this.addressMapping.removeSheet(removedSheetId);\n      });\n    });\n  }\n  clearSheet(sheetId) {\n    const arrays = new Set();\n    for (const [address, vertex] of this.addressMapping.sheetEntries(sheetId)) {\n      if (vertex instanceof ArrayVertex) {\n        arrays.add(vertex);\n      } else {\n        this.setCellEmpty(address);\n      }\n    }\n    for (const array of arrays.values()) {\n      this.setArrayEmpty(array);\n    }\n    this.addStructuralNodesToChangeSet();\n  }\n  removeColumns(removedColumns) {\n    this.stats.measure(StatType.ADJUSTING_GRAPH, () => {\n      for (const [address, vertex] of this.addressMapping.entriesFromColumnsSpan(removedColumns)) {\n        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {\n          this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);\n        }\n        if (vertex instanceof ArrayVertex) {\n          if (vertex.isLeftCorner(address)) {\n            this.shrinkArrayToCorner(vertex);\n            this.arrayMapping.removeArray(vertex.getRange());\n          } else {\n            continue;\n          }\n        }\n        this.removeVertex(vertex);\n      }\n    });\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.removeColumns(removedColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const affectedRanges = this.truncateRanges(removedColumns, address => address.col);\n      return this.getArrayVerticesRelatedToRanges(affectedRanges);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);\n    });\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  addRows(addedRows) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      this.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      this.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);\n    });\n    for (const vertex of this.addressMapping.verticesFromRowsSpan(addedRows)) {\n      this.graph.markNodeAsSpecialRecentlyChanged(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays\n    };\n  }\n  addColumns(addedColumns) {\n    this.stats.measure(StatType.ADJUSTING_ADDRESS_MAPPING, () => {\n      this.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    const affectedArrays = this.stats.measure(StatType.ADJUSTING_RANGES, () => {\n      const result = this.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      this.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);\n    });\n    this.stats.measure(StatType.ADJUSTING_ARRAY_MAPPING, () => {\n      return this.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);\n    });\n    for (const vertex of this.addressMapping.verticesFromColumnsSpan(addedColumns)) {\n      this.graph.markNodeAsSpecialRecentlyChanged(vertex);\n    }\n    this.addStructuralNodesToChangeSet();\n    return {\n      affectedArrays,\n      contentChanges: this.getAndClearContentChanges()\n    };\n  }\n  ensureNoArrayInRange(range) {\n    if (this.arrayMapping.isFormulaArrayInRange(range)) {\n      throw Error('It is not possible to move / replace cells with array');\n    }\n  }\n  isThereSpaceForArray(arrayVertex) {\n    const range = arrayVertex.getRangeOrUndef();\n    if (range === undefined) {\n      return false;\n    }\n    for (const address of range.addresses(this)) {\n      const vertexUnderAddress = this.addressMapping.getCell(address);\n      if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {\n        return false;\n      }\n    }\n    return true;\n  }\n  moveCells(sourceRange, toRight, toBottom, toSheet) {\n    for (const sourceAddress of sourceRange.addressesWithDirection(toRight, toBottom, this)) {\n      const targetAddress = simpleCellAddress(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);\n      let sourceVertex = this.addressMapping.getCell(sourceAddress);\n      const targetVertex = this.addressMapping.getCell(targetAddress);\n      this.addressMapping.removeCell(sourceAddress);\n      if (sourceVertex !== undefined) {\n        this.graph.markNodeAsSpecialRecentlyChanged(sourceVertex);\n        this.addressMapping.setCell(targetAddress, sourceVertex);\n        let emptyVertex = undefined;\n        for (const adjacentNode of this.graph.adjacentNodes(sourceVertex)) {\n          if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n            emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress);\n            this.graph.addEdge(emptyVertex, adjacentNode);\n            this.graph.removeEdge(sourceVertex, adjacentNode);\n          }\n        }\n        if (emptyVertex) {\n          this.graph.markNodeAsSpecialRecentlyChanged(emptyVertex);\n          this.addressMapping.setCell(sourceAddress, emptyVertex);\n        }\n      }\n      if (targetVertex !== undefined) {\n        if (sourceVertex === undefined) {\n          this.addressMapping.removeCell(targetAddress);\n        }\n        for (const adjacentNode of this.graph.adjacentNodes(targetVertex)) {\n          sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress);\n          this.graph.addEdge(sourceVertex, adjacentNode);\n          this.graph.markNodeAsSpecialRecentlyChanged(sourceVertex);\n        }\n        this.removeVertex(targetVertex);\n      }\n    }\n    for (const rangeVertex of this.rangeMapping.rangeVerticesContainedInRange(sourceRange)) {\n      for (const adjacentNode of this.graph.adjacentNodes(rangeVertex)) {\n        if (adjacentNode instanceof RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {\n          this.graph.removeEdge(rangeVertex, adjacentNode);\n          for (const address of rangeVertex.range.addresses(this)) {\n            const newEmptyVertex = this.fetchCellOrCreateEmpty(address);\n            this.graph.addEdge(newEmptyVertex, adjacentNode);\n            this.addressMapping.setCell(address, newEmptyVertex);\n            this.graph.markNodeAsSpecialRecentlyChanged(newEmptyVertex);\n          }\n        }\n      }\n    }\n    this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);\n  }\n  setArrayEmpty(arrayVertex) {\n    const arrayRange = AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);\n    const adjacentNodes = this.graph.adjacentNodes(arrayVertex);\n    for (const address of arrayRange.addresses(this)) {\n      this.addressMapping.removeCell(address);\n    }\n    for (const adjacentNode of adjacentNodes.values()) {\n      const nodeDependencies = collectAddressesDependentToRange(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);\n      for (const address of nodeDependencies) {\n        const vertex = this.fetchCellOrCreateEmpty(address);\n        this.graph.addEdge(vertex, adjacentNode);\n      }\n      if (nodeDependencies.length > 0) {\n        this.graph.markNodeAsSpecialRecentlyChanged(adjacentNode);\n      }\n    }\n    this.removeVertex(arrayVertex);\n    this.arrayMapping.removeArray(arrayVertex.getRange());\n  }\n  addVertex(address, vertex) {\n    this.graph.addNode(vertex);\n    this.addressMapping.setCell(address, vertex);\n  }\n  addArrayVertex(address, vertex) {\n    this.graph.addNode(vertex);\n    this.setAddressMappingForArrayVertex(vertex, address);\n  }\n  *arrayFormulaNodes() {\n    for (const vertex of this.graph.nodes) {\n      if (vertex instanceof ArrayVertex) {\n        yield vertex;\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    yield* this.addressMapping.entriesFromRowsSpan(rowsSpan);\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    yield* this.addressMapping.entriesFromColumnsSpan(columnsSpan);\n  }\n  existsVertex(address) {\n    return this.addressMapping.has(address);\n  }\n  fetchCell(address) {\n    return this.addressMapping.fetchCell(address);\n  }\n  getCell(address) {\n    return this.addressMapping.getCell(address);\n  }\n  getCellValue(address) {\n    return this.addressMapping.getCellValue(address);\n  }\n  getRawValue(address) {\n    return this.addressMapping.getRawValue(address);\n  }\n  getScalarValue(address) {\n    const value = this.addressMapping.getCellValue(address);\n    if (value instanceof SimpleRangeValue) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.ScalarExpected);\n    }\n    return value;\n  }\n  existsEdge(fromNode, toNode) {\n    return this.graph.existsEdge(fromNode, toNode);\n  }\n  getSheetId(sheetName) {\n    return this.sheetMapping.fetch(sheetName);\n  }\n  getSheetHeight(sheet) {\n    return this.addressMapping.getHeight(sheet);\n  }\n  getSheetWidth(sheet) {\n    return this.addressMapping.getWidth(sheet);\n  }\n  getArray(range) {\n    return this.arrayMapping.getArray(range);\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.setArray(range, vertex);\n  }\n  getRange(start, end) {\n    return this.rangeMapping.getRange(start, end);\n  }\n  topSortWithScc() {\n    return this.graph.topSortWithScc();\n  }\n  markAsVolatile(vertex) {\n    this.graph.markNodeAsSpecial(vertex);\n  }\n  markAsDependentOnStructureChange(vertex) {\n    this.graph.markNodeAsChangingWithStructure(vertex);\n  }\n  forceApplyPostponedTransformations() {\n    for (const vertex of this.graph.nodes.values()) {\n      if (vertex instanceof FormulaCellVertex) {\n        vertex.ensureRecentData(this.lazilyTransformingAstService);\n      }\n    }\n  }\n  volatileVertices() {\n    return this.graph.specialNodes;\n  }\n  getArrayVerticesRelatedToRanges(ranges) {\n    const arrayVertices = ranges.map(range => {\n      if (this.graph.hasNode(range)) {\n        return Array.from(this.graph.adjacentNodes(range)).filter(node => node instanceof ArrayVertex);\n      } else {\n        return [];\n      }\n    });\n    return new Set(...arrayVertices);\n  }\n  *rawValuesFromRange(range) {\n    for (const address of range.addresses(this)) {\n      const value = this.getScalarValue(address);\n      if (value !== EmptyValue) {\n        yield [getRawValue(value), address];\n      }\n    }\n  }\n  *entriesFromRange(range) {\n    for (const address of range.addresses(this)) {\n      yield [address, this.getCell(address)];\n    }\n  }\n  exchangeGraphNode(oldNode, newNode) {\n    this.graph.addNode(newNode);\n    const adjNodesStored = this.graph.adjacentNodes(oldNode);\n    this.removeVertex(oldNode);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(newNode, adjacentNode);\n      }\n    });\n  }\n  exchangeOrAddGraphNode(oldNode, newNode) {\n    if (oldNode) {\n      this.exchangeGraphNode(oldNode, newNode);\n    } else {\n      this.graph.addNode(newNode);\n    }\n  }\n  computeListOfValuesInRange(range) {\n    const values = [];\n    for (const cellFromRange of range.addresses(this)) {\n      const value = this.getScalarValue(cellFromRange);\n      values.push(value);\n    }\n    return values;\n  }\n  shrinkArrayToCorner(array) {\n    this.cleanAddressMappingUnderArray(array);\n    for (const adjacentVertex of this.adjacentArrayVertices(array)) {\n      let relevantDependencies;\n      if (adjacentVertex instanceof FormulaVertex) {\n        relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);\n      } else {\n        relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);\n      }\n      let dependentToCorner = false;\n      for (const [address, vertex] of relevantDependencies) {\n        if (array.isLeftCorner(address)) {\n          dependentToCorner = true;\n        }\n        this.graph.addEdge(vertex, adjacentVertex);\n        this.graph.markNodeAsSpecialRecentlyChanged(vertex);\n      }\n      if (!dependentToCorner) {\n        this.graph.removeEdge(array, adjacentVertex);\n      }\n    }\n    this.graph.markNodeAsSpecialRecentlyChanged(array);\n  }\n  isArrayInternalCell(address) {\n    const vertex = this.getCell(address);\n    return vertex instanceof ArrayVertex && !vertex.isLeftCorner(address);\n  }\n  getAndClearContentChanges() {\n    const changes = this.changes;\n    this.changes = ContentChanges.empty();\n    return changes;\n  }\n  getAdjacentNodesAddresses(inputVertex) {\n    const deps = this.graph.adjacentNodes(inputVertex);\n    const ret = [];\n    deps.forEach(vertex => {\n      const castVertex = vertex;\n      if (castVertex instanceof RangeVertex) {\n        ret.push(simpleCellRange(castVertex.start, castVertex.end));\n      } else {\n        ret.push(castVertex.getAddress(this.lazilyTransformingAstService));\n      }\n    });\n    return ret;\n  }\n  correctInfiniteRangesDependenciesByRangeVertex(vertex) {\n    for (const range of this.graph.infiniteRanges) {\n      const infiniteRangeVertex = range;\n      const intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);\n      if (intersection === undefined) {\n        continue;\n      }\n      for (const address of intersection.addresses(this)) {\n        this.graph.addEdge(this.fetchCellOrCreateEmpty(address), range);\n      }\n    }\n  }\n  cleanAddressMappingUnderArray(vertex) {\n    const arrayRange = vertex.getRange();\n    for (const address of arrayRange.addresses(this)) {\n      const oldValue = vertex.getArrayCellValue(address);\n      if (this.getCell(address) === vertex) {\n        if (vertex.isLeftCorner(address)) {\n          this.changes.addChange(new CellError(ErrorType.REF), address, oldValue);\n        } else {\n          this.addressMapping.removeCell(address);\n          this.changes.addChange(EmptyValue, address, oldValue);\n        }\n      } else {\n        this.changes.addChange(EmptyValue, address, oldValue);\n      }\n    }\n  }\n  *formulaDirectDependenciesToArray(vertex, array) {\n    var _a;\n    const [, formulaDependencies] = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [];\n    if (formulaDependencies === undefined) {\n      return;\n    }\n    for (const dependency of formulaDependencies) {\n      if (dependency instanceof NamedExpressionDependency || dependency instanceof AbsoluteCellRange) {\n        continue;\n      }\n      if (array.getRange().addressInRange(dependency)) {\n        const vertex = this.fetchCellOrCreateEmpty(dependency);\n        yield [dependency, vertex];\n      }\n    }\n  }\n  *rangeDirectDependenciesToArray(vertex, array) {\n    const {\n      restRange: range\n    } = this.rangeMapping.findSmallerRange(vertex.range);\n    for (const address of range.addresses(this)) {\n      if (array.getRange().addressInRange(address)) {\n        const cell = this.fetchCellOrCreateEmpty(address);\n        yield [address, cell];\n      }\n    }\n  }\n  *adjacentArrayVertices(vertex) {\n    const adjacentNodes = this.graph.adjacentNodes(vertex);\n    for (const item of adjacentNodes) {\n      if (item instanceof FormulaVertex || item instanceof RangeVertex) {\n        yield item;\n      }\n    }\n  }\n  addStructuralNodesToChangeSet() {\n    for (const vertex of this.graph.specialNodesStructuralChanges) {\n      this.graph.markNodeAsSpecialRecentlyChanged(vertex);\n    }\n  }\n  fixRangesWhenAddingRows(sheet, row, numberOfRows) {\n    const originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));\n    for (const rangeVertex of originalValues) {\n      if (rangeVertex.range.includesRow(row + numberOfRows)) {\n        if (rangeVertex.bruteForce) {\n          const addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);\n          for (const address of addedSubrangeInThatRange.addresses(this)) {\n            this.graph.addEdge(this.fetchCellOrCreateEmpty(address), rangeVertex);\n          }\n        } else {\n          let currentRangeVertex = rangeVertex;\n          let find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          if (find.smallerRangeVertex !== undefined) {\n            continue;\n          }\n          while (find.smallerRangeVertex === undefined) {\n            const newRangeVertex = new RangeVertex(AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));\n            this.rangeMapping.setRange(newRangeVertex);\n            this.graph.addNode(newRangeVertex);\n            const restRange = new AbsoluteCellRange(simpleCellAddress(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);\n            this.addAllFromRange(restRange, currentRangeVertex);\n            this.graph.addEdge(newRangeVertex, currentRangeVertex);\n            currentRangeVertex = newRangeVertex;\n            find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);\n          }\n          this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);\n          this.addAllFromRange(find.restRange, currentRangeVertex);\n          this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);\n        }\n      }\n    }\n  }\n  addAllFromRange(range, vertex) {\n    for (const address of range.addresses(this)) {\n      this.graph.addEdge(this.fetchCellOrCreateEmpty(address), vertex);\n    }\n  }\n  fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {\n    for (const rangeVertex of this.rangeMapping.rangesInSheet(sheet)) {\n      if (rangeVertex.range.includesColumn(column + numberOfColumns)) {\n        let subrange;\n        if (rangeVertex.bruteForce) {\n          subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);\n        } else {\n          subrange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);\n        }\n        for (const address of subrange.addresses(this)) {\n          this.graph.addEdge(this.fetchCellOrCreateEmpty(address), rangeVertex);\n        }\n      }\n    }\n  }\n  exchangeOrAddFormulaVertex(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    const range = AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);\n    const oldNode = this.shrinkPossibleArrayAndGetCell(address);\n    if (vertex instanceof ArrayVertex) {\n      this.setArray(range, vertex);\n    }\n    this.exchangeOrAddGraphNode(oldNode, vertex);\n    this.addressMapping.setCell(address, vertex);\n    if (vertex instanceof ArrayVertex) {\n      if (!this.isThereSpaceForArray(vertex)) {\n        return;\n      }\n      for (const cellAddress of range.addresses(this)) {\n        if (vertex.isLeftCorner(cellAddress)) {\n          continue;\n        }\n        const old = this.getCell(cellAddress);\n        this.exchangeOrAddGraphNode(old, vertex);\n      }\n    }\n    for (const cellAddress of range.addresses(this)) {\n      this.addressMapping.setCell(cellAddress, vertex);\n    }\n  }\n  setAddressMappingForArrayVertex(vertex, formulaAddress) {\n    this.addressMapping.setCell(formulaAddress, vertex);\n    if (!(vertex instanceof ArrayVertex)) {\n      return;\n    }\n    const range = AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);\n    if (range === undefined) {\n      return;\n    }\n    this.setArray(range, vertex);\n    if (!this.isThereSpaceForArray(vertex)) {\n      return;\n    }\n    for (const address of range.addresses(this)) {\n      this.addressMapping.setCell(address, vertex);\n    }\n  }\n  truncateRanges(span, coordinate) {\n    const {\n      verticesToRemove,\n      verticesToMerge,\n      verticesWithChangedSize\n    } = this.rangeMapping.truncateRanges(span, coordinate);\n    for (const [existingVertex, mergedVertex] of verticesToMerge) {\n      this.mergeRangeVertices(existingVertex, mergedVertex);\n    }\n    for (const rangeVertex of verticesToRemove) {\n      this.removeVertexAndCleanupDependencies(rangeVertex);\n    }\n    return verticesWithChangedSize;\n  }\n  fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {\n        for (let row = rowStart; row <= arrayRange.end.row; ++row) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col, row + numberOfRows);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {\n    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);\n    if (rowStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInRows(RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      const arrayRange = array.getRange();\n      for (let row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {\n        for (let col = columnStart; col <= arrayRange.end.col; ++col) {\n          const destination = simpleCellAddress(sheet, col, row);\n          const source = simpleCellAddress(sheet, col + numberOfColumns, row);\n          const value = array.getArrayCellValue(destination);\n          this.addressMapping.moveCell(source, destination);\n          this.changes.addChange(EmptyValue, source, value);\n        }\n      }\n    }\n  }\n  fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {\n    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);\n    if (columnStart <= 0) {\n      return;\n    }\n    for (const [, array] of this.arrayMapping.arraysInCols(ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {\n      if (this.isThereSpaceForArray(array)) {\n        for (const address of array.getRange().addresses(this)) {\n          this.addressMapping.setCell(address, array);\n        }\n      } else {\n        this.setNoSpaceIfArray(array);\n      }\n    }\n  }\n  shrinkPossibleArrayAndGetCell(address) {\n    const vertex = this.getCell(address);\n    if (!(vertex instanceof ArrayVertex)) {\n      return vertex;\n    }\n    this.setNoSpaceIfArray(vertex);\n    return this.getCell(address);\n  }\n  setNoSpaceIfArray(vertex) {\n    if (vertex instanceof ArrayVertex) {\n      this.shrinkArrayToCorner(vertex);\n      vertex.setNoSpace();\n    }\n  }\n  removeVertex(vertex) {\n    this.removeVertexAndCleanupDependencies(vertex);\n    if (vertex instanceof RangeVertex) {\n      this.rangeMapping.removeRange(vertex);\n    }\n  }\n  mergeRangeVertices(existingVertex, newVertex) {\n    const adjNodesStored = this.graph.adjacentNodes(newVertex);\n    this.removeVertexAndCleanupDependencies(newVertex);\n    this.graph.softRemoveEdge(existingVertex, newVertex);\n    adjNodesStored.forEach(adjacentNode => {\n      if (this.graph.hasNode(adjacentNode)) {\n        this.graph.addEdge(existingVertex, adjacentNode);\n      }\n    });\n  }\n  removeVertexAndCleanupDependencies(inputVertex) {\n    const dependencies = new Set(this.graph.removeNode(inputVertex));\n    while (dependencies.size > 0) {\n      const dependency = dependencies.values().next().value;\n      dependencies.delete(dependency);\n      const [address, vertex] = dependency;\n      if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {\n        if (vertex instanceof RangeVertex || vertex instanceof EmptyCellVertex) {\n          this.graph.removeNode(vertex).forEach(candidate => dependencies.add(candidate));\n        }\n        if (vertex instanceof RangeVertex) {\n          this.rangeMapping.removeRange(vertex);\n        } else if (vertex instanceof EmptyCellVertex) {\n          this.addressMapping.removeCell(address);\n        }\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}