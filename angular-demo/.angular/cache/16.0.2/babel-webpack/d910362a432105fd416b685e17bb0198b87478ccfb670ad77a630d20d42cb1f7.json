{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, movedSimpleCellAddress } from '../Cell';\nimport { AddRowsTransformer } from '../dependencyTransformers/AddRowsTransformer';\nimport { RemoveRowsTransformer } from '../dependencyTransformers/RemoveRowsTransformer';\nimport { forceNormalizeString } from '../interpreter/ArithmeticHelper';\nimport { EmptyValue, getRawValue } from '../interpreter/InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nimport { StatType } from '../statistics';\nimport { ColumnBinarySearch } from './ColumnBinarySearch';\nexport class ColumnIndex {\n  constructor(dependencyGraph, config, stats) {\n    this.dependencyGraph = dependencyGraph;\n    this.config = config;\n    this.stats = stats;\n    this.index = new Map();\n    this.transformingService = this.dependencyGraph.lazilyTransformingAstService;\n    this.binarySearchStrategy = new ColumnBinarySearch(dependencyGraph);\n  }\n  add(value, address) {\n    if (value === EmptyValue || value instanceof CellError) {\n      return;\n    } else if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.addSingleCellValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.addSingleCellValue(value, address);\n    }\n  }\n  remove(value, address) {\n    if (value === undefined) {\n      return;\n    }\n    if (value instanceof SimpleRangeValue) {\n      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {\n        this.removeSingleValue(getRawValue(arrayValue), cellAddress);\n      }\n    } else {\n      this.removeSingleValue(value, address);\n    }\n  }\n  change(oldValue, newValue, address) {\n    if (oldValue === newValue) {\n      return;\n    }\n    this.remove(oldValue, address);\n    this.add(newValue, address);\n  }\n  applyChanges(contentChanges) {\n    for (const change of contentChanges) {\n      if (change.oldValue !== undefined) {\n        this.change(getRawValue(change.oldValue), getRawValue(change.value), change.address);\n      }\n    }\n  }\n  moveValues(sourceRange, toRight, toBottom, toSheet) {\n    for (const [value, address] of sourceRange) {\n      const targetAddress = movedSimpleCellAddress(address, toSheet, toRight, toBottom);\n      this.remove(value, address);\n      this.add(value, targetAddress);\n    }\n  }\n  removeValues(range) {\n    for (const [value, address] of range) {\n      this.remove(value, address);\n    }\n  }\n  /*\r\n   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true\r\n   */\n  find(searchKey, rangeValue, {\n    ordering,\n    matchExactly\n  }) {\n    const handlingDuplicates = matchExactly === true ? 'findFirst' : 'findLast';\n    const resultUsingColumnIndex = this.findUsingColumnIndex(searchKey, rangeValue, handlingDuplicates);\n    return resultUsingColumnIndex !== undefined ? resultUsingColumnIndex : this.binarySearchStrategy.find(searchKey, rangeValue, {\n      ordering,\n      matchExactly\n    });\n  }\n  findUsingColumnIndex(key, rangeValue, handlingDuplicates) {\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return undefined;\n    }\n    this.ensureRecentData(range.sheet, range.start.col, key);\n    const columnMap = this.getColumnMap(range.sheet, range.start.col);\n    if (!columnMap) {\n      return -1;\n    }\n    const normalizedKey = typeof key === 'string' ? forceNormalizeString(key) : key;\n    const valueIndexForTheKey = columnMap.get(normalizedKey);\n    if (!valueIndexForTheKey || !valueIndexForTheKey.index || valueIndexForTheKey.index.length === 0) {\n      return undefined;\n    }\n    const rowNumber = ColumnIndex.findRowBelongingToRange(valueIndexForTheKey, range, handlingDuplicates);\n    return rowNumber !== undefined ? rowNumber - range.start.row : undefined;\n  }\n  static findRowBelongingToRange(valueIndex, range, handlingDuplicates) {\n    const start = range.start.row;\n    const end = range.end.row;\n    const positionInIndex = handlingDuplicates === 'findFirst' ? findInOrderedArray(start, valueIndex.index, 'upperBound') : findInOrderedArray(end, valueIndex.index, 'lowerBound');\n    if (positionInIndex === -1) {\n      return undefined;\n    }\n    const rowNumber = valueIndex.index[positionInIndex];\n    const isRowNumberBelongingToRange = rowNumber >= start && rowNumber <= end;\n    return isRowNumberBelongingToRange ? rowNumber : undefined;\n  }\n  advancedFind(keyMatcher, range) {\n    return this.binarySearchStrategy.advancedFind(keyMatcher, range);\n  }\n  addColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, 0, ...Array(columnsSpan.numberOfColumns));\n  }\n  removeColumns(columnsSpan) {\n    const sheetIndex = this.index.get(columnsSpan.sheet);\n    if (!sheetIndex) {\n      return;\n    }\n    sheetIndex.splice(columnsSpan.columnStart, columnsSpan.numberOfColumns);\n  }\n  removeSheet(sheetId) {\n    this.index.delete(sheetId);\n  }\n  getColumnMap(sheet, col) {\n    if (!this.index.has(sheet)) {\n      this.index.set(sheet, []);\n    }\n    const sheetMap = this.index.get(sheet); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    let columnMap = sheetMap[col];\n    if (!columnMap) {\n      columnMap = new Map();\n      sheetMap[col] = columnMap;\n    }\n    return columnMap;\n  }\n  getValueIndex(sheet, col, value) {\n    const columnMap = this.getColumnMap(sheet, col);\n    let index = this.getColumnMap(sheet, col).get(value);\n    if (!index) {\n      index = {\n        version: this.transformingService.version(),\n        index: []\n      };\n      columnMap.set(value, index);\n    }\n    return index;\n  }\n  ensureRecentData(sheet, col, value) {\n    const valueIndex = this.getValueIndex(sheet, col, value);\n    const actualVersion = this.transformingService.version();\n    if (valueIndex.version === actualVersion) {\n      return;\n    }\n    const relevantTransformations = this.transformingService.getTransformationsFrom(valueIndex.version, transformation => {\n      return transformation.sheet === sheet && (transformation instanceof AddRowsTransformer || transformation instanceof RemoveRowsTransformer);\n    });\n    for (const transformation of relevantTransformations) {\n      if (transformation instanceof AddRowsTransformer) {\n        this.addRows(col, transformation.rowsSpan, value);\n      } else if (transformation instanceof RemoveRowsTransformer) {\n        this.removeRows(col, transformation.rowsSpan, value);\n      }\n    }\n    valueIndex.version = actualVersion;\n  }\n  addSingleCellValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = this.getValueIndex(address.sheet, address.col, value);\n      ColumnIndex.addValue(valueIndex, address.row);\n    });\n  }\n  removeSingleValue(value, address) {\n    this.stats.measure(StatType.BUILD_COLUMN_INDEX, () => {\n      this.ensureRecentData(address.sheet, address.col, value);\n      const columnMap = this.getColumnMap(address.sheet, address.col);\n      if (typeof value === 'string') {\n        value = forceNormalizeString(value);\n      }\n      const valueIndex = columnMap.get(value);\n      if (!valueIndex) {\n        return;\n      }\n      const positionInIndex = findInOrderedArray(address.row, valueIndex.index);\n      if (positionInIndex > -1) {\n        valueIndex.index.splice(positionInIndex, 1);\n      }\n      if (valueIndex.index.length === 0) {\n        columnMap.delete(value);\n      }\n      if (columnMap.size === 0) {\n        delete this.index.get(address.sheet)[address.col]; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n      }\n    });\n  }\n\n  addRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowStart, rowsSpan.numberOfRows);\n  }\n  removeRows(col, rowsSpan, value) {\n    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);\n    ColumnIndex.removeRowsFromValues(valueIndex, rowsSpan);\n    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowEnd + 1, -rowsSpan.numberOfRows);\n  }\n  static addValue(valueIndex, rowNumber) {\n    const rowIndex = findInOrderedArray(rowNumber, valueIndex.index, 'lowerBound');\n    const isRowNumberAlreadyInIndex = valueIndex.index[rowIndex] === rowNumber;\n    if (!isRowNumberAlreadyInIndex) {\n      valueIndex.index.splice(rowIndex + 1, 0, rowNumber);\n    }\n  }\n  static removeRowsFromValues(valueIndex, rowsSpan) {\n    const start = findInOrderedArray(rowsSpan.rowStart, valueIndex.index, 'upperBound');\n    const end = findInOrderedArray(rowsSpan.rowEnd, valueIndex.index, 'lowerBound');\n    const isFoundSpanValid = start > -1 && end > -1 && start <= end && valueIndex.index[start] <= rowsSpan.rowEnd;\n    if (isFoundSpanValid) {\n      valueIndex.index.splice(start, end - start + 1);\n    }\n  }\n  static shiftRows(valueIndex, afterRow, numberOfRows) {\n    const positionInIndex = findInOrderedArray(afterRow, valueIndex.index, 'upperBound');\n    if (positionInIndex === -1) {\n      return;\n    }\n    for (let i = positionInIndex; i < valueIndex.index.length; ++i) {\n      valueIndex.index[i] += numberOfRows;\n    }\n  }\n}\n/*\r\n * Returns:\r\n * - index of the key, if the key exists in the array,\r\n * - index of the lower/upper bound (depending on handlingMisses parameter) otherwise.\r\n * Assumption: The array is ordered ascending and contains no repetitions.\r\n */\nexport function findInOrderedArray(key, values, handlingMisses = 'upperBound') {\n  let start = 0;\n  let end = values.length - 1;\n  while (start <= end) {\n    const center = Math.floor((start + end) / 2);\n    if (key > values[center]) {\n      start = center + 1;\n    } else if (key < values[center]) {\n      end = center - 1;\n    } else {\n      return center;\n    }\n  }\n  const foundIndex = handlingMisses === 'lowerBound' ? end : start;\n  const isIndexInRange = foundIndex >= 0 && foundIndex <= values.length;\n  return isIndexInRange ? foundIndex : -1;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}