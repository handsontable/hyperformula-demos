{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\n/**\r\n * Interpreter plugin containing text-specific functions\r\n */\nexport class TextPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to CONCATENATE(value1, [value2, ...])\r\n   *\r\n   * Concatenates provided arguments to one string.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  concatenate(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CONCATENATE'), (...args) => {\n      return ''.concat(...args);\n    });\n  }\n  /**\r\n   * Corresponds to SPLIT(string, index)\r\n   *\r\n   * Splits provided string using space separator and returns chunk at zero-based position specified by second argument\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  split(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SPLIT'), (stringToSplit, indexToUse) => {\n      const splittedString = stringToSplit.split(' ');\n      if (indexToUse >= splittedString.length || indexToUse < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.IndexBounds);\n      }\n      return splittedString[indexToUse];\n    });\n  }\n  len(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LEN'), arg => {\n      return arg.length;\n    });\n  }\n  lower(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LOWER'), arg => {\n      return arg.toLowerCase();\n    });\n  }\n  trim(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TRIM'), arg => {\n      return arg.replace(/^ +| +$/g, '').replace(/ +/g, ' ');\n    });\n  }\n  proper(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PROPER'), arg => {\n      return arg.replace(/\\p{L}+/gu, word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase());\n    });\n  }\n  clean(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CLEAN'), arg => {\n      // eslint-disable-next-line no-control-regex\n      return arg.replace(/[\\u0000-\\u001F]/g, '');\n    });\n  }\n  exact(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EXACT'), (left, right) => {\n      return left === right;\n    });\n  }\n  rept(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('REPT'), (text, count) => {\n      if (count < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NegativeCount);\n      }\n      return text.repeat(count);\n    });\n  }\n  right(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('RIGHT'), (text, length) => {\n      if (length < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);\n      } else if (length === 0) {\n        return '';\n      }\n      return text.slice(-length);\n    });\n  }\n  left(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LEFT'), (text, length) => {\n      if (length < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);\n      }\n      return text.slice(0, length);\n    });\n  }\n  mid(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MID'), (text, startPosition, numberOfChars) => {\n      if (startPosition < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (numberOfChars < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);\n      }\n      return text.substring(startPosition - 1, startPosition + numberOfChars - 1);\n    });\n  }\n  replace(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('REPLACE'), (text, startPosition, numberOfChars, newText) => {\n      if (startPosition < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (numberOfChars < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NegativeLength);\n      }\n      return text.substring(0, startPosition - 1) + newText + text.substring(startPosition + numberOfChars - 1);\n    });\n  }\n  search(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SEARCH'), (pattern, text, startIndex) => {\n      if (startIndex < 1 || startIndex > text.length) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LengthBounds);\n      }\n      const normalizedText = text.substring(startIndex - 1).toLowerCase();\n      let index;\n      if (this.arithmeticHelper.requiresRegex(pattern)) {\n        index = this.arithmeticHelper.searchString(pattern, normalizedText);\n      } else {\n        index = normalizedText.indexOf(pattern.toLowerCase());\n      }\n      index = index + startIndex;\n      return index > 0 ? index : new CellError(ErrorType.VALUE, ErrorMessage.PatternNotFound);\n    });\n  }\n  substitute(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SUBSTITUTE'), (text, oldText, newText, occurrence) => {\n      const oldTextRegexp = new RegExp(oldText, 'g');\n      if (occurrence === undefined) {\n        return text.replace(oldTextRegexp, newText);\n      }\n      if (occurrence < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      let match;\n      let i = 0;\n      while ((match = oldTextRegexp.exec(text)) !== null) {\n        if (occurrence === ++i) {\n          return text.substring(0, match.index) + newText + text.substring(oldTextRegexp.lastIndex);\n        }\n      }\n      return text;\n    });\n  }\n  find(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FIND'), (pattern, text, startIndex) => {\n      if (startIndex < 1 || startIndex > text.length) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.IndexBounds);\n      }\n      const shiftedText = text.substring(startIndex - 1);\n      const index = shiftedText.indexOf(pattern) + startIndex;\n      return index > 0 ? index : new CellError(ErrorType.VALUE, ErrorMessage.PatternNotFound);\n    });\n  }\n  t(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T'), arg => {\n      if (arg instanceof CellError) {\n        return arg;\n      }\n      return typeof arg === 'string' ? arg : '';\n    });\n  }\n  upper(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('UPPER'), arg => {\n      return arg.toUpperCase();\n    });\n  }\n}\nTextPlugin.implementedFunctions = {\n  'CONCATENATE': {\n    method: 'concatenate',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    repeatLastArgs: 1,\n    expandRanges: true\n  },\n  'EXACT': {\n    method: 'exact',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'SPLIT': {\n    method: 'split',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'LEN': {\n    method: 'len',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'LOWER': {\n    method: 'lower',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'MID': {\n    method: 'mid',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'TRIM': {\n    method: 'trim',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'T': {\n    method: 't',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'PROPER': {\n    method: 'proper',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'CLEAN': {\n    method: 'clean',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'REPT': {\n    method: 'rept',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'RIGHT': {\n    method: 'right',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'LEFT': {\n    method: 'left',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'REPLACE': {\n    method: 'replace',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'SEARCH': {\n    method: 'search',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'SUBSTITUTE': {\n    method: 'substitute',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }]\n  },\n  'FIND': {\n    method: 'find',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.STRING\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'UPPER': {\n    method: 'upper',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}