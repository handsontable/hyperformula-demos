{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AliasAlreadyExisting, FunctionPluginValidationError, ProtectedFunctionError } from '../errors';\nimport { HyperFormula } from '../HyperFormula';\nimport { VersionPlugin } from './plugin/VersionPlugin';\nfunction validateAndReturnMetadataFromName(functionId, plugin) {\n  var _a;\n  let entry = plugin.implementedFunctions[functionId];\n  const key = (_a = plugin.aliases) === null || _a === void 0 ? void 0 : _a[functionId];\n  if (key !== undefined) {\n    if (entry !== undefined) {\n      throw new AliasAlreadyExisting(functionId, plugin.name);\n    }\n    entry = plugin.implementedFunctions[key];\n  }\n  if (entry === undefined) {\n    throw FunctionPluginValidationError.functionNotDeclaredInPlugin(functionId, plugin.name);\n  }\n  return entry;\n}\nexport class FunctionRegistry {\n  constructor(config) {\n    this.config = config;\n    this.functions = new Map();\n    this.arraySizeFunctions = new Map();\n    this.volatileFunctions = new Set();\n    this.arrayFunctions = new Set();\n    this.structuralChangeFunctions = new Set();\n    this.functionsWhichDoesNotNeedArgumentsToBeComputed = new Set();\n    this.functionsMetadata = new Map();\n    this.doesFunctionNeedArgumentToBeComputed = functionId => this.functionsWhichDoesNotNeedArgumentsToBeComputed.has(functionId);\n    this.isFunctionVolatile = functionId => this.volatileFunctions.has(functionId);\n    this.isArrayFunction = functionId => this.arrayFunctions.has(functionId);\n    this.isFunctionDependentOnSheetStructureChange = functionId => this.structuralChangeFunctions.has(functionId);\n    if (config.functionPlugins.length > 0) {\n      this.instancePlugins = new Map();\n      for (const plugin of config.functionPlugins) {\n        FunctionRegistry.loadPluginFunctions(plugin, this.instancePlugins);\n      }\n    } else {\n      this.instancePlugins = new Map(FunctionRegistry.plugins);\n    }\n    for (const [functionId, plugin] of FunctionRegistry.protectedFunctions()) {\n      FunctionRegistry.loadFunctionUnprotected(plugin, functionId, this.instancePlugins);\n    }\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      this.categorizeFunction(functionId, validateAndReturnMetadataFromName(functionId, plugin));\n    }\n  }\n  static registerFunctionPlugin(plugin, translations) {\n    this.loadPluginFunctions(plugin, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static registerFunction(functionId, plugin, translations) {\n    this.loadPluginFunction(plugin, functionId, this.plugins);\n    if (translations !== undefined) {\n      this.loadTranslations(translations);\n    }\n  }\n  static unregisterFunction(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotUnregisterFunctionWithId(functionId);\n    }\n    this.plugins.delete(functionId);\n  }\n  static unregisterFunctionPlugin(plugin) {\n    for (const protectedPlugin of this.protectedPlugins()) {\n      if (protectedPlugin === plugin) {\n        throw ProtectedFunctionError.cannotUnregisterProtectedPlugin();\n      }\n    }\n    for (const [functionId, registeredPlugin] of this.plugins.entries()) {\n      if (registeredPlugin === plugin) {\n        this.plugins.delete(functionId);\n      }\n    }\n  }\n  static unregisterAll() {\n    this.plugins.clear();\n  }\n  static getRegisteredFunctionIds() {\n    return [...Array.from(this.plugins.keys()), ...Array.from(this._protectedPlugins.keys())];\n  }\n  static getPlugins() {\n    return Array.from(new Set(this.plugins.values()).values());\n  }\n  static getFunctionPlugin(functionId) {\n    if (this.functionIsProtected(functionId)) {\n      return undefined;\n    } else {\n      return this.plugins.get(functionId);\n    }\n  }\n  static functionIsProtected(functionId) {\n    return this._protectedPlugins.has(functionId);\n  }\n  static loadTranslations(translations) {\n    const registeredLanguages = new Set(HyperFormula.getRegisteredLanguagesCodes());\n    Object.keys(translations).forEach(code => {\n      if (registeredLanguages.has(code)) {\n        HyperFormula.getLanguage(code).extendFunctions(translations[code]);\n      }\n    });\n  }\n  static loadPluginFunctions(plugin, registry) {\n    Object.keys(plugin.implementedFunctions).forEach(functionName => {\n      this.loadPluginFunction(plugin, functionName, registry);\n    });\n    if (plugin.aliases !== undefined) {\n      Object.keys(plugin.aliases).forEach(functionName => {\n        this.loadPluginFunction(plugin, functionName, registry);\n      });\n    }\n  }\n  static loadPluginFunction(plugin, functionId, registry) {\n    if (this.functionIsProtected(functionId)) {\n      throw ProtectedFunctionError.cannotRegisterFunctionWithId(functionId);\n    } else {\n      this.loadFunctionUnprotected(plugin, functionId, registry);\n    }\n  }\n  static loadFunctionUnprotected(plugin, functionId, registry) {\n    const methodName = validateAndReturnMetadataFromName(functionId, plugin).method;\n    if (Object.prototype.hasOwnProperty.call(plugin.prototype, methodName)) {\n      registry.set(functionId, plugin);\n    } else {\n      throw FunctionPluginValidationError.functionMethodNotFound(methodName, plugin.name);\n    }\n  }\n  static *protectedFunctions() {\n    for (const [functionId, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield [functionId, plugin];\n      }\n    }\n  }\n  static *protectedPlugins() {\n    for (const [, plugin] of this._protectedPlugins) {\n      if (plugin !== undefined) {\n        yield plugin;\n      }\n    }\n  }\n  initializePlugins(interpreter) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const instances = [];\n    for (const [functionId, plugin] of this.instancePlugins.entries()) {\n      let foundPluginInstance = instances.find(pluginInstance => pluginInstance instanceof plugin);\n      if (foundPluginInstance === undefined) {\n        foundPluginInstance = new plugin(interpreter);\n        instances.push(foundPluginInstance);\n      }\n      const metadata = validateAndReturnMetadataFromName(functionId, plugin);\n      const methodName = metadata.method;\n      this.functions.set(functionId, [methodName, foundPluginInstance]);\n      const arraySizeMethodName = metadata.arraySizeMethod;\n      if (arraySizeMethodName !== undefined) {\n        this.arraySizeFunctions.set(functionId, [arraySizeMethodName, foundPluginInstance]);\n      }\n    }\n  }\n  getFunctionPlugin(functionId) {\n    if (FunctionRegistry.functionIsProtected(functionId)) {\n      return undefined;\n    }\n    return this.instancePlugins.get(functionId);\n  }\n  getFunction(functionId) {\n    const pluginEntry = this.functions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getArraySizeFunction(functionId) {\n    const pluginEntry = this.arraySizeFunctions.get(functionId);\n    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {\n      const [pluginArraySizeFunction, pluginInstance] = pluginEntry;\n      return (ast, state) => pluginInstance[pluginArraySizeFunction](ast, state);\n    } else {\n      return undefined;\n    }\n  }\n  getMetadata(functionId) {\n    return this.functionsMetadata.get(functionId);\n  }\n  getPlugins() {\n    const plugins = new Set();\n    for (const [functionId, plugin] of this.instancePlugins) {\n      if (!FunctionRegistry.functionIsProtected(functionId)) {\n        plugins.add(plugin);\n      }\n    }\n    return Array.from(plugins);\n  }\n  getRegisteredFunctionIds() {\n    return Array.from(this.functions.keys());\n  }\n  categorizeFunction(functionId, functionMetadata) {\n    if (functionMetadata.isVolatile) {\n      this.volatileFunctions.add(functionId);\n    }\n    if (functionMetadata.arrayFunction) {\n      this.arrayFunctions.add(functionId);\n    }\n    if (functionMetadata.doesNotNeedArgumentsToBeComputed) {\n      this.functionsWhichDoesNotNeedArgumentsToBeComputed.add(functionId);\n    }\n    if (functionMetadata.isDependentOnSheetStructureChange) {\n      this.structuralChangeFunctions.add(functionId);\n    }\n    this.functionsMetadata.set(functionId, functionMetadata);\n  }\n}\nFunctionRegistry.plugins = new Map();\nFunctionRegistry._protectedPlugins = new Map([['VERSION', VersionPlugin], ['OFFSET', undefined]]);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}