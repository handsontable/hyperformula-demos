{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from '../../Cell';\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Array to store addresses, having minimal memory usage for dense sheets and constant set/lookup.\r\n */\nexport class DenseStrategy {\n  /**\r\n   * @param width - width of the stored sheet\r\n   * @param height - height of the stored sheet\r\n   */\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.mapping = new Array(height);\n    for (let i = 0; i < height; i++) {\n      this.mapping[i] = new Array(width);\n    }\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    return this.getCellVertex(address.col, address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    const rowMapping = this.mapping[address.row];\n    if (!rowMapping) {\n      this.mapping[address.row] = new Array(this.width);\n    }\n    this.mapping[address.row][address.col] = newVertex;\n  }\n  /** @inheritDoc */\n  has(address) {\n    const row = this.mapping[address.row];\n    if (!row) {\n      return false;\n    }\n    return !!row[address.col];\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    if (this.mapping[address.row] !== undefined) {\n      delete this.mapping[address.row][address.col];\n    }\n  }\n  addRows(row, numberOfRows) {\n    const newRows = [];\n    for (let i = 0; i < numberOfRows; i++) {\n      newRows.push(new Array(this.width));\n    }\n    this.mapping.splice(row, 0, ...newRows);\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    for (let i = 0; i < this.height; i++) {\n      this.mapping[i].splice(column, 0, ...new Array(numberOfColumns));\n    }\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.splice(removedRows.rowStart, removedRows.numberOfRows);\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    for (let i = 0; i < this.height; i++) {\n      this.mapping[i].splice(removedColumns.columnStart, removedColumns.numberOfColumns);\n    }\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    for (let y = 0; y < this.height; ++y) {\n      const vertex = this.getCellVertex(column, y);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRow(row) {\n    for (let x = 0; x < this.width; ++x) {\n      const vertex = this.getCellVertex(x, row);\n      if (vertex) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (let x = 0; x < this.width; ++x) {\n      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(rowsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {\n      for (let y = 0; y < this.height; ++y) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield [simpleCellAddress(columnsSpan.sheet, x, y), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (let y = 0; y < this.height; ++y) {\n      for (let x = 0; x < this.width; ++x) {\n        const vertex = this.getCellVertex(x, y);\n        if (vertex) {\n          yield vertex;\n        }\n      }\n    }\n  }\n  getCellVertex(x, y) {\n    var _a;\n    return (_a = this.mapping[y]) === null || _a === void 0 ? void 0 : _a[x];\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}