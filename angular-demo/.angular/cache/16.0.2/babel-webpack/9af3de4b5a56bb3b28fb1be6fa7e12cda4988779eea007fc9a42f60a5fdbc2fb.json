{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class MathPlugin extends FunctionPlugin {\n  fact(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FACT'), arg => {\n      arg = Math.trunc(arg);\n      let ret = 1;\n      for (let i = 1; i <= arg; i++) {\n        ret *= i;\n      }\n      return ret;\n    });\n  }\n  factdouble(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FACTDOUBLE'), arg => {\n      arg = Math.trunc(arg);\n      let ret = 1;\n      for (let i = arg; i >= 1; i -= 2) {\n        ret *= i;\n      }\n      return ret;\n    });\n  }\n  combin(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('COMBIN'), (n, m) => {\n      if (m > n) {\n        return new CellError(ErrorType.NUM, ErrorMessage.WrongOrder);\n      }\n      n = Math.trunc(n);\n      m = Math.trunc(m);\n      return combin(n, m);\n    });\n  }\n  combina(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('COMBINA'), (n, m) => {\n      n = Math.trunc(n);\n      m = Math.trunc(m);\n      if (n + m - 1 >= 1030) {\n        //Product #2 does not enforce this\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      if (n === 0 && m === 0) {\n        return 1;\n      }\n      return combin(n + m - 1, m);\n    });\n  }\n  gcd(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GCD'), (...args) => {\n      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);\n      if (processedArgs instanceof CellError) {\n        return processedArgs;\n      }\n      let ret = 0;\n      for (const val of processedArgs) {\n        if (val < 0) {\n          return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n        }\n        ret = binaryGCD(ret, Math.trunc(val));\n      }\n      if (ret > Number.MAX_SAFE_INTEGER) {\n        //inconsistency with product #1\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      return ret;\n    });\n  }\n  lcm(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LCM'), (...args) => {\n      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);\n      if (processedArgs instanceof CellError) {\n        return processedArgs;\n      }\n      let ret = 1;\n      for (const val of processedArgs) {\n        if (val < 0) {\n          return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n        }\n        ret = binaryLCM(ret, Math.trunc(val));\n      }\n      if (ret > Number.MAX_SAFE_INTEGER) {\n        //inconsistency with product #1\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      return ret;\n    });\n  }\n  mround(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MROUND'), (nom, denom) => {\n      if (denom === 0) {\n        return 0;\n      }\n      if (nom > 0 && denom < 0 || nom < 0 && denom > 0) {\n        return new CellError(ErrorType.NUM, ErrorMessage.DistinctSigns);\n      }\n      return Math.round(nom / denom) * denom;\n    });\n  }\n  multinomial(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MULTINOMIAL'), (...args) => {\n      let n = 0;\n      let ans = 1;\n      for (let arg of args) {\n        if (arg < 0) {\n          return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n        }\n        arg = Math.trunc(arg);\n        for (let i = 1; i <= arg; i++) {\n          ans *= (n + i) / i;\n        }\n        n += arg;\n      }\n      return Math.round(ans);\n    });\n  }\n  quotient(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('QUOTIENT'), (nom, denom) => {\n      if (denom === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      return Math.trunc(nom / denom);\n    });\n  }\n  seriessum(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SERIESSUM'), (x, n, m, range) => {\n      const coefs = this.arithmeticHelper.manyToOnlyNumbersDropNulls(range.valuesFromTopLeftCorner());\n      if (coefs instanceof CellError) {\n        return coefs;\n      }\n      let ret = 0;\n      coefs.reverse();\n      for (const coef of coefs) {\n        ret *= Math.pow(x, m);\n        ret += coef;\n      }\n      return ret * Math.pow(x, n);\n    });\n  }\n  sign(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SIGN'), arg => {\n      if (arg > 0) {\n        return 1;\n      } else if (arg < 0) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n  }\n  sumx2my2(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SUMX2MY2'), (rangeX, rangeY) => {\n      const valsX = rangeX.valuesFromTopLeftCorner();\n      const valsY = rangeY.valuesFromTopLeftCorner();\n      if (valsX.length !== valsY.length) {\n        return new CellError(ErrorType.NA, ErrorMessage.EqualLength);\n      }\n      const n = valsX.length;\n      let ret = 0;\n      for (let i = 0; i < n; i++) {\n        const valX = valsX[i];\n        const valY = valsY[i];\n        if (valX instanceof CellError) {\n          return valX;\n        }\n        if (valY instanceof CellError) {\n          return valY;\n        }\n        if (typeof valX === 'number' && typeof valY === 'number') {\n          ret += Math.pow(valX, 2) - Math.pow(valY, 2);\n        }\n      }\n      return ret;\n    });\n  }\n  sumx2py2(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SUMX2PY2'), (rangeX, rangeY) => {\n      const valsX = rangeX.valuesFromTopLeftCorner();\n      const valsY = rangeY.valuesFromTopLeftCorner();\n      if (valsX.length !== valsY.length) {\n        return new CellError(ErrorType.NA, ErrorMessage.EqualLength);\n      }\n      const n = valsX.length;\n      let ret = 0;\n      for (let i = 0; i < n; i++) {\n        const valX = valsX[i];\n        const valY = valsY[i];\n        if (valX instanceof CellError) {\n          return valX;\n        }\n        if (valY instanceof CellError) {\n          return valY;\n        }\n        if (typeof valX === 'number' && typeof valY === 'number') {\n          ret += Math.pow(valX, 2) + Math.pow(valY, 2);\n        }\n      }\n      return ret;\n    });\n  }\n  sumxmy2(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SUMXMY2'), (rangeX, rangeY) => {\n      const valsX = rangeX.valuesFromTopLeftCorner();\n      const valsY = rangeY.valuesFromTopLeftCorner();\n      if (valsX.length !== valsY.length) {\n        return new CellError(ErrorType.NA, ErrorMessage.EqualLength);\n      }\n      const n = valsX.length;\n      let ret = 0;\n      for (let i = 0; i < n; i++) {\n        const valX = valsX[i];\n        const valY = valsY[i];\n        if (valX instanceof CellError) {\n          return valX;\n        }\n        if (valY instanceof CellError) {\n          return valY;\n        }\n        if (typeof valX === 'number' && typeof valY === 'number') {\n          ret += Math.pow(valX - valY, 2);\n        }\n      }\n      return ret;\n    });\n  }\n}\nMathPlugin.implementedFunctions = {\n  'FACT': {\n    method: 'fact',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 170\n    }]\n  },\n  'FACTDOUBLE': {\n    method: 'factdouble',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 288\n    }]\n  },\n  'COMBIN': {\n    method: 'combin',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      lessThan: 1030\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'COMBINA': {\n    method: 'combina',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'GCD': {\n    method: 'gcd',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'LCM': {\n    method: 'lcm',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MROUND': {\n    method: 'mround',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'MULTINOMIAL': {\n    method: 'multinomial',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }],\n    repeatLastArgs: 1,\n    expandRanges: true\n  },\n  'QUOTIENT': {\n    method: 'quotient',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'SERIESSUM': {\n    method: 'seriessum',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }]\n  },\n  'SIGN': {\n    method: 'sign',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'SUMX2MY2': {\n    method: 'sumx2my2',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }]\n  },\n  'SUMX2PY2': {\n    method: 'sumx2py2',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }]\n  },\n  'SUMXMY2': {\n    method: 'sumxmy2',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }]\n  }\n};\nfunction combin(n, m) {\n  if (2 * m > n) {\n    m = n - m;\n  }\n  let ret = 1;\n  for (let i = 1; i <= m; i++) {\n    ret *= (n - m + i) / i;\n  }\n  return Math.round(ret);\n}\nfunction binaryGCD(a, b) {\n  if (a < b) {\n    [a, b] = [b, a];\n  }\n  while (b > 0) {\n    [a, b] = [b, a % b];\n  }\n  return a;\n}\nfunction binaryLCM(a, b) {\n  if (a === 0 || b === 0) {\n    return 0;\n  }\n  return a * (b / binaryGCD(a, b));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}