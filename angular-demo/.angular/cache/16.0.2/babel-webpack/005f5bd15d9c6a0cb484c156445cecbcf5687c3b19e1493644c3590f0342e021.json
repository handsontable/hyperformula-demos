{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { EmbeddedActionsParser, EMPTY_ALT, Lexer, tokenMatcher } from 'chevrotain';\nimport { CellError, ErrorType, simpleCellAddress } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { cellAddressFromString, columnAddressFromString, rowAddressFromString } from './addressRepresentationConverters';\nimport { AstNodeType, buildArrayAst, buildCellErrorAst, buildCellRangeAst, buildCellReferenceAst, buildColumnRangeAst, buildConcatenateOpAst, buildDivOpAst, buildEmptyArgAst, buildEqualsOpAst, buildErrorWithRawInputAst, buildGreaterThanOpAst, buildGreaterThanOrEqualOpAst, buildLessThanOpAst, buildLessThanOrEqualOpAst, buildMinusOpAst, buildMinusUnaryOpAst, buildNamedExpressionAst, buildNotEqualOpAst, buildNumberAst, buildParenthesisAst, buildParsingErrorAst, buildPercentOpAst, buildPlusOpAst, buildPlusUnaryOpAst, buildPowerOpAst, buildProcedureAst, buildRowRangeAst, buildStringAst, buildTimesOpAst, parsingError, ParsingErrorType, RangeSheetReferenceType } from './Ast';\nimport { CellAddress, CellReferenceType } from './CellAddress';\nimport { AdditionOp, ArrayLParen, ArrayRParen, BooleanOp, CellReference, ColumnRange, ConcatenateOp, DivOp, EqualsOp, ErrorLiteral, GreaterThanOp, GreaterThanOrEqualOp, LessThanOp, LessThanOrEqualOp, LParen, MinusOp, MultiplicationOp, NamedExpression, NotEqualOp, PercentOp, PlusOp, PowerOp, ProcedureName, RangeSeparator, RowRange, RParen, StringLiteral, TimesOp } from './LexerConfig';\n/**\r\n * LL(k) formula parser described using Chevrotain DSL\r\n *\r\n * It is equivalent to the grammar below:\r\n *\r\n * F -> '=' E <br/>\r\n * B -> K < B | K >= B ... | K <br/>\r\n * K -> E & K | E <br/>\r\n * E -> M + E | M - E | M <br/>\r\n * M -> W * M | W / M | W <br/>\r\n * W -> C * W | C <br/>\r\n * C -> N | R | O | A | P | num <br/>\r\n * N -> '(' E ')' <br/>\r\n * R -> A:OFFSET(..) | A:A <br/>\r\n * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>\r\n * A -> A1 | $A1 | A$1 | $A$1 <br/>\r\n * P -> SUM(..) <br/>\r\n */\nexport class FormulaParser extends EmbeddedActionsParser {\n  constructor(lexerConfig, sheetMapping) {\n    super(lexerConfig.allTokens, {\n      outputCst: false,\n      maxLookahead: 7\n    });\n    this.booleanExpressionOrEmpty = this.RULE('booleanExpressionOrEmpty', () => {\n      return this.OR([{\n        ALT: () => this.SUBRULE(this.booleanExpression)\n      }, {\n        ALT: EMPTY_ALT(buildEmptyArgAst())\n      }]);\n    });\n    /**\r\n     * Rule for procedure expressions: SUM(1,A1)\r\n     */\n    this.procedureExpression = this.RULE('procedureExpression', () => {\n      var _a;\n      const procedureNameToken = this.CONSUME(ProcedureName);\n      const procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);\n      const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;\n      const args = [];\n      let argument = this.SUBRULE(this.booleanExpressionOrEmpty);\n      this.MANY(() => {\n        var _a;\n        const separator = this.CONSUME(this.lexerConfig.ArgSeparator);\n        if (argument.type === AstNodeType.EMPTY) {\n          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;\n        }\n        args.push(argument);\n        argument = this.SUBRULE2(this.booleanExpressionOrEmpty);\n      });\n      args.push(argument);\n      if (args.length === 1 && args[0].type === AstNodeType.EMPTY) {\n        args.length = 0;\n      }\n      const rParenToken = this.CONSUME(RParen);\n      return buildProcedureAst(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.namedExpressionExpression = this.RULE('namedExpressionExpression', () => {\n      const name = this.CONSUME(NamedExpression);\n      return buildNamedExpressionAst(name.image, name.leadingWhitespace);\n    });\n    /**\r\n     * Rule for OFFSET() function expression\r\n     */\n    this.offsetProcedureExpression = this.RULE('offsetProcedureExpression', () => {\n      const args = [];\n      this.CONSUME(this.lexerConfig.OffsetProcedureName);\n      this.CONSUME(LParen);\n      this.MANY_SEP({\n        SEP: this.lexerConfig.ArgSeparator,\n        DEF: () => {\n          args.push(this.SUBRULE(this.booleanExpression));\n        }\n      });\n      this.CONSUME(RParen);\n      return this.handleOffsetHeuristic(args);\n    });\n    /**\r\n     * Rule for column range, e.g. A:B, Sheet1!A:B, Sheet1!A:Sheet1!B\r\n     */\n    this.columnRangeExpression = this.RULE('columnRangeExpression', () => {\n      const range = this.CONSUME(ColumnRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => columnAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildColumnRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for row range, e.g. 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2\r\n     */\n    this.rowRangeExpression = this.RULE('rowRangeExpression', () => {\n      const range = this.CONSUME(RowRange);\n      const [startImage, endImage] = range.image.split(':');\n      const firstAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, startImage, this.formulaAddress));\n      const secondAddress = this.ACTION(() => rowAddressFromString(this.sheetMapping, endImage, this.formulaAddress));\n      if (firstAddress === undefined || secondAddress === undefined) {\n        return buildCellErrorAst(new CellError(ErrorType.REF));\n      }\n      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(range.image, new CellError(ErrorType.NAME), range.leadingWhitespace);\n      }\n      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n        return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n      }\n      const {\n        firstEnd,\n        secondEnd,\n        sheetRefType\n      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n      return buildRowRangeAst(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);\n    });\n    /**\r\n     * Rule for cell reference expression (e.g. A1, $A1, A$1, $A$1, $Sheet42!A$17)\r\n     */\n    this.cellReference = this.RULE('cellReference', () => {\n      const cell = this.CONSUME(CellReference);\n      const address = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, cell.image, this.formulaAddress);\n      });\n      if (address === undefined) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.REF), cell.leadingWhitespace);\n      } else if (address.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return buildErrorWithRawInputAst(cell.image, new CellError(ErrorType.NAME), cell.leadingWhitespace);\n      } else {\n        return buildCellReferenceAst(address, cell.leadingWhitespace);\n      }\n    });\n    /**\r\n     * Rule for end range reference expression with additional checks considering range start\r\n     */\n    this.endRangeReference = this.RULE('endRangeReference', start => {\n      var _a;\n      const end = this.CONSUME(CellReference);\n      const startAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n      });\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (startAddress === undefined || endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.REF), start.leadingWhitespace);\n        });\n      } else if (startAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {\n        return this.ACTION(() => {\n          return buildErrorWithRawInputAst(`${start.image}:${end.image}`, new CellError(ErrorType.NAME), start.leadingWhitespace);\n        });\n      }\n      return this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeExpression = this.RULE('endOfRangeExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          var _a;\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          const startAddress = this.ACTION(() => {\n            return cellAddressFromString(this.sheetMapping, start.image, this.formulaAddress);\n          });\n          if (startAddress === undefined) {\n            return buildCellErrorAst(new CellError(ErrorType.REF));\n          }\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(startAddress, offsetProcedure.reference, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for cell ranges (e.g. A1:B$3, A1:OFFSET())\r\n     */\n    this.cellRangeExpression = this.RULE('cellRangeExpression', () => {\n      const start = this.CONSUME(CellReference);\n      this.CONSUME2(RangeSeparator);\n      return this.SUBRULE(this.endOfRangeExpression, {\n        ARGS: [start]\n      });\n    });\n    /**\r\n     * Rule for end range reference expression starting with offset procedure with additional checks considering range start\r\n     */\n    this.endRangeWithOffsetStartReference = this.RULE('endRangeWithOffsetStartReference', start => {\n      const end = this.CONSUME(CellReference);\n      const endAddress = this.ACTION(() => {\n        return cellAddressFromString(this.sheetMapping, end.image, this.formulaAddress);\n      });\n      if (endAddress === undefined) {\n        return this.ACTION(() => {\n          return buildCellErrorAst(new CellError(ErrorType.REF));\n        });\n      }\n      return this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);\n    });\n    /**\r\n     * Rule for end of range expression\r\n     *\r\n     * End of range may be a cell reference or OFFSET() function call\r\n     */\n    this.endOfRangeWithOffsetStartExpression = this.RULE('endOfRangeWithOffsetStartExpression', start => {\n      return this.OR([{\n        ALT: () => {\n          return this.SUBRULE(this.endRangeWithOffsetStartReference, {\n            ARGS: [start]\n          });\n        }\n      }, {\n        ALT: () => {\n          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n          if (offsetProcedure.type === AstNodeType.CELL_REFERENCE) {\n            return this.buildCellRange(start.reference, offsetProcedure.reference, start.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n          }\n        }\n      }]);\n    });\n    /**\r\n     * Rule for expressions that start with the OFFSET function.\r\n     *\r\n     * The OFFSET function can occur as a cell reference, or as a part of a cell range.\r\n     * To preserve LL(k) properties, expressions that start with the OFFSET function need a separate rule.\r\n     *\r\n     * Depending on the presence of the {@link RangeSeparator}, a proper {@link Ast} node type is built.\r\n     */\n    this.offsetExpression = this.RULE('offsetExpression', () => {\n      const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);\n      let end;\n      this.OPTION(() => {\n        this.CONSUME(RangeSeparator);\n        if (offsetProcedure.type === AstNodeType.CELL_RANGE) {\n          end = this.parsingError(ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');\n        } else {\n          end = this.SUBRULE(this.endOfRangeWithOffsetStartExpression, {\n            ARGS: [offsetProcedure]\n          });\n        }\n      });\n      if (end !== undefined) {\n        return end;\n      }\n      return offsetProcedure;\n    });\n    this.insideArrayExpression = this.RULE('insideArrayExpression', () => {\n      const ret = [[]];\n      ret[ret.length - 1].push(this.SUBRULE(this.booleanExpression));\n      this.MANY(() => {\n        this.OR([{\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayColSeparator);\n            ret[ret.length - 1].push(this.SUBRULE2(this.booleanExpression));\n          }\n        }, {\n          ALT: () => {\n            this.CONSUME(this.lexerConfig.ArrayRowSeparator);\n            ret.push([]);\n            ret[ret.length - 1].push(this.SUBRULE3(this.booleanExpression));\n          }\n        }]);\n      });\n      return buildArrayAst(ret);\n    });\n    /**\r\n     * Rule for parenthesis expression\r\n     */\n    this.parenthesisExpression = this.RULE('parenthesisExpression', () => {\n      const lParenToken = this.CONSUME(LParen);\n      const expression = this.SUBRULE(this.booleanExpression);\n      const rParenToken = this.CONSUME(RParen);\n      return buildParenthesisAst(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);\n    });\n    this.arrayExpression = this.RULE('arrayExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const ltoken = this.CONSUME(ArrayLParen);\n          const ret = this.SUBRULE(this.insideArrayExpression);\n          const rtoken = this.CONSUME(ArrayRParen);\n          return buildArrayAst(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);\n        }\n      }, {\n        ALT: () => this.SUBRULE(this.parenthesisExpression)\n      }]);\n    });\n    this.numericStringToNumber = input => {\n      const normalized = input.replace(this.lexerConfig.decimalSeparator, '.');\n      return Number(normalized);\n    };\n    /**\r\n     * Rule for positive atomic expressions\r\n     */\n    this.positiveAtomicExpression = this.RULE('positiveAtomicExpression', () => {\n      var _a;\n      return this.OR((_a = this.atomicExpCache) !== null && _a !== void 0 ? _a : this.atomicExpCache = [{\n        ALT: () => this.SUBRULE(this.arrayExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.columnRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.rowRangeExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.offsetExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.cellReference)\n      }, {\n        ALT: () => this.SUBRULE(this.procedureExpression)\n      }, {\n        ALT: () => this.SUBRULE(this.namedExpressionExpression)\n      }, {\n        ALT: () => {\n          const number = this.CONSUME(this.lexerConfig.NumberLiteral);\n          return buildNumberAst(this.numericStringToNumber(number.image), number.leadingWhitespace);\n        }\n      }, {\n        ALT: () => {\n          const str = this.CONSUME(StringLiteral);\n          return buildStringAst(str);\n        }\n      }, {\n        ALT: () => {\n          const token = this.CONSUME(ErrorLiteral);\n          const errString = token.image.toUpperCase();\n          const errorType = this.lexerConfig.errorMapping[errString];\n          if (errorType) {\n            return buildCellErrorAst(new CellError(errorType), token.leadingWhitespace);\n          } else {\n            return this.parsingError(ParsingErrorType.ParserError, 'Unknown error literal');\n          }\n        }\n      }]);\n    });\n    this.rightUnaryOpAtomicExpression = this.RULE('rightUnaryOpAtomicExpression', () => {\n      const positiveAtomicExpression = this.SUBRULE(this.positiveAtomicExpression);\n      const percentage = this.OPTION(() => {\n        return this.CONSUME(PercentOp);\n      });\n      if (percentage) {\n        return buildPercentOpAst(positiveAtomicExpression, percentage.leadingWhitespace);\n      }\n      return positiveAtomicExpression;\n    });\n    /**\r\n     * Rule for atomic expressions, which is positive atomic expression or negation of it\r\n     */\n    this.atomicExpression = this.RULE('atomicExpression', () => {\n      return this.OR([{\n        ALT: () => {\n          const op = this.CONSUME(AdditionOp);\n          const value = this.SUBRULE(this.atomicExpression);\n          if (tokenMatcher(op, PlusOp)) {\n            return buildPlusUnaryOpAst(value, op.leadingWhitespace);\n          } else if (tokenMatcher(op, MinusOp)) {\n            return buildMinusUnaryOpAst(value, op.leadingWhitespace);\n          } else {\n            this.customParsingError = parsingError(ParsingErrorType.ParserError, 'Mismatched token type');\n            return this.customParsingError;\n          }\n        }\n      }, {\n        ALT: () => this.SUBRULE2(this.rightUnaryOpAtomicExpression)\n      }]);\n    });\n    /**\r\n     * Rule for power expression\r\n     */\n    this.powerExpression = this.RULE('powerExpression', () => {\n      let lhs = this.SUBRULE(this.atomicExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(PowerOp);\n        const rhs = this.SUBRULE2(this.atomicExpression);\n        if (tokenMatcher(op, PowerOp)) {\n          lhs = buildPowerOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for multiplication category operators (e.g. 1 * A1, 1 / A1)\r\n     */\n    this.multiplicationExpression = this.RULE('multiplicationExpression', () => {\n      let lhs = this.SUBRULE(this.powerExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(MultiplicationOp);\n        const rhs = this.SUBRULE2(this.powerExpression);\n        if (tokenMatcher(op, TimesOp)) {\n          lhs = buildTimesOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, DivOp)) {\n          lhs = buildDivOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for addition category operators (e.g. 1 + A1, 1 - A1)\r\n     */\n    this.additionExpression = this.RULE('additionExpression', () => {\n      let lhs = this.SUBRULE(this.multiplicationExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(AdditionOp);\n        const rhs = this.SUBRULE2(this.multiplicationExpression);\n        if (tokenMatcher(op, PlusOp)) {\n          lhs = buildPlusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, MinusOp)) {\n          lhs = buildMinusOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for concatenation operator expression (e.g. \"=\" & A1)\r\n     */\n    this.concatenateExpression = this.RULE('concatenateExpression', () => {\n      let lhs = this.SUBRULE(this.additionExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(ConcatenateOp);\n        const rhs = this.SUBRULE2(this.additionExpression);\n        lhs = buildConcatenateOpAst(lhs, rhs, op.leadingWhitespace);\n      });\n      return lhs;\n    });\n    /**\r\n     * Rule for boolean expression (e.g. 1 <= A1)\r\n     */\n    this.booleanExpression = this.RULE('booleanExpression', () => {\n      let lhs = this.SUBRULE(this.concatenateExpression);\n      this.MANY(() => {\n        const op = this.CONSUME(BooleanOp);\n        const rhs = this.SUBRULE2(this.concatenateExpression);\n        if (tokenMatcher(op, EqualsOp)) {\n          lhs = buildEqualsOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, NotEqualOp)) {\n          lhs = buildNotEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOp)) {\n          lhs = buildGreaterThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOp)) {\n          lhs = buildLessThanOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, GreaterThanOrEqualOp)) {\n          lhs = buildGreaterThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else if (tokenMatcher(op, LessThanOrEqualOp)) {\n          lhs = buildLessThanOrEqualOpAst(lhs, rhs, op.leadingWhitespace);\n        } else {\n          this.ACTION(() => {\n            throw Error('Operator not supported');\n          });\n        }\n      });\n      return lhs;\n    });\n    /**\r\n     * Entry rule\r\n     */\n    this.formula = this.RULE('formula', () => {\n      this.CONSUME(EqualsOp);\n      return this.SUBRULE(this.booleanExpression);\n    });\n    this.lexerConfig = lexerConfig;\n    this.sheetMapping = sheetMapping;\n    this.formulaAddress = simpleCellAddress(0, 0, 0);\n    this.performSelfAnalysis();\n  }\n  /**\r\n   * Parses tokenized formula and builds abstract syntax tree\r\n   *\r\n   * @param {ExtendedToken[]} tokens - tokenized formula\r\n   * @param {SimpleCellAddress} formulaAddress - address of the cell in which formula is located\r\n   */\n  parseFromTokens(tokens, formulaAddress) {\n    this.input = tokens;\n    let ast = this.formulaWithContext(formulaAddress);\n    let errors = [];\n    if (this.customParsingError) {\n      errors.push(this.customParsingError);\n    }\n    errors = errors.concat(this.errors.map(e => ({\n      type: ParsingErrorType.ParserError,\n      message: e.message\n    })));\n    if (errors.length > 0) {\n      ast = buildParsingErrorAst();\n    }\n    return {\n      ast,\n      errors\n    };\n  }\n  reset() {\n    super.reset();\n    this.customParsingError = undefined;\n  }\n  /**\r\n   * Entry rule wrapper that sets formula address\r\n   *\r\n   * @param {SimpleCellAddress} address - address of the cell in which formula is located\r\n   */\n  formulaWithContext(address) {\n    this.formulaAddress = address;\n    return this.formula();\n  }\n  buildCellRange(firstAddress, secondAddress, leadingWhitespace) {\n    if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {\n      return this.parsingError(ParsingErrorType.ParserError, 'Malformed range expression');\n    }\n    const {\n      firstEnd,\n      secondEnd,\n      sheetRefType\n    } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);\n    return buildCellRangeAst(firstEnd, secondEnd, sheetRefType, leadingWhitespace);\n  }\n  static fixSheetIdsForRangeEnds(firstEnd, secondEnd) {\n    const sheetRefType = FormulaParser.rangeSheetReferenceType(firstEnd.sheet, secondEnd.sheet);\n    const secondEndFixed = firstEnd.sheet !== undefined && secondEnd.sheet === undefined ? secondEnd.withSheet(firstEnd.sheet) : secondEnd;\n    return {\n      firstEnd,\n      secondEnd: secondEndFixed,\n      sheetRefType\n    };\n  }\n  /**\r\n   * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments\r\n   *\r\n   * @param {Ast[]} args - OFFSET function arguments\r\n   */\n  handleOffsetHeuristic(args) {\n    const cellArg = args[0];\n    if (cellArg.type !== AstNodeType.CELL_REFERENCE) {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');\n    }\n    const rowsArg = args[1];\n    let rowShift;\n    if (rowsArg.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {\n      rowShift = rowsArg.value;\n    } else if (rowsArg.type === AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = rowsArg.value.value;\n    } else if (rowsArg.type === AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {\n      rowShift = -rowsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');\n    }\n    const columnsArg = args[2];\n    let colShift;\n    if (columnsArg.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {\n      colShift = columnsArg.value;\n    } else if (columnsArg.type === AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = columnsArg.value.value;\n    } else if (columnsArg.type === AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {\n      colShift = -columnsArg.value.value;\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');\n    }\n    const heightArg = args[3];\n    let height;\n    if (heightArg === undefined) {\n      height = 1;\n    } else if (heightArg.type === AstNodeType.NUMBER) {\n      height = heightArg.value;\n      if (height < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(height)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');\n    }\n    const widthArg = args[4];\n    let width;\n    if (widthArg === undefined) {\n      width = 1;\n    } else if (widthArg.type === AstNodeType.NUMBER) {\n      width = widthArg.value;\n      if (width < 1) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');\n      } else if (!Number.isInteger(width)) {\n        return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');\n      }\n    } else {\n      return this.parsingError(ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');\n    }\n    const topLeftCorner = new CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);\n    let absoluteCol = topLeftCorner.col;\n    let absoluteRow = topLeftCorner.row;\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      absoluteRow = absoluteRow + this.formulaAddress.row;\n    }\n    if (cellArg.reference.type === CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      absoluteCol = absoluteCol + this.formulaAddress.col;\n    }\n    if (absoluteCol < 0 || absoluteRow < 0) {\n      return buildCellErrorAst(new CellError(ErrorType.REF, ErrorMessage.OutOfSheet));\n    }\n    if (width === 1 && height === 1) {\n      return buildCellReferenceAst(topLeftCorner);\n    } else {\n      const bottomRightCorner = new CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);\n      return buildCellRangeAst(topLeftCorner, bottomRightCorner, RangeSheetReferenceType.RELATIVE);\n    }\n  }\n  parsingError(type, message) {\n    this.customParsingError = parsingError(type, message);\n    return buildParsingErrorAst();\n  }\n  static rangeSheetReferenceType(start, end) {\n    if (start === undefined) {\n      return RangeSheetReferenceType.RELATIVE;\n    } else if (end === undefined) {\n      return RangeSheetReferenceType.START_ABSOLUTE;\n    } else {\n      return RangeSheetReferenceType.BOTH_ABSOLUTE;\n    }\n  }\n}\nexport class FormulaLexer {\n  constructor(lexerConfig) {\n    this.lexerConfig = lexerConfig;\n    this.lexer = new Lexer(lexerConfig.allTokens, {\n      ensureOptimizations: true\n    });\n  }\n  /**\r\n   * Returns Lexer tokens from formula string\r\n   *\r\n   * @param {string} text - string representation of a formula\r\n   */\n  tokenizeFormula(text) {\n    const lexingResult = this.lexer.tokenize(text);\n    let tokens = lexingResult.tokens;\n    tokens = this.trimTrailingWhitespaces(tokens);\n    tokens = this.skipWhitespacesInsideRanges(tokens);\n    tokens = this.skipWhitespacesBeforeArgSeparators(tokens);\n    lexingResult.tokens = tokens;\n    return lexingResult;\n  }\n  skipWhitespacesInsideRanges(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return (tokenMatcher(previous, CellReference) || tokenMatcher(previous, RangeSeparator)) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && (tokenMatcher(next, CellReference) || tokenMatcher(next, RangeSeparator));\n    });\n  }\n  skipWhitespacesBeforeArgSeparators(tokens) {\n    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {\n      return !tokenMatcher(previous, this.lexerConfig.ArgSeparator) && tokenMatcher(current, this.lexerConfig.WhiteSpace) && tokenMatcher(next, this.lexerConfig.ArgSeparator);\n    });\n  }\n  static filterTokensByNeighbors(tokens, shouldBeSkipped) {\n    if (tokens.length < 3) {\n      return tokens;\n    }\n    let i = 0;\n    const filteredTokens = [tokens[i++]];\n    while (i < tokens.length - 1) {\n      if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {\n        filteredTokens.push(tokens[i]);\n      }\n      ++i;\n    }\n    filteredTokens.push(tokens[i]);\n    return filteredTokens;\n  }\n  trimTrailingWhitespaces(tokens) {\n    if (tokens.length > 0 && tokenMatcher(tokens[tokens.length - 1], this.lexerConfig.WhiteSpace)) {\n      tokens.pop();\n    }\n    return tokens;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}