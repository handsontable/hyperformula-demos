{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { absolutizeDependencies } from './absolutizeDependencies';\nimport { CellError, ErrorType } from './Cell';\nimport { ContentChanges } from './ContentChanges';\nimport { ArrayVertex, RangeVertex } from './DependencyGraph';\nimport { FormulaVertex } from './DependencyGraph/FormulaCellVertex';\nimport { InterpreterState } from './interpreter/InterpreterState';\nimport { EmptyValue, getRawValue } from './interpreter/InterpreterValue';\nimport { SimpleRangeValue } from './SimpleRangeValue';\nimport { StatType } from './statistics';\nexport class Evaluator {\n  constructor(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch) {\n    this.config = config;\n    this.stats = stats;\n    this.interpreter = interpreter;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n  }\n  run() {\n    this.stats.start(StatType.TOP_SORT);\n    const {\n      sorted,\n      cycled\n    } = this.dependencyGraph.topSortWithScc();\n    this.stats.end(StatType.TOP_SORT);\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.recomputeFormulas(cycled, sorted);\n    });\n  }\n  partialRun(vertices) {\n    const changes = ContentChanges.empty();\n    this.stats.measure(StatType.EVALUATION, () => {\n      this.dependencyGraph.graph.getTopSortedWithSccSubgraphFrom(vertices, vertex => {\n        if (vertex instanceof FormulaVertex) {\n          const currentValue = vertex.isComputed() ? vertex.getCellValue() : undefined;\n          const newCellValue = this.recomputeFormulaVertexValue(vertex);\n          if (newCellValue !== currentValue) {\n            const address = vertex.getAddress(this.lazilyTransformingAstService);\n            changes.addChange(newCellValue, address);\n            this.columnSearch.change(getRawValue(currentValue), getRawValue(newCellValue), address);\n            return true;\n          }\n          return false;\n        } else if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n          return true;\n        } else {\n          return true;\n        }\n      }, vertex => {\n        if (vertex instanceof RangeVertex) {\n          vertex.clearCache();\n        } else if (vertex instanceof FormulaVertex) {\n          const address = vertex.getAddress(this.lazilyTransformingAstService);\n          this.columnSearch.remove(getRawValue(vertex.valueOrUndef()), address);\n          const error = new CellError(ErrorType.CYCLE, undefined, vertex);\n          vertex.setCellValue(error);\n          changes.addChange(error, address);\n        }\n      });\n    });\n    return changes;\n  }\n  runAndForget(ast, address, dependencies) {\n    const tmpRanges = [];\n    for (const dep of absolutizeDependencies(dependencies, address)) {\n      if (dep instanceof AbsoluteCellRange) {\n        const range = dep;\n        if (this.dependencyGraph.getRange(range.start, range.end) === undefined) {\n          const rangeVertex = new RangeVertex(range);\n          this.dependencyGraph.rangeMapping.setRange(rangeVertex);\n          tmpRanges.push(rangeVertex);\n        }\n      }\n    }\n    const ret = this.evaluateAstToCellValue(ast, new InterpreterState(address, this.config.useArrayArithmetic));\n    tmpRanges.forEach(rangeVertex => {\n      this.dependencyGraph.rangeMapping.removeRange(rangeVertex);\n    });\n    return ret;\n  }\n  /**\r\n   * Recalculates formulas in the topological sort order\r\n   */\n  recomputeFormulas(cycled, sorted) {\n    cycled.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        vertex.setCellValue(new CellError(ErrorType.CYCLE, undefined, vertex));\n      }\n    });\n    sorted.forEach(vertex => {\n      if (vertex instanceof FormulaVertex) {\n        const newCellValue = this.recomputeFormulaVertexValue(vertex);\n        const address = vertex.getAddress(this.lazilyTransformingAstService);\n        this.columnSearch.add(getRawValue(newCellValue), address);\n      } else if (vertex instanceof RangeVertex) {\n        vertex.clearCache();\n      }\n    });\n  }\n  recomputeFormulaVertexValue(vertex) {\n    const address = vertex.getAddress(this.lazilyTransformingAstService);\n    if (vertex instanceof ArrayVertex && (vertex.array.size.isRef || !this.dependencyGraph.isThereSpaceForArray(vertex))) {\n      return vertex.setNoSpace();\n    } else {\n      const formula = vertex.getFormula(this.lazilyTransformingAstService);\n      const newCellValue = this.evaluateAstToCellValue(formula, new InterpreterState(address, this.config.useArrayArithmetic, vertex));\n      return vertex.setCellValue(newCellValue);\n    }\n  }\n  evaluateAstToCellValue(ast, state) {\n    const interpreterValue = this.interpreter.evaluateAst(ast, state);\n    if (interpreterValue instanceof SimpleRangeValue) {\n      return interpreterValue;\n    } else if (interpreterValue === EmptyValue && this.config.evaluateNullToZero) {\n      return 0;\n    } else {\n      return interpreterValue;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}