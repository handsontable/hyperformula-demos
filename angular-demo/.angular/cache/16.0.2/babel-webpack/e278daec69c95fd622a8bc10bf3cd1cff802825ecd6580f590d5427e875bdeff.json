{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { assign, forEach, isRegExp, map, pick } from \"../../../utils/utils\";\nimport { tokenLabel } from \"../../../scan/tokens_public\";\nvar AbstractProduction = /** @class */function () {\n  function AbstractProduction(definition) {\n    this.definition = definition;\n  }\n  AbstractProduction.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    forEach(this.definition, function (prod) {\n      prod.accept(visitor);\n    });\n  };\n  return AbstractProduction;\n}();\nexport { AbstractProduction };\nvar NonTerminal = /** @class */function (_super) {\n  __extends(NonTerminal, _super);\n  function NonTerminal(options) {\n    var _this = _super.call(this, []) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  Object.defineProperty(NonTerminal.prototype, \"definition\", {\n    get: function () {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition;\n      }\n      return [];\n    },\n    set: function (definition) {\n      // immutable\n    },\n    enumerable: true,\n    configurable: true\n  });\n  NonTerminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  };\n\n  return NonTerminal;\n}(AbstractProduction);\nexport { NonTerminal };\nvar Rule = /** @class */function (_super) {\n  __extends(Rule, _super);\n  function Rule(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.orgText = \"\";\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Rule;\n}(AbstractProduction);\nexport { Rule };\n// TODO: is this only used in an Alternation?\n//       Perhaps `Flat` should be renamed to `Alternative`?\nvar Flat = /** @class */function (_super) {\n  __extends(Flat, _super);\n  // A named Flat production is used to indicate a Nested Rule in an alternation\n  function Flat(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.ignoreAmbiguities = false;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Flat;\n}(AbstractProduction);\nexport { Flat };\nvar Option = /** @class */function (_super) {\n  __extends(Option, _super);\n  function Option(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Option;\n}(AbstractProduction);\nexport { Option };\nvar RepetitionMandatory = /** @class */function (_super) {\n  __extends(RepetitionMandatory, _super);\n  function RepetitionMandatory(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatory;\n}(AbstractProduction);\nexport { RepetitionMandatory };\nvar RepetitionMandatoryWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionMandatoryWithSeparator, _super);\n  function RepetitionMandatoryWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionMandatoryWithSeparator;\n}(AbstractProduction);\nexport { RepetitionMandatoryWithSeparator };\nvar Repetition = /** @class */function (_super) {\n  __extends(Repetition, _super);\n  function Repetition(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Repetition;\n}(AbstractProduction);\nexport { Repetition };\nvar RepetitionWithSeparator = /** @class */function (_super) {\n  __extends(RepetitionWithSeparator, _super);\n  function RepetitionWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return RepetitionWithSeparator;\n}(AbstractProduction);\nexport { RepetitionWithSeparator };\nvar Alternation = /** @class */function (_super) {\n  __extends(Alternation, _super);\n  function Alternation(options) {\n    var _this = _super.call(this, options.definition) || this;\n    _this.idx = 1;\n    _this.ignoreAmbiguities = false;\n    _this.hasPredicates = false;\n    assign(_this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n  return Alternation;\n}(AbstractProduction);\nexport { Alternation };\nvar Terminal = /** @class */function () {\n  function Terminal(options) {\n    this.idx = 1;\n    assign(this, pick(options, function (v) {\n      return v !== undefined;\n    }));\n  }\n  Terminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n  };\n  return Terminal;\n}();\nexport { Terminal };\nexport function serializeGrammar(topRules) {\n  return map(topRules, serializeProduction);\n}\nexport function serializeProduction(node) {\n  function convertDefinition(definition) {\n    return map(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n  if (node instanceof NonTerminal) {\n    return {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n  } else if (node instanceof Flat) {\n    return {\n      type: \"Flat\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      name: node.name,\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      name: node.name,\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      name: node.name,\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      name: node.name,\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      name: node.name,\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    var serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n    var pattern = node.terminalType.PATTERN;\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = isRegExp(pattern) ? pattern.source : pattern;\n    }\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n//# sourceMappingURL=gast_public.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}