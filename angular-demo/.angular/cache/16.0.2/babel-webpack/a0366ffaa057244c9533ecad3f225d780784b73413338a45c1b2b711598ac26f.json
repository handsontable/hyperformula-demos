{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { secondsExtendedRegexp } from '../DateTimeDefault';\nimport { numberToSimpleTime } from '../DateTimeHelper';\nimport { parseForDateTimeFormat, parseForNumberFormat, TokenType } from './parser';\nexport function format(value, formatArg, config, dateHelper) {\n  const tryDateTime = config.stringifyDateTime(dateHelper.numberToSimpleDateTime(value), formatArg); // default points to defaultStringifyDateTime()\n  if (tryDateTime !== undefined) {\n    return tryDateTime;\n  }\n  const tryDuration = config.stringifyDuration(numberToSimpleTime(value), formatArg);\n  if (tryDuration !== undefined) {\n    return tryDuration;\n  }\n  const expression = parseForNumberFormat(formatArg);\n  if (expression !== undefined) {\n    return numberFormat(expression.tokens, value);\n  }\n  return formatArg;\n}\nexport function padLeft(number, size) {\n  let result = number + '';\n  while (result.length < size) {\n    result = '0' + result;\n  }\n  return result;\n}\nexport function padRight(number, size) {\n  let result = number + '';\n  while (result.length < size) {\n    result = result + '0';\n  }\n  return result;\n}\nfunction countChars(text, char) {\n  return text.split(char).length - 1;\n}\nfunction numberFormat(tokens, value) {\n  let result = '';\n  for (let i = 0; i < tokens.length; ++i) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    const tokenParts = token.value.split('.');\n    const integerFormat = tokenParts[0];\n    const decimalFormat = tokenParts[1] || '';\n    const separator = tokenParts[1] ? '.' : '';\n    /* get fixed-point number without trailing zeros */\n    const valueParts = Number(value.toFixed(decimalFormat.length)).toString().split('.');\n    let integerPart = valueParts[0] || '';\n    let decimalPart = valueParts[1] || '';\n    if (integerFormat.length > integerPart.length) {\n      const padSizeInteger = countChars(integerFormat.substr(0, integerFormat.length - integerPart.length), '0');\n      integerPart = padLeft(integerPart, padSizeInteger + integerPart.length);\n    }\n    const padSizeDecimal = countChars(decimalFormat.substr(decimalPart.length, decimalFormat.length - decimalPart.length), '0');\n    decimalPart = padRight(decimalPart, padSizeDecimal + decimalPart.length);\n    result += integerPart + separator + decimalPart;\n  }\n  return result;\n}\nexport function defaultStringifyDuration(time, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  for (const token of tokens) {\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      case 'h':\n      case 'hh':\n        {\n          result += padLeft(time.hours, token.value.length);\n          time.hours = 0;\n          break;\n        }\n      case '[hh]':\n        {\n          result += padLeft(time.hours, token.value.length - 2);\n          time.hours = 0;\n          break;\n        }\n      case 'm':\n      case 'mm':\n        {\n          result += padLeft(time.minutes, token.value.length);\n          time.minutes = 0;\n          break;\n        }\n      case '[mm]':\n        {\n          result += padLeft(time.minutes + 60 * time.hours, token.value.length - 2);\n          time.minutes = 0;\n          time.hours = 0;\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(time.seconds), token.value.length);\n          break;\n        }\n      default:\n        {\n          if (secondsExtendedRegexp.test(token.value)) {\n            const fractionOfSecondPrecision = Math.max(token.value.length - 3, 0);\n            result += (time.seconds < 10 ? '0' : '') + Math.floor(time.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision);\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}\nexport function defaultStringifyDateTime(dateTime, formatArg) {\n  const expression = parseForDateTimeFormat(formatArg);\n  if (expression === undefined) {\n    return undefined;\n  }\n  const tokens = expression.tokens;\n  let result = '';\n  let minutes = false;\n  const ampm = tokens.some(token => token.type === TokenType.FORMAT && (token.value === 'a/p' || token.value === 'A/P' || token.value === 'am/pm' || token.value === 'AM/PM'));\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.type === TokenType.FREE_TEXT) {\n      result += token.value;\n      continue;\n    }\n    switch (token.value.toLowerCase()) {\n      /* hours*/\n      case 'h':\n      case 'hh':\n        {\n          minutes = true;\n          result += padLeft(ampm ? (dateTime.hours + 11) % 12 + 1 : dateTime.hours, token.value.length);\n          break;\n        }\n      /* days */\n      case 'd':\n      case 'dd':\n        {\n          result += padLeft(dateTime.day, token.value.length);\n          break;\n        }\n      /* seconds */\n      case 's':\n      case 'ss':\n        {\n          result += padLeft(Math.floor(dateTime.seconds), token.value.length);\n          break;\n        }\n      /* minutes / months */\n      case 'm':\n      case 'mm':\n        {\n          if (i + 1 < tokens.length && tokens[i + 1].value.startsWith(':')) {\n            minutes = true;\n          }\n          if (minutes) {\n            result += padLeft(dateTime.minutes, token.value.length);\n          } else {\n            result += padLeft(dateTime.month, token.value.length);\n          }\n          minutes = true;\n          break;\n        }\n      /* years */\n      case 'yy':\n        {\n          result += padLeft(dateTime.year % 100, token.value.length);\n          break;\n        }\n      case 'yyyy':\n        {\n          result += dateTime.year;\n          break;\n        }\n      /* AM / PM */\n      case 'am/pm':\n      case 'a/p':\n        {\n          const [am, pm] = token.value.split('/');\n          result += dateTime.hours < 12 ? am : pm;\n          break;\n        }\n      default:\n        {\n          if (secondsExtendedRegexp.test(token.value)) {\n            const fractionOfSecondPrecision = token.value.length - 3;\n            result += (dateTime.seconds < 10 ? '0' : '') + Math.floor(dateTime.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision);\n            continue;\n          }\n          return undefined;\n        }\n    }\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}