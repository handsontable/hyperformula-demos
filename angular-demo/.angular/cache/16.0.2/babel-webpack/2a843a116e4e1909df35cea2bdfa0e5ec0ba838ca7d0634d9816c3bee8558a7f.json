{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, ErrorType } from '../Cell';\nimport { Transformer } from './Transformer';\nexport class AddColumnsTransformer extends Transformer {\n  constructor(columnsSpan) {\n    super();\n    this.columnsSpan = columnsSpan;\n  }\n  get sheet() {\n    return this.columnsSpan.sheet;\n  }\n  isIrreversible() {\n    return false;\n  }\n  transformRowRangeAst(ast, _formulaAddress) {\n    return ast;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(_start, _end, _formulaAddress) {\n    throw Error('Not implemented');\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    const absoluteDependencySheet = absoluteSheetReference(dependencyAddress, formulaAddress);\n    // Case 4 and 5\n    if (absoluteDependencySheet !== this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      return false;\n    }\n    const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n    // Case 3\n    if (absoluteDependencySheet === this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {\n      if (this.columnsSpan.columnStart <= absolutizedDependencyAddress.col) {\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      } else {\n        return false;\n      }\n    }\n    // Case 2\n    if (formulaAddress.sheet === this.columnsSpan.sheet && absoluteDependencySheet !== this.columnsSpan.sheet) {\n      if (dependencyAddress.isColumnAbsolute()) {\n        return false;\n      }\n      if (formulaAddress.col < this.columnsSpan.columnStart) {\n        return false;\n      }\n      return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n    }\n    // Case 1\n    if (dependencyAddress.isColumnAbsolute()) {\n      if (dependencyAddress.col < this.columnsSpan.columnStart) {\n        // Case Aa\n        return false;\n      } else {\n        // Case Ab\n        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n      }\n    } else {\n      const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);\n      if (absolutizedDependencyAddress.col < this.columnsSpan.columnStart) {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Raa\n          return false;\n        } else {\n          // Case Rab\n          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);\n        }\n      } else {\n        if (formulaAddress.col < this.columnsSpan.columnStart) {\n          // Case Rba\n          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);\n        } else {\n          // Case Rbb\n          return false;\n        }\n      }\n    }\n  }\n  fixNodeAddress(address) {\n    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {\n      return Object.assign(Object.assign({}, address), {\n        col: address.col + this.columnsSpan.numberOfColumns\n      });\n    } else {\n      return address;\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart === ErrorType.REF || newEnd === ErrorType.REF) {\n      return ErrorType.REF;\n    } else if (newStart || newEnd) {\n      return [newStart || start, newEnd || end];\n    } else {\n      return false;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}