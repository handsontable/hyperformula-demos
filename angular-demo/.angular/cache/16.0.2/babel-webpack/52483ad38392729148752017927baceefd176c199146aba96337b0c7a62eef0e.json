{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from '../../AbsoluteCellRange';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { SheetsNotEqual } from '../../errors';\nimport { AstNodeType } from '../../parser';\nimport { coerceBooleanToNumber } from '../ArithmeticHelper';\nimport { EmptyValue, getRawValue, isExtendedNumber } from '../InterpreterValue';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nfunction zeroForInfinite(value) {\n  if (isExtendedNumber(value) && !Number.isFinite(getRawValue(value))) {\n    return 0;\n  } else {\n    return value;\n  }\n}\nclass MomentsAggregate {\n  constructor(sumsq, sum, count) {\n    this.sumsq = sumsq;\n    this.sum = sum;\n    this.count = count;\n  }\n  static single(arg) {\n    return new MomentsAggregate(arg * arg, arg, 1);\n  }\n  compose(other) {\n    return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);\n  }\n  averageValue() {\n    if (this.count > 0) {\n      return this.sum / this.count;\n    } else {\n      return undefined;\n    }\n  }\n  varSValue() {\n    if (this.count > 1) {\n      return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);\n    } else {\n      return undefined;\n    }\n  }\n  varPValue() {\n    if (this.count > 0) {\n      return (this.sumsq - this.sum * this.sum / this.count) / this.count;\n    } else {\n      return undefined;\n    }\n  }\n}\nMomentsAggregate.empty = new MomentsAggregate(0, 0, 0);\nexport class NumericAggregationPlugin extends FunctionPlugin {\n  constructor() {\n    super(...arguments);\n    this.addWithEpsilonRaw = (left, right) => this.arithmeticHelper.addWithEpsilonRaw(left, right);\n  }\n  /**\r\n   * Corresponds to SUM(Number1, Number2, ...).\r\n   *\r\n   * Returns a sum of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sum(ast, state) {\n    return this.doSum(ast.args, state);\n  }\n  sumsq(ast, state) {\n    return this.reduce(ast.args, state, 0, 'SUMSQ', this.addWithEpsilonRaw, arg => Math.pow(getRawValue(arg), 2), strictlyNumbers);\n  }\n  /**\r\n   * Corresponds to MAX(Number1, Number2, ...).\r\n   *\r\n   * Returns a max of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  max(ast, state) {\n    return this.doMax(ast.args, state);\n  }\n  maxa(ast, state) {\n    const value = this.reduce(ast.args, state, Number.NEGATIVE_INFINITY, 'MAXA', (left, right) => Math.max(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  /**\r\n   * Corresponds to MIN(Number1, Number2, ...).\r\n   *\r\n   * Returns a min of given numbers.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  min(ast, state) {\n    return this.doMin(ast.args, state);\n  }\n  mina(ast, state) {\n    const value = this.reduce(ast.args, state, Number.POSITIVE_INFINITY, 'MINA', (left, right) => Math.min(left, right), getRawValue, numbersBooleans);\n    return zeroForInfinite(value);\n  }\n  count(ast, state) {\n    return this.doCount(ast.args, state);\n  }\n  counta(ast, state) {\n    return this.doCounta(ast.args, state);\n  }\n  average(ast, state) {\n    return this.doAverage(ast.args, state);\n  }\n  averagea(ast, state) {\n    var _a;\n    const result = this.reduce(ast.args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => left.compose(right), arg => MomentsAggregate.single(getRawValue(arg)), numbersBooleans);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  vars(ast, state) {\n    return this.doVarS(ast.args, state);\n  }\n  varp(ast, state) {\n    return this.doVarP(ast.args, state);\n  }\n  vara(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  varpa(ast, state) {\n    var _a;\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  stdevs(ast, state) {\n    return this.doStdevS(ast.args, state);\n  }\n  stdevp(ast, state) {\n    return this.doStdevP(ast.args, state);\n  }\n  stdeva(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  stdevpa(ast, state) {\n    const result = this.reduceAggregateA(ast.args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  product(ast, state) {\n    return this.doProduct(ast.args, state);\n  }\n  subtotal(ast, state) {\n    if (ast.args.length < 2) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    const functionType = this.coerceToType(this.evaluateAst(ast.args[0], state), {\n      argumentType: FunctionArgumentType.NUMBER\n    }, state);\n    const args = ast.args.slice(1);\n    switch (functionType) {\n      case 1:\n      case 101:\n        return this.doAverage(args, state);\n      case 2:\n      case 102:\n        return this.doCount(args, state);\n      case 3:\n      case 103:\n        return this.doCounta(args, state);\n      case 4:\n      case 104:\n        return this.doMax(args, state);\n      case 5:\n      case 105:\n        return this.doMin(args, state);\n      case 6:\n      case 106:\n        return this.doProduct(args, state);\n      case 7:\n      case 107:\n        return this.doStdevS(args, state);\n      case 8:\n      case 108:\n        return this.doStdevP(args, state);\n      case 9:\n      case 109:\n        return this.doSum(args, state);\n      case 10:\n      case 110:\n        return this.doVarS(args, state);\n      case 11:\n      case 111:\n        return this.doVarP(args, state);\n      default:\n        return new CellError(ErrorType.VALUE, ErrorMessage.BadMode);\n    }\n  }\n  reduceAggregate(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, strictlyNumbers);\n  }\n  reduceAggregateA(args, state) {\n    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => {\n      return left.compose(right);\n    }, arg => {\n      return MomentsAggregate.single(getRawValue(arg));\n    }, numbersBooleans);\n  }\n  doAverage(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarS(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doVarP(args, state) {\n    var _a;\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new CellError(ErrorType.DIV_BY_ZERO);\n    }\n  }\n  doStdevS(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varSValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doStdevP(args, state) {\n    const result = this.reduceAggregate(args, state);\n    if (result instanceof CellError) {\n      return result;\n    } else {\n      const val = result.varPValue();\n      return val === undefined ? new CellError(ErrorType.DIV_BY_ZERO) : Math.sqrt(val);\n    }\n  }\n  doCount(args, state) {\n    return this.reduce(args, state, 0, 'COUNT', (left, right) => left + right, getRawValue, arg => isExtendedNumber(arg) ? 1 : 0);\n  }\n  doCounta(args, state) {\n    return this.reduce(args, state, 0, 'COUNTA', (left, right) => left + right, getRawValue, arg => arg === EmptyValue ? 0 : 1);\n  }\n  doMax(args, state) {\n    const value = this.reduce(args, state, Number.NEGATIVE_INFINITY, 'MAX', (left, right) => Math.max(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doMin(args, state) {\n    const value = this.reduce(args, state, Number.POSITIVE_INFINITY, 'MIN', (left, right) => Math.min(left, right), getRawValue, strictlyNumbers);\n    return zeroForInfinite(value);\n  }\n  doSum(args, state) {\n    return this.reduce(args, state, 0, 'SUM', this.addWithEpsilonRaw, getRawValue, strictlyNumbers);\n  }\n  doProduct(args, state) {\n    return this.reduce(args, state, 1, 'PRODUCT', (left, right) => left * right, getRawValue, strictlyNumbers);\n  }\n  /**\r\n   * Reduces procedure arguments with given reducing function\r\n   *\r\n   * @param args\r\n   * @param state\r\n   * @param initialAccValue - \"neutral\" value (equivalent of 0)\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  reduce(args, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    if (args.length < 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    return args.reduce((acc, arg) => {\n      if (acc instanceof CellError) {\n        return acc;\n      }\n      if (arg.type === AstNodeType.CELL_RANGE || arg.type === AstNodeType.COLUMN_RANGE || arg.type === AstNodeType.ROW_RANGE) {\n        const val = this.evaluateRange(arg, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction);\n        if (val instanceof CellError) {\n          return val;\n        }\n        return reducingFunction(val, acc);\n      }\n      let value;\n      value = this.evaluateAst(arg, state);\n      if (value instanceof SimpleRangeValue) {\n        const coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(arg => arg !== undefined);\n        return coercedRangeValues.map(arg => {\n          if (arg instanceof CellError) {\n            return arg;\n          } else {\n            return mapFunction(arg);\n          }\n        }).reduce((left, right) => {\n          if (left instanceof CellError) {\n            return left;\n          } else if (right instanceof CellError) {\n            return right;\n          } else {\n            return reducingFunction(left, right);\n          }\n        }, acc);\n      } else if (arg.type === AstNodeType.CELL_REFERENCE) {\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      } else {\n        value = this.coerceScalarToNumberOrError(value);\n        value = coercionFunction(value);\n        if (value === undefined) {\n          return acc;\n        }\n      }\n      if (value instanceof CellError) {\n        return value;\n      }\n      return reducingFunction(acc, mapFunction(value));\n    }, initialAccValue);\n  }\n  /**\r\n   * Performs range operation on given range\r\n   *\r\n   * @param ast - cell range ast\r\n   * @param state\r\n   * @param initialAccValue - initial accumulator value for reducing function\r\n   * @param functionName - function name to use as cache key\r\n   * @param reducingFunction - reducing function\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  evaluateRange(ast, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {\n    let range;\n    try {\n      range = AbsoluteCellRange.fromAst(ast, state.formulaAddress);\n    } catch (err) {\n      if (err instanceof SheetsNotEqual) {\n        return new CellError(ErrorType.REF, ErrorMessage.RangeManySheets);\n      } else {\n        throw err;\n      }\n    }\n    const rangeVertex = this.dependencyGraph.getRange(range.start, range.end);\n    if (rangeVertex === undefined) {\n      throw new Error('Range does not exists in graph');\n    }\n    let value = rangeVertex.getFunctionValue(functionName);\n    if (value === undefined) {\n      const rangeValues = this.getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction);\n      value = rangeValues.reduce((arg1, arg2) => {\n        if (arg1 instanceof CellError) {\n          return arg1;\n        } else if (arg2 instanceof CellError) {\n          return arg2;\n        } else {\n          return reducingFunction(arg1, arg2);\n        }\n      }, initialAccValue);\n      rangeVertex.setFunctionValue(functionName, value);\n    }\n    return value;\n  }\n  /**\r\n   * Returns list of values for given range and function name\r\n   *\r\n   * If range is dependent on smaller range, list will contain value of smaller range for this function\r\n   * and values of cells that are not present in smaller range\r\n   *\r\n   * @param functionName - function name (e.g. SUM)\r\n   * @param range - cell range\r\n   * @param rangeVertex\r\n   * @param mapFunction\r\n   * @param coercionFunction\r\n   */\n  getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction) {\n    const rangeResult = [];\n    const {\n      smallerRangeVertex,\n      restRange\n    } = this.dependencyGraph.rangeMapping.findSmallerRange(range);\n    let actualRange;\n    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, rangeVertex)) {\n      const cachedValue = smallerRangeVertex.getFunctionValue(functionName);\n      if (cachedValue !== undefined) {\n        rangeResult.push(cachedValue);\n      } else {\n        for (const cellFromRange of smallerRangeVertex.range.addresses(this.dependencyGraph)) {\n          const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n          if (val instanceof CellError) {\n            rangeResult.push(val);\n          } else if (val !== undefined) {\n            rangeResult.push(mapFunction(val));\n          }\n        }\n      }\n      actualRange = restRange;\n    } else {\n      actualRange = range;\n    }\n    for (const cellFromRange of actualRange.addresses(this.dependencyGraph)) {\n      const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));\n      if (val instanceof CellError) {\n        rangeResult.push(val);\n      } else if (val !== undefined) {\n        rangeResult.push(mapFunction(val));\n      }\n    }\n    return rangeResult;\n  }\n}\nNumericAggregationPlugin.implementedFunctions = {\n  'SUM': {\n    method: 'sum',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUMSQ': {\n    method: 'sumsq',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAX': {\n    method: 'max',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MIN': {\n    method: 'min',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MAXA': {\n    method: 'maxa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'MINA': {\n    method: 'mina',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNT': {\n    method: 'count',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'COUNTA': {\n    method: 'counta',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGE': {\n    method: 'average',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'AVERAGEA': {\n    method: 'averagea',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'PRODUCT': {\n    method: 'product',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.S': {\n    method: 'vars',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VAR.P': {\n    method: 'varp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARA': {\n    method: 'vara',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'VARPA': {\n    method: 'varpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.S': {\n    method: 'stdevs',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEV.P': {\n    method: 'stdevp',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVA': {\n    method: 'stdeva',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'STDEVPA': {\n    method: 'stdevpa',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'SUBTOTAL': {\n    method: 'subtotal',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  }\n};\nNumericAggregationPlugin.aliases = {\n  VAR: 'VAR.S',\n  VARP: 'VAR.P',\n  STDEV: 'STDEV.S',\n  STDEVP: 'STDEV.P',\n  VARS: 'VAR.S',\n  STDEVS: 'STDEV.S'\n};\nfunction strictlyNumbers(arg) {\n  if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else {\n    return undefined;\n  }\n}\nfunction numbersBooleans(arg) {\n  if (typeof arg === 'boolean') {\n    return coerceBooleanToNumber(arg);\n  } else if (isExtendedNumber(arg) || arg instanceof CellError) {\n    return arg;\n  } else if (typeof arg === 'string') {\n    return 0;\n  } else {\n    return undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}