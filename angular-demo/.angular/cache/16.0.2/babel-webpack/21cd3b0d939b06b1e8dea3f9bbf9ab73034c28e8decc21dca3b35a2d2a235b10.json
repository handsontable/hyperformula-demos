{"ast":null,"code":"/**\r\n * @license\r\n Copyright (c) 2013 jStat\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy\r\n of this software and associated documentation files (the \"Software\"), to deal\r\n in the Software without restriction, including without limitation the rights\r\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n copies of the Software, and to permit persons to whom the Software is\r\n furnished to do so, subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in\r\n all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n THE SOFTWARE.\r\n */\nexport function erf(x) {\n  const cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4, 4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6, 1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8, 6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12, 8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17];\n  let j = cof.length - 1;\n  let isneg = false;\n  let d = 0;\n  let dd = 0;\n  let t, ty, tmp, res;\n  if (x === 0) {\n    return 0;\n  }\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n  for (; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n}\nexport function erfc(x) {\n  return 1 - erf(x);\n}\nfunction erfcinv(p) {\n  let j = 0;\n  let x, err, t, pp;\n  if (p >= 2) {\n    return -100;\n  }\n  if (p <= 0) {\n    return 100;\n  }\n  pp = p < 1 ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return p < 1 ? x : -x;\n}\nexport const exponential = {\n  pdf: (x, rate) => {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n  cdf: (x, rate) => {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  }\n};\nexport function gammafn(x) {\n  const p = [-1.716185138865495, 24.76565080557592, -379.80425647094563, 629.3311553128184, 866.9662027904133, -31451.272968848367, -36144.413418691176, 66456.14382024054];\n  const q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192, -3107.771671572311, 22538.118420980151, 4755.8462775278811, -134659.9598649693, -115132.2596755535];\n  let fact = false;\n  let n = 0;\n  let xden = 0;\n  let xnum = 0;\n  let y = x;\n  let i, z, yi, res;\n  if (x > 171.6243769536076) {\n    return Infinity;\n  }\n  if (y <= 0) {\n    res = y % 1;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n}\nexport const gamma = {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0) {\n      return 0;\n    }\n    return x === 0 && shape === 1 ? 1 / scale : Math.exp((shape - 1) * Math.log(x) - x / scale - gammaln(shape) - shape * Math.log(scale));\n  },\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0) {\n      return 0;\n    }\n    return lowRegGamma(shape, x / scale);\n  },\n  inv: function (p, shape, scale) {\n    return gammapinv(p, shape) * scale;\n  }\n};\nexport function gammaln(x) {\n  let j = 0;\n  const cof = [76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];\n  let ser = 1.000000000190015;\n  let xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++) {\n    ser += cof[j] / ++y;\n  }\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n}\nfunction lowRegGamma(a, x) {\n  const aln = gammaln(a);\n  let ap = a;\n  let sum = 1 / a;\n  let del = sum;\n  let b = x + 1 - a;\n  let c = 1 / 1.0e-30;\n  let d = 1 / b;\n  let h = d;\n  let i = 1;\n  // calculate maximum number of itterations required for a\n  const ITMAX = -~(Math.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  let an;\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return sum * Math.exp(-x + a * Math.log(x) - aln);\n  }\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n  return 1 - h * Math.exp(-x + a * Math.log(x) - aln);\n}\nfunction gammapinv(p, a) {\n  let j = 0;\n  const a1 = a - 1;\n  const EPS = 1e-8;\n  const gln = gammaln(a);\n  let x, err, t, u, pp;\n  let lna1;\n  let afac;\n  if (p >= 1) {\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  }\n  if (p <= 0) {\n    return 0;\n  }\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5) {\n      x = -x;\n    }\n    x = Math.max(1e-3, a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t) {\n      x = Math.pow(p / t, 1 / a);\n    } else {\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n    }\n  }\n  for (; j < 12; j++) {\n    if (x <= 0) {\n      return 0;\n    }\n    err = lowRegGamma(a, x) - p;\n    if (a > 1) {\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    } else {\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    }\n    u = err / t;\n    x -= t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1)));\n    if (x <= 0) {\n      x = 0.5 * (x + t);\n    }\n    if (Math.abs(t) < EPS * x) {\n      break;\n    }\n  }\n  return x;\n}\nexport const normal = {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n  inv: function (p, mean, std) {\n    return -1.41421356237309505 * std * erfcinv(2 * p) + mean;\n  }\n};\nexport const beta = {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0) {\n      return 0;\n    }\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1) {\n      return 1;\n    }\n    if (alpha < 512 && beta < 512) {\n      return Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) - betaln(alpha, beta));\n    }\n  },\n  cdf: function cdf(x, alpha, beta) {\n    return x > 1 || x < 0 ? +(x > 1) : ibeta(x, alpha, beta);\n  },\n  inv: function inv(x, alpha, beta) {\n    return ibetainv(x, alpha, beta);\n  }\n};\nfunction betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0) {\n    return undefined;\n  }\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return x + y > 170 ? Math.exp(betaln(x, y)) : gammafn(x) * gammafn(y) / gammafn(x + y);\n}\nfunction betaln(x, y) {\n  return gammaln(x) + gammaln(y) - gammaln(x + y);\n}\nfunction ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0) {\n    return 0;\n  }\n  if (p >= 1) {\n    return 1;\n  }\n  if (a >= 1 && b >= 1) {\n    pp = p < 0.5 ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5) {\n      x = -x;\n    }\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));\n    w = x * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w) {\n      x = Math.pow(a * w * p, 1 / a);\n    } else {\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n    }\n  }\n  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);\n  for (; j < 10; j++) {\n    if (x === 0 || x === 1) {\n      return x;\n    }\n    // @ts-ignore\n    err = ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));\n    if (x <= 0) {\n      x = 0.5 * (x + t);\n    }\n    if (x >= 1) {\n      x = 0.5 * (x + t + 1);\n    }\n    if (Math.abs(t) < EPS * x && j > 0) {\n      break;\n    }\n  }\n  return x;\n}\nfunction ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = x === 0 || x === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x) + b * Math.log(1 - x));\n  if (x < 0 || x > 1) {\n    return false;\n  }\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    {\n      return bt * betacf(x, a, b) / a;\n    }\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * betacf(1 - x, b, a) / b;\n}\nfunction betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin) {\n    d = fpmin;\n  }\n  d = 1 / d;\n  h = d;\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin) {\n      d = fpmin;\n    }\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin) {\n      c = fpmin;\n    }\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin) {\n      d = fpmin;\n    }\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin) {\n      c = fpmin;\n    }\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7) {\n      break;\n    }\n  }\n  return h;\n}\nexport const binomial = {\n  pdf: function (k, n, p) {\n    return p === 0 || p === 1 ? n * p === k ? 1 : 0 : combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n  cdf: function (x, n, p) {\n    var betacdf;\n    var eps = 1e-10;\n    if (x < 0) {\n      return 0;\n    }\n    if (x >= n) {\n      return 1;\n    }\n    if (p < 0 || p > 1 || n <= 0) {\n      return NaN;\n    }\n    x = Math.floor(x);\n    var z = p;\n    var a = x + 1;\n    var b = n - x;\n    var s = a + b;\n    var bt = Math.exp(gammaln(s) - gammaln(b) - gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));\n    if (z < (a + 1) / (s + 2)) {\n      betacdf = bt * betinc(z, a, b, eps);\n    } else {\n      betacdf = 1 - bt * betinc(1 - z, b, a, eps);\n    }\n    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);\n  }\n};\nfunction betinc(x, a, b, eps) {\n  var a0 = 0;\n  var b0 = 1;\n  var a1 = 1;\n  var b1 = 1;\n  var m9 = 0;\n  var a2 = 0;\n  var c9;\n  while (Math.abs((a1 - a2) / a1) > eps) {\n    a2 = a1;\n    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);\n    a0 = a1 + c9 * a0;\n    b0 = b1 + c9 * b0;\n    m9 = m9 + 1;\n    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);\n    a1 = a0 + c9 * a1;\n    b1 = b0 + c9 * b1;\n    a0 = a0 / b1;\n    b0 = b0 / b1;\n    a1 = a1 / b1;\n    b1 = 1;\n  }\n  return a1 / a;\n}\nfunction combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return n > 170 || m > 170 ? Math.exp(combinationln(n, m)) : factorial(n) / factorial(m) / factorial(n - m);\n}\nfunction combinationln(n, m) {\n  return factorialln(n) - factorialln(m) - factorialln(n - m);\n}\n// natural log factorial of n\nexport function factorialln(n) {\n  return n < 0 ? NaN : gammaln(n + 1);\n}\n// factorial of n\nexport function factorial(n) {\n  return n < 0 ? NaN : gammafn(n + 1);\n}\nexport const chisquare = {\n  pdf: function pdf(x, dof) {\n    if (x < 0) {\n      return 0;\n    }\n    return x === 0 && dof === 2 ? 0.5 : Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - dof / 2 * Math.log(2) - gammaln(dof / 2));\n  },\n  cdf: function cdf(x, dof) {\n    if (x < 0) {\n      return 0;\n    }\n    return lowRegGamma(dof / 2, x / 2);\n  },\n  inv: function (p, dof) {\n    return 2 * gammapinv(p, 0.5 * dof);\n  }\n};\nexport const centralF = {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n    if (x < 0) {\n      return 0;\n    }\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return 1 / betafn(df1 / 2, df2 / 2) * Math.pow(df1 / df2, df1 / 2) * Math.pow(x, df1 / 2 - 1) * Math.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);\n    }\n    p = df1 * x / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0) {\n      return 0;\n    }\n    return ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / ibetainv(x, df1 / 2, df2 / 2) - 1));\n  }\n};\nexport const weibull = {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0) {\n      return 0;\n    }\n    return shape / scale * Math.pow(x / scale, shape - 1) * Math.exp(-Math.pow(x / scale, shape));\n  },\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow(x / scale, shape));\n  }\n};\nexport const poisson = {\n  pdf: function pdf(k, l) {\n    if (l < 0 || k % 1 !== 0 || k < 0) {\n      return 0;\n    }\n    return Math.pow(l, k) * Math.exp(-l) / factorial(k);\n  },\n  cdf: function cdf(x, l) {\n    var k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    var sum = 0;\n    for (; k <= x; k++) {\n      sum += poisson.pdf(k, l);\n    }\n    return sum;\n  }\n};\nexport const hypgeom = {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n    // A simplification of the CDF algorithm below.\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n    // if(k !== k | 0) {\n    //   return false;\n    // } else\n    if (k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if (k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n      if (n * 2 > N) {\n        // More than half the population is sampled.\n        return hypgeom.pdf(N - m - n + k, N, N - m, N - n);\n      } else {\n        // Half or less of the population is sampled.\n        return hypgeom.pdf(n - k, N, N - m, n);\n      }\n    } else if (n * 2 > N) {\n      // Half or less is successes.\n      return hypgeom.pdf(m - k, N, m, N - n);\n    } else if (m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n      for (var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n        while (scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n          scaledPDF *= 1 - m / (N - samplesDone);\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n      for (; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - m / (N - samplesDone);\n      }\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n    if (x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if (x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n      if (n * 2 > N) {\n        // More than half the population is sampled.\n        return cdf(N - m - n + x, N, N - m, N - n);\n      } else {\n        // Half or less of the population is sampled.\n        return 1 - hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n    } else if (n * 2 > N) {\n      // Half or less is successes.\n      return 1 - hypgeom.cdf(m - x - 1, N, m, N - n);\n    } else if (m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n      for (var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n        while (scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n          var factor = 1 - m / (N - samplesDone);\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n      for (; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - m / (N - samplesDone);\n      }\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n};\nexport const studentt = {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return 1 / (Math.sqrt(dof) * betafn(0.5, dof / 2)) * Math.pow(1 + x * x / dof, -((dof + 1) / 2));\n  },\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return ibeta((x + Math.sqrt(x * x + dof)) / (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n  inv: function (p, dof) {\n    var x = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return p > 0.5 ? x : -x;\n  }\n};\nexport const lognormal = {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0) {\n      return 0;\n    }\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) - Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));\n  },\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0) {\n      return 0;\n    }\n    return 0.5 + 0.5 * erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma));\n  },\n  inv: function (p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * erfcinv(2 * p) + mu);\n  }\n};\nexport const negbin = {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0) {\n      return false;\n    }\n    if (k < 0) {\n      return 0;\n    }\n    return combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n      k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    for (; k <= x; k++) {\n      sum += negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n};\nfunction sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0) {\n    sum += arr[i];\n  }\n  return sum;\n}\nexport function mean(arr) {\n  return sum(arr) / arr.length;\n}\nexport function sumsqerr(arr) {\n  var meanv = mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - meanv;\n    sum += tmp * tmp;\n  }\n  return sum;\n}\nexport function variance(arr, flag) {\n  return sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n}\nexport function stdev(arr, flag) {\n  return Math.sqrt(variance(arr, flag));\n}\n// 2 different parameter setups\n// (value, alpha, sd, n)\n// (value, alpha, array)\nexport function normalci() {\n  var args = [].slice.call(arguments),\n    ans = new Array(2),\n    change;\n  if (args.length === 4) {\n    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * args[2] / Math.sqrt(args[3]));\n  } else {\n    // @ts-ignore\n    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * stdev(args[2]) / Math.sqrt(args[2].length));\n  }\n  ans[0] = args[0] - change;\n  ans[1] = args[0] + change;\n  return ans;\n}\nexport function tci() {\n  var args = [].slice.call(arguments),\n    ans = new Array(2),\n    change;\n  if (args.length === 4) {\n    change = Math.abs(studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math.sqrt(args[3]));\n  } else {\n    // @ts-ignore\n    change = Math.abs(studentt.inv(args[1] / 2, args[2].length - 1) * stdev(args[2], true) / Math.sqrt(args[2].length));\n  }\n  ans[0] = args[0] - change;\n  ans[1] = args[0] + change;\n  return ans;\n}\nfunction product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0) {\n    prod *= arr[i];\n  }\n  return prod;\n}\nexport function geomean(arr) {\n  return Math.pow(product(arr), 1 / arr.length);\n}\nexport function covariance(arr1, arr2) {\n  var u = mean(arr1);\n  var v = mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n  for (i = 0; i < arr1Len; i++) {\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n  }\n  return sum(sq_dev) / (arr1Len - 1);\n}\nexport function corrcoeff(arr1, arr2) {\n  return covariance(arr1, arr2) / stdev(arr1, 1) / stdev(arr2, 1);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}