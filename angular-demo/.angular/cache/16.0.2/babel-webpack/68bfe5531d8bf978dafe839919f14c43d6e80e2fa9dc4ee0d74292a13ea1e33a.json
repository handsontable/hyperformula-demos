{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { getRawValue } from '../InterpreterValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class RomanPlugin extends FunctionPlugin {\n  roman(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ROMAN'), (val, mode) => {\n      val = Math.trunc(val);\n      if (mode === false) {\n        mode = 4;\n      } else if (mode === true) {\n        mode = 0;\n      }\n      mode = getRawValue(this.coerceScalarToNumberOrError(mode));\n      if (mode instanceof CellError) {\n        return mode;\n      }\n      mode = Math.trunc(mode);\n      if (mode < 0) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ValueSmall);\n      }\n      if (mode > 4) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ValueLarge);\n      }\n      return romanMode(val, mode);\n    });\n  }\n  arabic(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ARABIC'), inputString => {\n      inputString = inputString.trim().toUpperCase();\n      let minusSign = false;\n      if (inputString.startsWith('-')) {\n        inputString = inputString.slice(1);\n        minusSign = true;\n        if (inputString === '') {\n          return new CellError(ErrorType.VALUE, ErrorMessage.InvalidRoman);\n        }\n      }\n      const work = {\n        input: inputString,\n        acc: 0\n      };\n      eatToken(work, {\n        token: 'MMM',\n        val: 3000\n      }, {\n        token: 'MM',\n        val: 2000\n      }, {\n        token: 'M',\n        val: 1000\n      });\n      eatToken(work, {\n        token: 'IM',\n        val: 999\n      }, {\n        token: 'VM',\n        val: 995\n      }, {\n        token: 'XM',\n        val: 990\n      }, {\n        token: 'LM',\n        val: 950\n      }, {\n        token: 'CM',\n        val: 900\n      });\n      eatToken(work, {\n        token: 'D',\n        val: 500\n      }, {\n        token: 'ID',\n        val: 499\n      }, {\n        token: 'VD',\n        val: 495\n      }, {\n        token: 'XD',\n        val: 490\n      }, {\n        token: 'LD',\n        val: 450\n      }, {\n        token: 'CD',\n        val: 400\n      });\n      eatToken(work, {\n        token: 'CCC',\n        val: 300\n      }, {\n        token: 'CC',\n        val: 200\n      }, {\n        token: 'C',\n        val: 100\n      });\n      eatToken(work, {\n        token: 'IC',\n        val: 99\n      }, {\n        token: 'VC',\n        val: 95\n      }, {\n        token: 'XC',\n        val: 90\n      });\n      eatToken(work, {\n        token: 'L',\n        val: 50\n      }, {\n        token: 'IL',\n        val: 49\n      }, {\n        token: 'VL',\n        val: 45\n      }, {\n        token: 'XL',\n        val: 40\n      });\n      eatToken(work, {\n        token: 'XXX',\n        val: 30\n      }, {\n        token: 'XX',\n        val: 20\n      }, {\n        token: 'X',\n        val: 10\n      });\n      eatToken(work, {\n        token: 'IX',\n        val: 9\n      });\n      eatToken(work, {\n        token: 'V',\n        val: 5\n      }, {\n        token: 'IV',\n        val: 4\n      });\n      eatToken(work, {\n        token: 'III',\n        val: 3\n      }, {\n        token: 'II',\n        val: 2\n      }, {\n        token: 'I',\n        val: 1\n      });\n      if (work.input !== '') {\n        return new CellError(ErrorType.VALUE, ErrorMessage.InvalidRoman);\n      } else {\n        return minusSign ? -work.acc : work.acc;\n      }\n    });\n  }\n}\nRomanPlugin.implementedFunctions = {\n  'ROMAN': {\n    method: 'roman',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1,\n      lessThan: 4000\n    }, {\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true,\n      defaultValue: 0\n    }]\n  },\n  'ARABIC': {\n    method: 'arabic',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  }\n};\nfunction eatToken(inputAcc, ...tokens) {\n  for (const token of tokens) {\n    if (inputAcc.input.startsWith(token.token)) {\n      inputAcc.input = inputAcc.input.slice(token.token.length);\n      inputAcc.acc += token.val;\n      break;\n    }\n  }\n}\nfunction romanMode(input, mode) {\n  const work = {\n    val: input % 1000,\n    acc: 'M'.repeat(Math.floor(input / 1000))\n  };\n  if (mode === 4) {\n    absorb(work, 'IM', 999, 1000);\n    absorb(work, 'ID', 499, 500);\n  }\n  if (mode >= 3) {\n    absorb(work, 'VM', 995, 1000);\n    absorb(work, 'VD', 495, 500);\n  }\n  if (mode >= 2) {\n    absorb(work, 'XM', 990, 1000);\n    absorb(work, 'XD', 490, 500);\n  }\n  if (mode >= 1) {\n    absorb(work, 'LM', 950, 1000);\n    absorb(work, 'LD', 450, 500);\n  }\n  absorb(work, 'CM', 900, 1000);\n  absorb(work, 'CD', 400, 500);\n  absorb(work, 'D', 500, 900);\n  work.acc += 'C'.repeat(Math.floor(work.val / 100));\n  work.val %= 100;\n  if (mode >= 2) {\n    absorb(work, 'IC', 99, 100);\n    absorb(work, 'IL', 49, 50);\n  }\n  if (mode >= 1) {\n    absorb(work, 'VC', 95, 100);\n    absorb(work, 'VL', 45, 50);\n  }\n  absorb(work, 'XC', 90, 100);\n  absorb(work, 'XL', 40, 50);\n  absorb(work, 'L', 50, 90);\n  work.acc += 'X'.repeat(Math.floor(work.val / 10));\n  work.val %= 10;\n  absorb(work, 'IX', 9, 10);\n  absorb(work, 'IV', 4, 5);\n  absorb(work, 'V', 5, 9);\n  work.acc += 'I'.repeat(work.val);\n  return work.acc;\n}\nfunction absorb(valAcc, token, lower, upper) {\n  if (valAcc.val >= lower && valAcc.val < upper) {\n    valAcc.val -= lower;\n    valAcc.acc += token;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}