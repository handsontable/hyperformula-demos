{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { FormulaVertex } from '../../DependencyGraph/FormulaCellVertex';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { EmptyValue, isExtendedNumber } from '../InterpreterValue';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\n/**\r\n * Interpreter plugin containing information functions\r\n */\nexport class InformationPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to ISBINARY(value)\r\n   *\r\n   * Returns true if provided value is a valid binary number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isbinary(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBINARY'), arg => /^[01]{1,10}$/.test(arg));\n  }\n  /**\r\n   * Corresponds to ISERR(value)\r\n   *\r\n   * Returns true if provided value is an error except #N/A!\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserr(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERR'), arg => arg instanceof CellError && arg.type !== ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISERROR(value)\r\n   *\r\n   * Checks whether provided value is an error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  iserror(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISERROR'), arg => arg instanceof CellError);\n  }\n  /**\r\n   * Corresponds to ISFORMULA(value)\r\n   *\r\n   * Checks whether referenced cell is a formula\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isformula(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ISFORMULA'), () => new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber), reference => {\n      const vertex = this.dependencyGraph.addressMapping.getCell(reference);\n      return vertex instanceof FormulaVertex;\n    });\n  }\n  /**\r\n   * Corresponds to ISBLANK(value)\r\n   *\r\n   * Checks whether provided cell reference is empty\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isblank(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISBLANK'), arg => arg === EmptyValue);\n  }\n  /**\r\n   * Corresponds to ISNA(value)\r\n   *\r\n   * Returns true if provided value is #N/A! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isna(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNA'), arg => arg instanceof CellError && arg.type == ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to ISNUMBER(value)\r\n   *\r\n   * Checks whether provided cell reference is a number\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnumber(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNUMBER'), isExtendedNumber);\n  }\n  /**\r\n   * Corresponds to ISLOGICAL(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  islogical(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISLOGICAL'), arg => typeof arg === 'boolean');\n  }\n  /**\r\n   * Corresponds to ISREF(value)\r\n   *\r\n   * Returns true if provided value is #REF! error\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isref(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISREF'), arg => arg instanceof CellError && (arg.type == ErrorType.REF || arg.type == ErrorType.CYCLE));\n  }\n  /**\r\n   * Corresponds to ISTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  istext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISTEXT'), arg => typeof arg === 'string');\n  }\n  /**\r\n   * Corresponds to ISNONTEXT(value)\r\n   *\r\n   * Checks whether provided cell reference is of logical type\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  isnontext(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ISNONTEXT'), arg => !(typeof arg === 'string'));\n  }\n  /**\r\n   * Corresponds to COLUMN(reference)\r\n   *\r\n   * Returns column number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  column(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('COLUMN'), () => state.formulaAddress.col + 1, reference => reference.col + 1);\n  }\n  /**\r\n   * Corresponds to COLUMNS(range)\r\n   *\r\n   * Returns number of columns in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  columns(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.COLUMN_RANGE) {\n      return argAst.end.col - argAst.start.col + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.ROW_RANGE) {\n      return this.config.maxColumns;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.width();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to ROW(reference)\r\n   *\r\n   * Returns row number of a reference or a formula cell if reference not provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  row(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ROW'), () => state.formulaAddress.row + 1, reference => reference.row + 1);\n  }\n  /**\r\n   * Corresponds to ROWS(range)\r\n   *\r\n   * Returns number of rows in provided range of cells\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  rows(ast, state) {\n    if (ast.args.length !== 1) {\n      return new CellError(ErrorType.NA, ErrorMessage.WrongArgNumber);\n    }\n    if (ast.args.some(astIt => astIt.type === AstNodeType.EMPTY)) {\n      return new CellError(ErrorType.NUM, ErrorMessage.EmptyArg);\n    }\n    let argAst = ast.args[0];\n    while (argAst.type === AstNodeType.PARENTHESIS) {\n      argAst = argAst.expression;\n    }\n    if (argAst.type === AstNodeType.CELL_RANGE || argAst.type === AstNodeType.ROW_RANGE) {\n      return argAst.end.row - argAst.start.row + 1;\n    } else if (argAst.type === AstNodeType.CELL_REFERENCE) {\n      return 1;\n    } else if (argAst.type === AstNodeType.COLUMN_RANGE) {\n      return this.config.maxRows;\n    } else {\n      const val = this.evaluateAst(argAst, state);\n      if (val instanceof SimpleRangeValue) {\n        return val.height();\n      } else if (val instanceof CellError) {\n        return val;\n      } else {\n        return 1;\n      }\n    }\n  }\n  /**\r\n   * Corresponds to INDEX\r\n   *\r\n   * Returns specific position in 2d array.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  index(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('INDEX'), (rangeValue, row, col) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (col < 1 || row < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (col > rangeValue.width() || row > rangeValue.height()) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      return (_f = (_c = (_b = (_a = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _a === void 0 ? void 0 : _a[row - 1]) === null || _b === void 0 ? void 0 : _b[col - 1]) !== null && _c !== void 0 ? _c : (_e = (_d = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : new CellError(ErrorType.VALUE, ErrorMessage.CellRangeExpected);\n    });\n  }\n  /**\r\n   * Corresponds to NA()\r\n   *\r\n   * Returns #N/A!\r\n   *\r\n   * @param _ast\r\n   * @param _state\r\n   */\n  na(_ast, _state) {\n    return new CellError(ErrorType.NA);\n  }\n  /**\r\n   * Corresponds to SHEET(value)\r\n   *\r\n   * Returns sheet number of a given value or a formula sheet number if no argument is provided\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheet(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEET'), () => state.formulaAddress.sheet + 1, reference => reference.sheet + 1, value => {\n      const sheetNumber = this.dependencyGraph.sheetMapping.get(value);\n      if (sheetNumber !== undefined) {\n        return sheetNumber + 1;\n      } else {\n        return new CellError(ErrorType.NA, ErrorMessage.SheetRef);\n      }\n    });\n  }\n  /**\r\n   * Corresponds to SHEETS(value)\r\n   *\r\n   * Returns number of sheet of a given reference or number of all sheets in workbook when no argument is provided.\r\n   * It returns always 1 for a valid reference as 3D references are not supported.\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  sheets(ast, state) {\n    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEETS'), () => this.dependencyGraph.sheetMapping.numberOfSheets(),\n    // return number of sheets if no argument\n    () => 1,\n    // return 1 for valid reference\n    () => new CellError(ErrorType.VALUE, ErrorMessage.CellRefExpected) // error otherwise\n    );\n  }\n}\n\nInformationPlugin.implementedFunctions = {\n  'COLUMN': {\n    method: 'column',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'COLUMNS': {\n    method: 'columns',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISBINARY': {\n    method: 'isbinary',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }]\n  },\n  'ISERR': {\n    method: 'iserr',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISFORMULA': {\n    method: 'isformula',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ISNA': {\n    method: 'isna',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISREF': {\n    method: 'isref',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }],\n    vectorizationForbidden: true\n  },\n  'ISERROR': {\n    method: 'iserror',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISBLANK': {\n    method: 'isblank',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNUMBER': {\n    method: 'isnumber',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISLOGICAL': {\n    method: 'islogical',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISTEXT': {\n    method: 'istext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'ISNONTEXT': {\n    method: 'isnontext',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR\n    }]\n  },\n  'INDEX': {\n    method: 'index',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'NA': {\n    method: 'na',\n    parameters: []\n  },\n  'ROW': {\n    method: 'row',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR,\n      optionalArg: true\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'ROWS': {\n    method: 'rows',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    isDependentOnSheetStructureChange: true,\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEET': {\n    method: 'sheet',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  },\n  'SHEETS': {\n    method: 'sheets',\n    parameters: [{\n      argumentType: FunctionArgumentType.STRING\n    }],\n    doesNotNeedArgumentsToBeComputed: true,\n    vectorizationForbidden: true\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}