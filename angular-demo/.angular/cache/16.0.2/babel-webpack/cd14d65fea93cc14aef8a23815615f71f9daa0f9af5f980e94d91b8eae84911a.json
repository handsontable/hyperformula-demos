{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { forEach, isUndefined } from \"../../utils/utils\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAltIndex, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../grammar/keys\";\nimport { Alternation, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator } from \"../grammar/gast/gast_public\";\nimport { GAstVisitor } from \"../grammar/gast/gast_visitor_public\";\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\nexport function addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\nexport function addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\nvar NamedDSLMethodsCollectorVisitor = /** @class */function (_super) {\n  __extends(NamedDSLMethodsCollectorVisitor, _super);\n  function NamedDSLMethodsCollectorVisitor(ruleIdx) {\n    var _this = _super.call(this) || this;\n    _this.result = [];\n    _this.ruleIdx = ruleIdx;\n    return _this;\n  }\n  NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {\n    // TODO: better hack to copy what we need here...\n    if (!isUndefined(node.name)) {\n      // copy without name so this will indeed be processed later.\n      var nameLessNode\n      /* istanbul ignore else */ = void 0;\n      /* istanbul ignore else */\n      if (node instanceof Option || node instanceof Repetition || node instanceof RepetitionMandatory || node instanceof Alternation) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx\n        });\n      } else if (node instanceof RepetitionMandatoryWithSeparator || node instanceof RepetitionWithSeparator) {\n        nameLessNode = new newNodeConstructor({\n          definition: node.definition,\n          idx: node.idx,\n          separator: node.separator\n        });\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n      var def = [nameLessNode];\n      var key = getKeyForAutomaticLookahead(this.ruleIdx, methodIdx, node.idx);\n      this.result.push({\n        def: def,\n        key: key,\n        name: node.name,\n        orgProd: node\n      });\n    }\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {\n    this.collectNamedDSLMethod(node, Option, OPTION_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {\n    this.collectNamedDSLMethod(node, Repetition, MANY_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatory, AT_LEAST_ONE_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionMandatoryWithSeparator, AT_LEAST_ONE_SEP_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.collectNamedDSLMethod(node, RepetitionWithSeparator, MANY_SEP_IDX);\n  };\n  NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {\n    var _this = this;\n    this.collectNamedDSLMethod(node, Alternation, OR_IDX);\n    var hasMoreThanOneAlternative = node.definition.length > 1;\n    forEach(node.definition, function (currFlatAlt, altIdx) {\n      if (!isUndefined(currFlatAlt.name)) {\n        var def = currFlatAlt.definition;\n        if (hasMoreThanOneAlternative) {\n          def = [new Option({\n            definition: currFlatAlt.definition\n          })];\n        } else {\n          // mandatory\n          def = currFlatAlt.definition;\n        }\n        var key = getKeyForAltIndex(_this.ruleIdx, OR_IDX, node.idx, altIdx);\n        _this.result.push({\n          def: def,\n          key: key,\n          name: currFlatAlt.name,\n          orgProd: currFlatAlt\n        });\n      }\n    });\n  };\n  return NamedDSLMethodsCollectorVisitor;\n}(GAstVisitor);\nexport { NamedDSLMethodsCollectorVisitor };\nexport function expandAllNestedRuleNames(topRules, fullToShortName) {\n  var result = {\n    allRuleNames: []\n  };\n  forEach(topRules, function (currTopRule) {\n    var currTopRuleShortName = fullToShortName[currTopRule.name];\n    result.allRuleNames.push(currTopRule.name);\n    var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);\n    currTopRule.accept(namedCollectorVisitor);\n    forEach(namedCollectorVisitor.result, function (_a) {\n      var def = _a.def,\n        key = _a.key,\n        name = _a.name;\n      result.allRuleNames.push(currTopRule.name + name);\n    });\n  });\n  return result;\n}\n//# sourceMappingURL=cst.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}