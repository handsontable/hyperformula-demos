{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { invalidSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { CellContent } from './CellContentParser';\nimport { InvalidAddressError, InvalidArgumentsError, NamedExpressionDoesNotExistError, NamedExpressionNameIsAlreadyTakenError, NamedExpressionNameIsInvalidError, NoOperationToRedoError, NoOperationToUndoError, NoRelativeAddressesAllowedError, NoSheetWithIdError, NothingToPasteError, SheetNameAlreadyTakenError, SheetSizeLimitExceededError, SourceLocationHasArrayError, TargetLocationHasArrayError } from './errors';\nimport { doesContainRelativeReferences } from './NamedExpressions';\nimport { AddColumnsCommand, AddRowsCommand, RemoveColumnsCommand, RemoveRowsCommand } from './Operations';\nimport { findBoundaries, validateAsSheet } from './Sheet';\nimport { ColumnsSpan, RowsSpan } from './Span';\nimport { AddColumnsUndoEntry, AddNamedExpressionUndoEntry, AddRowsUndoEntry, AddSheetUndoEntry, ChangeNamedExpressionUndoEntry, ClearSheetUndoEntry, MoveCellsUndoEntry, MoveColumnsUndoEntry, MoveRowsUndoEntry, PasteUndoEntry, RemoveColumnsUndoEntry, RemoveNamedExpressionUndoEntry, RemoveRowsUndoEntry, RemoveSheetUndoEntry, RenameSheetUndoEntry, SetCellContentsUndoEntry, SetColumnOrderUndoEntry, SetRowOrderUndoEntry, SetSheetContentUndoEntry } from './UndoRedo';\nexport class CrudOperations {\n  constructor(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions) {\n    this.operations = operations;\n    this.undoRedo = undoRedo;\n    this.clipboardOperations = clipboardOperations;\n    this.dependencyGraph = dependencyGraph;\n    this.columnSearch = columnSearch;\n    this.parser = parser;\n    this.cellContentParser = cellContentParser;\n    this.lazilyTransformingAstService = lazilyTransformingAstService;\n    this.namedExpressions = namedExpressions;\n    this.maxRows = config.maxRows;\n    this.maxColumns = config.maxColumns;\n  }\n  get sheetMapping() {\n    return this.dependencyGraph.sheetMapping;\n  }\n  addRows(sheet, ...indexes) {\n    const addRowsCommand = new AddRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addRows(addRowsCommand);\n    this.undoRedo.saveOperation(new AddRowsUndoEntry(addRowsCommand));\n  }\n  removeRows(sheet, ...indexes) {\n    const removeRowsCommand = new RemoveRowsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveRows(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const rowsRemovals = this.operations.removeRows(removeRowsCommand);\n    this.undoRedo.saveOperation(new RemoveRowsUndoEntry(removeRowsCommand, rowsRemovals));\n  }\n  addColumns(sheet, ...indexes) {\n    const addColumnsCommand = new AddColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToAddColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.operations.addColumns(addColumnsCommand);\n    this.undoRedo.saveOperation(new AddColumnsUndoEntry(addColumnsCommand));\n  }\n  removeColumns(sheet, ...indexes) {\n    const removeColumnsCommand = new RemoveColumnsCommand(sheet, indexes);\n    this.ensureItIsPossibleToRemoveColumns(sheet, ...indexes);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const columnsRemovals = this.operations.removeColumns(removeColumnsCommand);\n    this.undoRedo.saveOperation(new RemoveColumnsUndoEntry(removeColumnsCommand, columnsRemovals));\n  }\n  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const {\n      version,\n      overwrittenCellsData,\n      addedGlobalNamedExpressions\n    } = this.operations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);\n    this.undoRedo.saveOperation(new MoveCellsUndoEntry(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version));\n  }\n  moveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const version = this.operations.moveRows(sheet, startRow, numberOfRows, targetRow);\n    this.undoRedo.saveOperation(new MoveRowsUndoEntry(sheet, startRow, numberOfRows, targetRow, version));\n  }\n  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.clearRedoStack();\n    const version = this.operations.moveColumns(sheet, startColumn, numberOfColumns, targetColumn);\n    this.undoRedo.saveOperation(new MoveColumnsUndoEntry(sheet, startColumn, numberOfColumns, targetColumn, version));\n  }\n  cut(sourceLeftCorner, width, height) {\n    this.clipboardOperations.cut(sourceLeftCorner, width, height);\n  }\n  ensureItIsPossibleToCopy(sourceLeftCorner, width, height) {\n    if (!isPositiveInteger(width)) {\n      throw new InvalidArgumentsError('width to be positive integer.');\n    }\n    if (!isPositiveInteger(height)) {\n      throw new InvalidArgumentsError('height to be positive integer.');\n    }\n  }\n  copy(sourceLeftCorner, width, height) {\n    this.ensureItIsPossibleToCopy(sourceLeftCorner, width, height);\n    this.clipboardOperations.copy(sourceLeftCorner, width, height);\n  }\n  paste(targetLeftCorner) {\n    const clipboard = this.clipboardOperations.clipboard;\n    if (clipboard === undefined) {\n      throw new NothingToPasteError();\n    } else if (this.clipboardOperations.isCutClipboard()) {\n      this.moveCells(clipboard.sourceLeftCorner, clipboard.width, clipboard.height, targetLeftCorner);\n    } else if (this.clipboardOperations.isCopyClipboard()) {\n      this.clipboardOperations.ensureItIsPossibleToCopyPaste(targetLeftCorner);\n      const targetRange = AbsoluteCellRange.spanFrom(targetLeftCorner, clipboard.width, clipboard.height);\n      const oldContent = this.operations.getRangeClipboardCells(targetRange);\n      this.undoRedo.clearRedoStack();\n      const addedGlobalNamedExpressions = this.operations.restoreClipboardCells(clipboard.sourceLeftCorner.sheet, clipboard.getContent(targetLeftCorner));\n      this.undoRedo.saveOperation(new PasteUndoEntry(targetLeftCorner, oldContent, clipboard.content, addedGlobalNamedExpressions));\n    }\n  }\n  beginUndoRedoBatchMode() {\n    this.undoRedo.beginBatchMode();\n  }\n  commitUndoRedoBatchMode() {\n    this.undoRedo.commitBatchMode();\n  }\n  isClipboardEmpty() {\n    return this.clipboardOperations.clipboard === undefined;\n  }\n  clearClipboard() {\n    this.clipboardOperations.clear();\n  }\n  addSheet(name) {\n    if (name !== undefined) {\n      this.ensureItIsPossibleToAddSheet(name);\n    }\n    this.undoRedo.clearRedoStack();\n    const addedSheetName = this.operations.addSheet(name);\n    this.undoRedo.saveOperation(new AddSheetUndoEntry(addedSheetName));\n    return addedSheetName;\n  }\n  removeSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const originalName = this.sheetMapping.fetchDisplayName(sheetId);\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    const {\n      version,\n      scopedNamedExpressions\n    } = this.operations.removeSheet(sheetId);\n    this.undoRedo.saveOperation(new RemoveSheetUndoEntry(originalName, sheetId, oldSheetContent, scopedNamedExpressions, version));\n  }\n  renameSheet(sheetId, newName) {\n    this.ensureItIsPossibleToRenameSheet(sheetId, newName);\n    const oldName = this.operations.renameSheet(sheetId, newName);\n    if (oldName !== undefined) {\n      this.undoRedo.clearRedoStack();\n      this.undoRedo.saveOperation(new RenameSheetUndoEntry(sheetId, oldName, newName));\n    }\n    return oldName;\n  }\n  clearSheet(sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.clearSheet(sheetId);\n    this.undoRedo.saveOperation(new ClearSheetUndoEntry(sheetId, oldSheetContent));\n  }\n  setCellContents(topLeftCornerAddress, cellContents) {\n    if (!(cellContents instanceof Array)) {\n      cellContents = [[cellContents]];\n    } else {\n      for (let i = 0; i < cellContents.length; i++) {\n        if (!(cellContents[i] instanceof Array)) {\n          throw new InvalidArgumentsError('an array of arrays or a raw cell value.');\n        }\n      }\n    }\n    this.ensureItIsPossibleToChangeCellContents(topLeftCornerAddress, cellContents);\n    this.undoRedo.clearRedoStack();\n    const oldContents = [];\n    for (let i = 0; i < cellContents.length; i++) {\n      for (let j = 0; j < cellContents[i].length; j++) {\n        const address = {\n          sheet: topLeftCornerAddress.sheet,\n          row: topLeftCornerAddress.row + i,\n          col: topLeftCornerAddress.col + j\n        };\n        const newContent = cellContents[i][j];\n        this.clipboardOperations.abortCut();\n        const oldContent = this.operations.setCellContent(address, newContent);\n        oldContents.push({\n          address,\n          newContent,\n          oldContent\n        });\n      }\n    }\n    this.undoRedo.saveOperation(new SetCellContentsUndoEntry(oldContents));\n  }\n  setSheetContent(sheetId, values) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureItIsPossibleToChangeSheetContents(sheetId, values);\n    validateAsSheet(values);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);\n    this.operations.setSheetContent(sheetId, values);\n    this.undoRedo.saveOperation(new SetSheetContentUndoEntry(sheetId, oldSheetContent, values));\n  }\n  setRowOrder(sheetId, rowMapping) {\n    this.validateSwapRowIndexes(sheetId, rowMapping);\n    this.testRowOrderForArrays(sheetId, rowMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setRowOrder(sheetId, rowMapping);\n    this.undoRedo.saveOperation(new SetRowOrderUndoEntry(sheetId, rowMapping, oldContent));\n  }\n  validateSwapRowIndexes(sheetId, rowMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, rowMapping, 'row');\n  }\n  testColumnOrderForArrays(sheetId, columnMapping) {\n    for (const [source, target] of columnMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: source,\n          row: 0\n        }, 1, Infinity);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  setColumnOrder(sheetId, columnMapping) {\n    this.validateSwapColumnIndexes(sheetId, columnMapping);\n    this.testColumnOrderForArrays(sheetId, columnMapping);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    const oldContent = this.operations.setColumnOrder(sheetId, columnMapping);\n    this.undoRedo.saveOperation(new SetColumnOrderUndoEntry(sheetId, columnMapping, oldContent));\n  }\n  validateSwapColumnIndexes(sheetId, columnMapping) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    this.validateRowOrColumnMapping(sheetId, columnMapping, 'column');\n  }\n  testRowOrderForArrays(sheetId, rowMapping) {\n    for (const [source, target] of rowMapping) {\n      if (source !== target) {\n        const rowRange = AbsoluteCellRange.spanFrom({\n          sheet: sheetId,\n          col: 0,\n          row: source\n        }, Infinity, 1);\n        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {\n          throw new SourceLocationHasArrayError();\n        }\n      }\n    }\n  }\n  mappingFromOrder(sheetId, newOrder, rowOrColumn) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    if (newOrder.length !== limit) {\n      throw new InvalidArgumentsError(`number of ${rowOrColumn}s provided to be sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n    }\n    const ret = [];\n    for (let i = 0; i < limit; i++) {\n      if (newOrder[i] !== i) {\n        ret.push([i, newOrder[i]]);\n      }\n    }\n    return ret;\n  }\n  undo() {\n    if (this.undoRedo.isUndoStackEmpty()) {\n      throw new NoOperationToUndoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.undo();\n  }\n  redo() {\n    if (this.undoRedo.isRedoStackEmpty()) {\n      throw new NoOperationToRedoError();\n    }\n    this.clipboardOperations.abortCut();\n    this.undoRedo.redo();\n  }\n  addNamedExpression(expressionName, expression, sheetId, options) {\n    this.ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId);\n    this.operations.addNamedExpression(expressionName, expression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new AddNamedExpressionUndoEntry(expressionName, expression, sheetId, options));\n  }\n  changeNamedExpressionExpression(expressionName, sheetId, newExpression, options) {\n    this.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, sheetId);\n    const [oldNamedExpression, content] = this.operations.changeNamedExpressionExpression(expressionName, newExpression, sheetId, options);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new ChangeNamedExpressionUndoEntry(oldNamedExpression, newExpression, content, sheetId, options));\n  }\n  removeNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    const [namedExpression, content] = this.operations.removeNamedExpression(expressionName, sheetId);\n    this.undoRedo.clearRedoStack();\n    this.clipboardOperations.abortCut();\n    this.undoRedo.saveOperation(new RemoveNamedExpressionUndoEntry(namedExpression, content, sheetId));\n    return namedExpression;\n  }\n  ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    this.ensureNamedExpressionNameIsValid(expressionName, sheetId);\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  ensureItIsPossibleToChangeNamedExpression(expressionName, expression, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n    this.ensureNamedExpressionIsValid(expression);\n  }\n  isItPossibleToRemoveNamedExpression(expressionName, sheetId) {\n    this.ensureScopeIdIsValid(sheetId);\n    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {\n      throw new NamedExpressionDoesNotExistError(expressionName);\n    }\n  }\n  ensureItIsPossibleToAddRows(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const newRowsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetHeight + newRowsCount > this.maxRows) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [row, numberOfRowsToAdd] of indexes) {\n      if (!isNonnegativeInteger(row) || !isPositiveInteger(numberOfRowsToAdd)) {\n        throw new InvalidArgumentsError('row number to be nonnegative and number of rows to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveRows(sheet, ...indexes) {\n    for (const [rowStart, numberOfRows] of indexes) {\n      const rowEnd = rowStart + numberOfRows - 1;\n      if (!isNonnegativeInteger(rowStart) || !isNonnegativeInteger(rowEnd)) {\n        throw new InvalidArgumentsError('starting and ending row to be nonnegative.');\n      }\n      if (rowEnd < rowStart) {\n        throw new InvalidArgumentsError('starting row to be smaller than the ending row.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToAddColumns(sheet, ...indexes) {\n    if (!this.sheetMapping.hasSheetWithId(sheet)) {\n      throw new NoSheetWithIdError(sheet);\n    }\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const newColumnsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);\n    if (sheetWidth + newColumnsCount > this.maxColumns) {\n      throw new SheetSizeLimitExceededError();\n    }\n    for (const [column, numberOfColumnsToAdd] of indexes) {\n      if (!isNonnegativeInteger(column) || !isPositiveInteger(numberOfColumnsToAdd)) {\n        throw new InvalidArgumentsError('column number to be nonnegative and number of columns to add to be positive.');\n      }\n    }\n  }\n  ensureItIsPossibleToRemoveColumns(sheet, ...indexes) {\n    for (const [columnStart, numberOfColumns] of indexes) {\n      const columnEnd = columnStart + numberOfColumns - 1;\n      if (!isNonnegativeInteger(columnStart) || !isNonnegativeInteger(columnEnd)) {\n        throw new InvalidArgumentsError('starting and ending column to be nonnegative.');\n      }\n      if (columnEnd < columnStart) {\n        throw new InvalidArgumentsError('starting column to be smaller than the ending column.');\n      }\n      if (!this.sheetMapping.hasSheetWithId(sheet)) {\n        throw new NoSheetWithIdError(sheet);\n      }\n    }\n  }\n  ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow) {\n    this.ensureItIsPossibleToAddRows(sheet, [targetRow, numberOfRows]);\n    const sourceStart = simpleCellAddress(sheet, 0, startRow);\n    const targetStart = simpleCellAddress(sheet, 0, targetRow);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfRows) || targetRow <= startRow + numberOfRows && targetRow >= startRow) {\n      throw new InvalidArgumentsError('a valid range of rows to move.');\n    }\n    const width = this.dependencyGraph.getSheetWidth(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, width, numberOfRows);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetRow > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllRows(RowsSpan.fromNumberOfRows(sheet, targetRow - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn) {\n    this.ensureItIsPossibleToAddColumns(sheet, [targetColumn, numberOfColumns]);\n    const sourceStart = simpleCellAddress(sheet, startColumn, 0);\n    const targetStart = simpleCellAddress(sheet, targetColumn, 0);\n    if (!this.sheetMapping.hasSheetWithId(sheet) || invalidSimpleCellAddress(sourceStart) || invalidSimpleCellAddress(targetStart) || !isPositiveInteger(numberOfColumns) || targetColumn <= startColumn + numberOfColumns && targetColumn >= startColumn) {\n      throw new InvalidArgumentsError('a valid range of columns to move.');\n    }\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sourceRange = AbsoluteCellRange.spanFrom(sourceStart, numberOfColumns, sheetHeight);\n    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {\n      throw new SourceLocationHasArrayError();\n    }\n    if (targetColumn > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllColumns(ColumnsSpan.fromNumberOfColumns(sheet, targetColumn - 1, 2))) {\n      throw new TargetLocationHasArrayError();\n    }\n  }\n  ensureItIsPossibleToAddSheet(name) {\n    if (this.sheetMapping.hasSheetWithName(name)) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToRenameSheet(sheetId, name) {\n    if (!this.sheetMapping.hasSheetWithId(sheetId)) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    const existingSheetId = this.sheetMapping.get(name);\n    if (existingSheetId !== undefined && existingSheetId !== sheetId) {\n      throw new SheetNameAlreadyTakenError(name);\n    }\n  }\n  ensureItIsPossibleToChangeContent(address) {\n    if (invalidSimpleCellAddress(address)) {\n      throw new InvalidAddressError(address);\n    }\n    if (!this.sheetMapping.hasSheetWithId(address.sheet)) {\n      throw new NoSheetWithIdError(address.sheet);\n    }\n  }\n  ensureItIsPossibleToChangeCellContents(inputAddress, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(inputAddress, boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n    for (const address of targetRange.addresses(this.dependencyGraph)) {\n      this.ensureItIsPossibleToChangeContent(address);\n    }\n  }\n  ensureItIsPossibleToChangeSheetContents(sheetId, content) {\n    const boundaries = findBoundaries(content);\n    const targetRange = AbsoluteCellRange.spanFrom(simpleCellAddress(sheetId, 0, 0), boundaries.width, boundaries.height);\n    this.ensureRangeInSizeLimits(targetRange);\n  }\n  ensureRangeInSizeLimits(range) {\n    if (range.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {\n      throw new SheetSizeLimitExceededError();\n    }\n  }\n  isThereSomethingToUndo() {\n    return !this.undoRedo.isUndoStackEmpty();\n  }\n  isThereSomethingToRedo() {\n    return !this.undoRedo.isRedoStackEmpty();\n  }\n  getAndClearContentChanges() {\n    return this.operations.getAndClearContentChanges();\n  }\n  ensureScopeIdIsValid(scopeId) {\n    if (scopeId !== undefined && !this.sheetMapping.hasSheetWithId(scopeId)) {\n      throw new NoSheetWithIdError(scopeId);\n    }\n  }\n  validateRowOrColumnMapping(sheetId, rowMapping, rowOrColumn) {\n    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);\n    const sources = rowMapping.map(([a, _]) => a).sort((a, b) => a - b);\n    const targets = rowMapping.map(([_, b]) => b).sort((a, b) => a - b);\n    for (let i = 0; i < sources.length; i++) {\n      if (!isNonnegativeInteger(sources[i]) || sources[i] >= limit) {\n        throw new InvalidArgumentsError(`${rowOrColumn} numbers to be nonnegative integers and less than sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);\n      }\n      if (sources[i] === sources[i + 1]) {\n        throw new InvalidArgumentsError(`source ${rowOrColumn} numbers to be unique.`);\n      }\n      if (sources[i] !== targets[i]) {\n        throw new InvalidArgumentsError(`target ${rowOrColumn} numbers to be permutation of source ${rowOrColumn} numbers.`);\n      }\n    }\n  }\n  ensureNamedExpressionNameIsValid(expressionName, sheetId) {\n    if (!this.namedExpressions.isNameValid(expressionName)) {\n      throw new NamedExpressionNameIsInvalidError(expressionName);\n    }\n    if (!this.namedExpressions.isNameAvailable(expressionName, sheetId)) {\n      throw new NamedExpressionNameIsAlreadyTakenError(expressionName);\n    }\n  }\n  ensureNamedExpressionIsValid(expression) {\n    const parsedExpression = this.cellContentParser.parse(expression);\n    if (parsedExpression instanceof CellContent.Formula) {\n      const parsingResult = this.parser.parse(parsedExpression.formula, simpleCellAddress(-1, 0, 0));\n      if (doesContainRelativeReferences(parsingResult.ast)) {\n        throw new NoRelativeAddressesAllowedError();\n      }\n    }\n  }\n}\nfunction isPositiveInteger(x) {\n  return Number.isInteger(x) && x > 0;\n}\nfunction isNonnegativeInteger(x) {\n  return Number.isInteger(x) && x >= 0;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}