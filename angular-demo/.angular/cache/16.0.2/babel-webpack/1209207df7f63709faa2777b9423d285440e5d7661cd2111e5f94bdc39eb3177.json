{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { absoluteSheetReference, invalidSimpleCellAddress, simpleCellAddress, simpleColumnAddress, simpleRowAddress } from '../Cell';\nimport { columnIndexToLabel } from './addressRepresentationConverters';\nimport { ColumnAddress, ReferenceType } from './ColumnAddress';\nimport { RowAddress } from './RowAddress';\n/** Possible kinds of cell references */\nexport var CellReferenceType = /*#__PURE__*/(() => {\n  CellReferenceType = CellReferenceType || {};\n  /** Cell reference with both row and column relative. */\n  CellReferenceType[\"CELL_REFERENCE_RELATIVE\"] = \"CELL_REFERENCE\";\n  /** Cell reference with both row and column absolute. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE\"] = \"CELL_REFERENCE_ABSOLUTE\";\n  /** Cell reference with absolute column and relative row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_COL\"] = \"CELL_REFERENCE_ABSOLUTE_COL\";\n  /** Cell reference with relative column and absolute row. */\n  CellReferenceType[\"CELL_REFERENCE_ABSOLUTE_ROW\"] = \"CELL_REFERENCE_ABSOLUTE_ROW\";\n  return CellReferenceType;\n})();\nexport class CellAddress {\n  constructor(col, row, type, sheet) {\n    this.col = col;\n    this.row = row;\n    this.type = type;\n    this.sheet = sheet;\n  }\n  static fromColAndRow(col, row, sheet) {\n    const factoryMethod = col.isColumnAbsolute() && row.isRowAbsolute() ? CellAddress.absolute.bind(this) : col.isColumnAbsolute() ? CellAddress.absoluteCol.bind(this) : row.isRowAbsolute() ? CellAddress.absoluteRow.bind(this) : CellAddress.relative.bind(this);\n    return factoryMethod(col.col, row.row, sheet);\n  }\n  static relative(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_RELATIVE, sheet);\n  }\n  static absolute(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE, sheet);\n  }\n  static absoluteCol(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL, sheet);\n  }\n  static absoluteRow(col, row, sheet) {\n    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW, sheet);\n  }\n  /**\r\n   * Converts R0C0 representation of cell address to simple object representation.\r\n   *\r\n   * @param baseAddress - base address for R0C0 shifts\r\n   */\n  toSimpleCellAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE) {\n      return simpleCellAddress(sheet, this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, this.row);\n    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {\n      return simpleCellAddress(sheet, this.col, baseAddress.row + this.row);\n    } else {\n      return simpleCellAddress(sheet, baseAddress.col + this.col, baseAddress.row + this.row);\n    }\n  }\n  toColumnAddress() {\n    const refType = this.isColumnRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new ColumnAddress(refType, this.col, this.sheet);\n  }\n  toRowAddress() {\n    const refType = this.isRowRelative() ? ReferenceType.RELATIVE : ReferenceType.ABSOLUTE;\n    return new RowAddress(refType, this.row, this.sheet);\n  }\n  toSimpleColumnAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let column = this.col;\n    if (this.isColumnRelative()) {\n      column += baseAddress.col;\n    }\n    return simpleColumnAddress(sheet, column);\n  }\n  toSimpleRowAddress(baseAddress) {\n    const sheet = absoluteSheetReference(this, baseAddress);\n    let row = this.row;\n    if (this.isRowRelative()) {\n      row += baseAddress.row;\n    }\n    return simpleRowAddress(sheet, row);\n  }\n  isRowAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isColumnAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isColumnRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;\n  }\n  isRowRelative() {\n    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;\n  }\n  isAbsolute() {\n    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE && this.sheet !== undefined;\n  }\n  shiftedByRows(numberOfRows) {\n    return new CellAddress(this.col, this.row + numberOfRows, this.type, this.sheet);\n  }\n  shiftedByColumns(numberOfColumns) {\n    return new CellAddress(this.col + numberOfColumns, this.row, this.type, this.sheet);\n  }\n  moved(toSheet, toRight, toBottom) {\n    const newSheet = this.sheet === undefined ? undefined : toSheet;\n    return new CellAddress(this.col + toRight, this.row + toBottom, this.type, newSheet);\n  }\n  withSheet(sheet) {\n    return new CellAddress(this.col, this.row, this.type, sheet);\n  }\n  isInvalid(baseAddress) {\n    return invalidSimpleCellAddress(this.toSimpleCellAddress(baseAddress));\n  }\n  shiftRelativeDimensions(toRight, toBottom) {\n    const col = this.isColumnAbsolute() ? this.col : this.col + toRight;\n    const row = this.isRowAbsolute() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  shiftAbsoluteDimensions(toRight, toBottom) {\n    const col = this.isColumnRelative() ? this.col : this.col + toRight;\n    const row = this.isRowRelative() ? this.row : this.row + toBottom;\n    return new CellAddress(col, row, this.type, this.sheet);\n  }\n  hash(withSheet) {\n    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';\n    switch (this.type) {\n      case CellReferenceType.CELL_REFERENCE_RELATIVE:\n        {\n          return `${sheetPart}#${this.row}R${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE:\n        {\n          return `${sheetPart}#${this.row}A${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL:\n        {\n          return `${sheetPart}#${this.row}AC${this.col}`;\n        }\n      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW:\n        {\n          return `${sheetPart}#${this.row}AR${this.col}`;\n        }\n    }\n  }\n  unparse(baseAddress) {\n    const simpleAddress = this.toSimpleCellAddress(baseAddress);\n    if (invalidSimpleCellAddress(simpleAddress)) {\n      return undefined;\n    }\n    const column = columnIndexToLabel(simpleAddress.col);\n    const rowDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW ? '$' : '';\n    const colDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL ? '$' : '';\n    return `${colDollar}${column}${rowDollar}${simpleAddress.row + 1}`;\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.row >= maxRows || this.col >= maxColumns;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}