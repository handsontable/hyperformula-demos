{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from './Cell';\nimport { AstNodeType } from './parser';\nimport { CELL_REFERENCE_PATTERN, NAMED_EXPRESSION_PATTERN, R1C1_CELL_REFERENCE_PATTERN } from './parser/parser-consts';\nexport class InternalNamedExpression {\n  constructor(displayName, address, added, options) {\n    this.displayName = displayName;\n    this.address = address;\n    this.added = added;\n    this.options = options;\n  }\n  normalizeExpressionName() {\n    return this.displayName.toLowerCase();\n  }\n  copy() {\n    return new InternalNamedExpression(this.displayName, this.address, this.added, this.options);\n  }\n}\nclass WorkbookStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    return !(namedExpression && namedExpression.added);\n  }\n  add(namedExpression) {\n    this.mapping.set(namedExpression.normalizeExpressionName(), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  getExisting(expressionName) {\n    const namedExpression = this.mapping.get(this.normalizeExpressionName(expressionName));\n    if (namedExpression && namedExpression.added) {\n      return namedExpression;\n    } else {\n      return undefined;\n    }\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      namedExpression.added = false;\n    }\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nclass WorksheetStore {\n  constructor() {\n    this.mapping = new Map();\n  }\n  add(namedExpression) {\n    this.mapping.set(this.normalizeExpressionName(namedExpression.displayName), namedExpression);\n  }\n  get(expressionName) {\n    return this.mapping.get(this.normalizeExpressionName(expressionName));\n  }\n  has(expressionName) {\n    return this.mapping.has(this.normalizeExpressionName(expressionName));\n  }\n  getAllNamedExpressions() {\n    return Array.from(this.mapping.values()).filter(ne => ne.added);\n  }\n  isNameAvailable(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    return !this.mapping.has(normalizedExpressionName);\n  }\n  remove(expressionName) {\n    const normalizedExpressionName = this.normalizeExpressionName(expressionName);\n    const namedExpression = this.mapping.get(normalizedExpressionName);\n    if (namedExpression) {\n      this.mapping.delete(normalizedExpressionName);\n    }\n  }\n  normalizeExpressionName(expressionName) {\n    return expressionName.toLowerCase();\n  }\n}\nexport let NamedExpressions = /*#__PURE__*/(() => {\n  class NamedExpressions {\n    constructor() {\n      this.nextNamedExpressionRow = 0;\n      this.workbookStore = new WorkbookStore();\n      this.worksheetStores = new Map();\n      this.addressCache = new Map();\n    }\n    isNameAvailable(expressionName, sheetId) {\n      var _a, _b;\n      if (sheetId === undefined) {\n        return this.workbookStore.isNameAvailable(expressionName);\n      } else {\n        return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.isNameAvailable(expressionName)) !== null && _b !== void 0 ? _b : true;\n      }\n    }\n    namedExpressionInAddress(row) {\n      const namedExpression = this.addressCache.get(row);\n      if (namedExpression && namedExpression.added) {\n        return namedExpression;\n      } else {\n        return undefined;\n      }\n    }\n    namedExpressionForScope(expressionName, sheetId) {\n      var _a;\n      if (sheetId === undefined) {\n        return this.workbookStore.getExisting(expressionName);\n      } else {\n        return (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName);\n      }\n    }\n    nearestNamedExpression(expressionName, sheetId) {\n      var _a, _b;\n      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName)) !== null && _b !== void 0 ? _b : this.workbookStore.getExisting(expressionName);\n    }\n    isExpressionInScope(expressionName, sheetId) {\n      var _a, _b;\n      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.has(expressionName)) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\r\n     * Checks the validity of a named-expression's name.\r\n     *\r\n     * The name:\r\n     * - Must start with a Unicode letter or with an underscore (`_`).\r\n     * - Can contain only Unicode letters, numbers, underscores, and periods (`.`).\r\n     * - Can't be the same as any possible reference in the A1 notation (`[A-Za-z]+[0-9]+`).\r\n     * - Can't be the same as any possible reference in the R1C1 notation (`[rR][0-9]*[cC][0-9]*`).\r\n     *\r\n     * The naming rules follow the [OpenDocument](https://docs.oasis-open.org/office/OpenDocument/v1.3/os/part4-formula/OpenDocument-v1.3-os-part4-formula.html#__RefHeading__1017964_715980110) standard.\r\n     */\n    isNameValid(expressionName) {\n      const a1CellRefRegexp = new RegExp(`^${CELL_REFERENCE_PATTERN}$`);\n      const r1c1CellRefRegexp = new RegExp(`^${R1C1_CELL_REFERENCE_PATTERN}$`);\n      const namedExpRegexp = new RegExp(`^${NAMED_EXPRESSION_PATTERN}$`);\n      if (a1CellRefRegexp.test(expressionName) || r1c1CellRefRegexp.test(expressionName)) {\n        return false;\n      }\n      return namedExpRegexp.test(expressionName);\n    }\n    addNamedExpression(expressionName, sheetId, options) {\n      const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n      let namedExpression = store.get(expressionName);\n      if (namedExpression !== undefined) {\n        namedExpression.added = true;\n        namedExpression.displayName = expressionName;\n        namedExpression.options = options;\n      } else {\n        namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), true, options);\n        store.add(namedExpression);\n      }\n      this.addressCache.set(namedExpression.address.row, namedExpression);\n      return namedExpression;\n    }\n    restoreNamedExpression(namedExpression, sheetId) {\n      const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);\n      namedExpression.added = true;\n      store.add(namedExpression);\n      this.addressCache.set(namedExpression.address.row, namedExpression);\n      return namedExpression;\n    }\n    namedExpressionOrPlaceholder(expressionName, sheetId) {\n      var _a;\n      return (_a = this.worksheetStoreOrCreate(sheetId).get(expressionName)) !== null && _a !== void 0 ? _a : this.workbookNamedExpressionOrPlaceholder(expressionName);\n    }\n    workbookNamedExpressionOrPlaceholder(expressionName) {\n      let namedExpression = this.workbookStore.get(expressionName);\n      if (namedExpression === undefined) {\n        namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), false);\n        this.workbookStore.add(namedExpression);\n      }\n      return namedExpression;\n    }\n    remove(expressionName, sheetId) {\n      let store;\n      if (sheetId === undefined) {\n        store = this.workbookStore;\n      } else {\n        store = this.worksheetStore(sheetId);\n      }\n      const namedExpression = store === null || store === void 0 ? void 0 : store.get(expressionName);\n      if (store === undefined || namedExpression === undefined || !namedExpression.added) {\n        throw Error('Named expression does not exist');\n      }\n      store.remove(expressionName);\n      if (store instanceof WorksheetStore && store.mapping.size === 0) {\n        this.worksheetStores.delete(sheetId);\n      }\n      this.addressCache.delete(namedExpression.address.row);\n    }\n    getAllNamedExpressionsNamesInScope(sheetId) {\n      return this.getAllNamedExpressions().filter(({\n        scope\n      }) => scope === sheetId).map(ne => ne.expression.displayName);\n    }\n    getAllNamedExpressionsNames() {\n      return this.getAllNamedExpressions().map(ne => ne.expression.displayName);\n    }\n    getAllNamedExpressions() {\n      const storedNamedExpressions = [];\n      this.workbookStore.getAllNamedExpressions().forEach(expr => {\n        storedNamedExpressions.push({\n          expression: expr,\n          scope: undefined\n        });\n      });\n      this.worksheetStores.forEach((store, sheetNum) => {\n        store.getAllNamedExpressions().forEach(expr => {\n          storedNamedExpressions.push({\n            expression: expr,\n            scope: sheetNum\n          });\n        });\n      });\n      return storedNamedExpressions;\n    }\n    getAllNamedExpressionsForScope(scope) {\n      var _a, _b;\n      if (scope === undefined) {\n        return this.workbookStore.getAllNamedExpressions();\n      } else {\n        return (_b = (_a = this.worksheetStores.get(scope)) === null || _a === void 0 ? void 0 : _a.getAllNamedExpressions()) !== null && _b !== void 0 ? _b : [];\n      }\n    }\n    worksheetStoreOrCreate(sheetId) {\n      let store = this.worksheetStores.get(sheetId);\n      if (!store) {\n        store = new WorksheetStore();\n        this.worksheetStores.set(sheetId, store);\n      }\n      return store;\n    }\n    worksheetStore(sheetId) {\n      return this.worksheetStores.get(sheetId);\n    }\n    nextAddress() {\n      return simpleCellAddress(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, 0, this.nextNamedExpressionRow++);\n    }\n  }\n  NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS = -1;\n  return NamedExpressions;\n})();\nexport const doesContainRelativeReferences = ast => {\n  switch (ast.type) {\n    case AstNodeType.EMPTY:\n    case AstNodeType.NUMBER:\n    case AstNodeType.STRING:\n    case AstNodeType.ERROR:\n    case AstNodeType.ERROR_WITH_RAW_INPUT:\n      return false;\n    case AstNodeType.CELL_REFERENCE:\n      return !ast.reference.isAbsolute();\n    case AstNodeType.CELL_RANGE:\n    case AstNodeType.COLUMN_RANGE:\n    case AstNodeType.ROW_RANGE:\n      return !ast.start.isAbsolute();\n    case AstNodeType.NAMED_EXPRESSION:\n      return false;\n    case AstNodeType.PERCENT_OP:\n    case AstNodeType.PLUS_UNARY_OP:\n    case AstNodeType.MINUS_UNARY_OP:\n      {\n        return doesContainRelativeReferences(ast.value);\n      }\n    case AstNodeType.CONCATENATE_OP:\n    case AstNodeType.EQUALS_OP:\n    case AstNodeType.NOT_EQUAL_OP:\n    case AstNodeType.LESS_THAN_OP:\n    case AstNodeType.GREATER_THAN_OP:\n    case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n    case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n    case AstNodeType.MINUS_OP:\n    case AstNodeType.PLUS_OP:\n    case AstNodeType.TIMES_OP:\n    case AstNodeType.DIV_OP:\n    case AstNodeType.POWER_OP:\n      return doesContainRelativeReferences(ast.left) || doesContainRelativeReferences(ast.right);\n    case AstNodeType.PARENTHESIS:\n      return doesContainRelativeReferences(ast.expression);\n    case AstNodeType.FUNCTION_CALL:\n      {\n        return ast.args.some(arg => doesContainRelativeReferences(arg));\n      }\n    case AstNodeType.ARRAY:\n      {\n        return ast.args.some(row => row.some(arg => doesContainRelativeReferences(arg)));\n      }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}