{"ast":null,"code":"/*\n Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.\n These utils should replace usage of lodash in the production code base. not because they are any better...\n but for the purpose of being a dependency free library.\n\n The hotspots in the code are already written in imperative style for performance reasons.\n so writing several dozen utils which may be slower than the original lodash, does not matter as much\n considering they will not be invoked in hotspots...\n */\nexport function isEmpty(arr) {\n  return arr && arr.length === 0;\n}\nexport function keys(obj) {\n  if (obj === undefined || obj === null) {\n    return [];\n  }\n  return Object.keys(obj);\n}\nexport function values(obj) {\n  var vals = [];\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    vals.push(obj[keys[i]]);\n  }\n  return vals;\n}\nexport function mapValues(obj, callback) {\n  var result = [];\n  var objKeys = keys(obj);\n  for (var idx = 0; idx < objKeys.length; idx++) {\n    var currKey = objKeys[idx];\n    result.push(callback.call(null, obj[currKey], currKey));\n  }\n  return result;\n}\nexport function map(arr, callback) {\n  var result = [];\n  for (var idx = 0; idx < arr.length; idx++) {\n    result.push(callback.call(null, arr[idx], idx));\n  }\n  return result;\n}\nexport function flatten(arr) {\n  var result = [];\n  for (var idx = 0; idx < arr.length; idx++) {\n    var currItem = arr[idx];\n    if (Array.isArray(currItem)) {\n      result = result.concat(flatten(currItem));\n    } else {\n      result.push(currItem);\n    }\n  }\n  return result;\n}\nexport function first(arr) {\n  return isEmpty(arr) ? undefined : arr[0];\n}\nexport function last(arr) {\n  var len = arr && arr.length;\n  return len ? arr[len - 1] : undefined;\n}\nexport function forEach(collection, iteratorCallback) {\n  /* istanbul ignore else */\n  if (Array.isArray(collection)) {\n    for (var i = 0; i < collection.length; i++) {\n      iteratorCallback.call(null, collection[i], i);\n    }\n  } else if (isObject(collection)) {\n    var colKeys = keys(collection);\n    for (var i = 0; i < colKeys.length; i++) {\n      var key = colKeys[i];\n      var value = collection[key];\n      iteratorCallback.call(null, value, key);\n    }\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\nexport function isString(item) {\n  return typeof item === \"string\";\n}\nexport function isUndefined(item) {\n  return item === undefined;\n}\nexport function isFunction(item) {\n  return item instanceof Function;\n}\nexport function drop(arr, howMuch) {\n  if (howMuch === void 0) {\n    howMuch = 1;\n  }\n  return arr.slice(howMuch, arr.length);\n}\nexport function dropRight(arr, howMuch) {\n  if (howMuch === void 0) {\n    howMuch = 1;\n  }\n  return arr.slice(0, arr.length - howMuch);\n}\nexport function filter(arr, predicate) {\n  var result = [];\n  if (Array.isArray(arr)) {\n    for (var i = 0; i < arr.length; i++) {\n      var item = arr[i];\n      if (predicate.call(null, item)) {\n        result.push(item);\n      }\n    }\n  }\n  return result;\n}\nexport function reject(arr, predicate) {\n  return filter(arr, function (item) {\n    return !predicate(item);\n  });\n}\nexport function pick(obj, predicate) {\n  var keys = Object.keys(obj);\n  var result = {};\n  for (var i = 0; i < keys.length; i++) {\n    var currKey = keys[i];\n    var currItem = obj[currKey];\n    if (predicate(currItem)) {\n      result[currKey] = currItem;\n    }\n  }\n  return result;\n}\nexport function has(obj, prop) {\n  if (isObject(obj)) {\n    return obj.hasOwnProperty(prop);\n  }\n  return false;\n}\nexport function contains(arr, item) {\n  return find(arr, function (currItem) {\n    return currItem === item;\n  }) !== undefined ? true : false;\n}\n/**\n * shallow clone\n */\nexport function cloneArr(arr) {\n  var newArr = [];\n  for (var i = 0; i < arr.length; i++) {\n    newArr.push(arr[i]);\n  }\n  return newArr;\n}\n/**\n * shallow clone\n */\nexport function cloneObj(obj) {\n  var clonedObj = {};\n  for (var key in obj) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      clonedObj[key] = obj[key];\n    }\n  }\n  return clonedObj;\n}\nexport function find(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i];\n    if (predicate.call(null, item)) {\n      return item;\n    }\n  }\n  return undefined;\n}\nexport function findAll(arr, predicate) {\n  var found = [];\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i];\n    if (predicate.call(null, item)) {\n      found.push(item);\n    }\n  }\n  return found;\n}\nexport function reduce(arrOrObj, iterator, initial) {\n  var isArr = Array.isArray(arrOrObj);\n  var vals = isArr ? arrOrObj : values(arrOrObj);\n  var objKeys = isArr ? [] : keys(arrOrObj);\n  var accumulator = initial;\n  for (var i = 0; i < vals.length; i++) {\n    accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);\n  }\n  return accumulator;\n}\nexport function compact(arr) {\n  return reject(arr, function (item) {\n    return item === null || item === undefined;\n  });\n}\nexport function uniq(arr, identity) {\n  if (identity === void 0) {\n    identity = function (item) {\n      return item;\n    };\n  }\n  var identities = [];\n  return reduce(arr, function (result, currItem) {\n    var currIdentity = identity(currItem);\n    if (contains(identities, currIdentity)) {\n      return result;\n    } else {\n      identities.push(currIdentity);\n      return result.concat(currItem);\n    }\n  }, []);\n}\nexport function partial(func) {\n  var restArgs = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    restArgs[_i - 1] = arguments[_i];\n  }\n  var firstArg = [null];\n  var allArgs = firstArg.concat(restArgs);\n  return Function.bind.apply(func, allArgs);\n}\nexport function isArray(obj) {\n  return Array.isArray(obj);\n}\nexport function isRegExp(obj) {\n  return obj instanceof RegExp;\n}\nexport function isObject(obj) {\n  return obj instanceof Object;\n}\nexport function every(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (!predicate(arr[i], i)) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function difference(arr, values) {\n  return reject(arr, function (item) {\n    return contains(values, item);\n  });\n}\nexport function some(arr, predicate) {\n  for (var i = 0; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function indexOf(arr, value) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport function sortBy(arr, orderFunc) {\n  var result = cloneArr(arr);\n  result.sort(function (a, b) {\n    return orderFunc(a) - orderFunc(b);\n  });\n  return result;\n}\nexport function zipObject(keys, values) {\n  if (keys.length !== values.length) {\n    throw Error(\"can't zipObject with different number of keys and values!\");\n  }\n  var result = {};\n  for (var i = 0; i < keys.length; i++) {\n    result[keys[i]] = values[i];\n  }\n  return result;\n}\n/**\n * mutates! (and returns) target\n */\nexport function assign(target) {\n  var sources = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n  for (var i = 0; i < sources.length; i++) {\n    var curSource = sources[i];\n    var currSourceKeys = keys(curSource);\n    for (var j = 0; j < currSourceKeys.length; j++) {\n      var currKey = currSourceKeys[j];\n      target[currKey] = curSource[currKey];\n    }\n  }\n  return target;\n}\n/**\n * mutates! (and returns) target\n */\nexport function assignNoOverwrite(target) {\n  var sources = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n  for (var i = 0; i < sources.length; i++) {\n    var curSource = sources[i];\n    if (isUndefined(curSource)) {\n      continue;\n    }\n    var currSourceKeys = keys(curSource);\n    for (var j = 0; j < currSourceKeys.length; j++) {\n      var currKey = currSourceKeys[j];\n      if (!has(target, currKey)) {\n        target[currKey] = curSource[currKey];\n      }\n    }\n  }\n  return target;\n}\nexport function defaults() {\n  var sources = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    sources[_i] = arguments[_i];\n  }\n  return assignNoOverwrite.apply(null, [{}].concat(sources));\n}\nexport function groupBy(arr, groupKeyFunc) {\n  var result = {};\n  forEach(arr, function (item) {\n    var currGroupKey = groupKeyFunc(item);\n    var currGroupArr = result[currGroupKey];\n    if (currGroupArr) {\n      currGroupArr.push(item);\n    } else {\n      result[currGroupKey] = [item];\n    }\n  });\n  return result;\n}\n/**\n * Merge obj2 into obj1.\n * Will overwrite existing properties with the same name\n */\nexport function merge(obj1, obj2) {\n  var result = cloneObj(obj1);\n  var keys2 = keys(obj2);\n  for (var i = 0; i < keys2.length; i++) {\n    var key = keys2[i];\n    var value = obj2[key];\n    result[key] = value;\n  }\n  return result;\n}\nexport function NOOP() {}\nexport function IDENTITY(item) {\n  return item;\n}\n/**\n * Will return a new packed array with same values.\n */\nexport function packArray(holeyArr) {\n  var result = [];\n  for (var i = 0; i < holeyArr.length; i++) {\n    var orgValue = holeyArr[i];\n    result.push(orgValue !== undefined ? orgValue : undefined);\n  }\n  return result;\n}\nexport function PRINT_ERROR(msg) {\n  /* istanbul ignore else - can't override global.console in node.js */\n  if (console && console.error) {\n    console.error(\"Error: \" + msg);\n  }\n}\nexport function PRINT_WARNING(msg) {\n  /* istanbul ignore else - can't override global.console in node.js*/\n  if (console && console.warn) {\n    // TODO: modify docs accordingly\n    console.warn(\"Warning: \" + msg);\n  }\n}\nexport function isES2015MapSupported() {\n  return typeof Map === \"function\";\n}\nexport function applyMixins(derivedCtor, baseCtors) {\n  baseCtors.forEach(function (baseCtor) {\n    var baseProto = baseCtor.prototype;\n    Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n      if (propName === \"constructor\") {\n        return;\n      }\n      var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n      // Handle Accessors\n      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n      } else {\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n      }\n    });\n  });\n}\n// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nexport function toFastProperties(toBecomeFast) {\n  function FakeConstructor() {}\n  // If our object is used as a constructor it would receive\n  FakeConstructor.prototype = toBecomeFast;\n  var fakeInstance = new FakeConstructor();\n  function fakeAccess() {\n    return typeof fakeInstance.bar;\n  }\n  // help V8 understand this is a \"real\" prototype by actually using\n  // the fake instance.\n  fakeAccess();\n  fakeAccess();\n  return toBecomeFast;\n  // Eval prevents optimization of this method (even though this is dead code)\n  /* istanbul ignore next */\n  // tslint:disable-next-line\n  eval(toBecomeFast);\n}\nexport function peek(arr) {\n  return arr[arr.length - 1];\n}\n/* istanbul ignore next - for performance tracing*/\nexport function timer(func) {\n  var start = new Date().getTime();\n  var val = func();\n  var end = new Date().getTime();\n  var total = end - start;\n  return {\n    time: total,\n    value: val\n  };\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}