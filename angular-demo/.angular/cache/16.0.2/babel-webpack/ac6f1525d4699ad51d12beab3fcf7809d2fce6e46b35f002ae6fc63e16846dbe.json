{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { equalSimpleCellAddress, isSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { SheetsNotEqual } from './errors';\nimport { AstNodeType } from './parser';\nimport { RowsSpan } from './Span';\nexport const WRONG_RANGE_SIZE = 'AbsoluteCellRange: Wrong range size';\nexport function isSimpleCellRange(obj) {\n  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {\n    return 'start' in obj && isSimpleCellAddress(obj.start) && 'end' in obj && isSimpleCellAddress(obj.end);\n  } else {\n    return false;\n  }\n}\nexport const simpleCellRange = (start, end) => ({\n  start,\n  end\n});\nexport class AbsoluteCellRange {\n  constructor(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    this.start = simpleCellAddress(start.sheet, start.col, start.row);\n    this.end = simpleCellAddress(end.sheet, end.col, end.row);\n  }\n  get sheet() {\n    return this.start.sheet;\n  }\n  static fromSimpleCellAddresses(start, end) {\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    const width = end.col - start.col;\n    const height = end.row - start.row;\n    if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(start, end);\n    }\n    if (Number.isFinite(height)) {\n      return new AbsoluteRowRange(start.sheet, start.row, end.row);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  static fromAst(ast, baseAddress) {\n    if (ast.type === AstNodeType.CELL_RANGE) {\n      return AbsoluteCellRange.fromCellRange(ast, baseAddress);\n    } else if (ast.type === AstNodeType.COLUMN_RANGE) {\n      return AbsoluteColumnRange.fromColumnRange(ast, baseAddress);\n    } else {\n      return AbsoluteRowRange.fromRowRangeAst(ast, baseAddress);\n    }\n  }\n  static fromAstOrUndef(ast, baseAddress) {\n    try {\n      return AbsoluteCellRange.fromAst(ast, baseAddress);\n    } catch (_e) {\n      return undefined;\n    }\n  }\n  static fromCellRange(x, baseAddress) {\n    return new AbsoluteCellRange(x.start.toSimpleCellAddress(baseAddress), x.end.toSimpleCellAddress(baseAddress));\n  }\n  static spanFrom(topLeftCorner, width, height) {\n    const ret = AbsoluteCellRange.spanFromOrUndef(topLeftCorner, width, height);\n    if (ret === undefined) {\n      throw new Error(WRONG_RANGE_SIZE);\n    }\n    return ret;\n  }\n  static spanFromOrUndef(topLeftCorner, width, height) {\n    if (!Number.isFinite(width) && Number.isFinite(height)) {\n      if (topLeftCorner.col !== 0) {\n        return undefined;\n      }\n      return new AbsoluteRowRange(topLeftCorner.sheet, topLeftCorner.row, topLeftCorner.row + height - 1);\n    } else if (!Number.isFinite(height) && Number.isFinite(width)) {\n      if (topLeftCorner.row !== 0) {\n        return undefined;\n      }\n      return new AbsoluteColumnRange(topLeftCorner.sheet, topLeftCorner.col, topLeftCorner.col + width - 1);\n    } else if (Number.isFinite(height) && Number.isFinite(width)) {\n      return new AbsoluteCellRange(topLeftCorner, simpleCellAddress(topLeftCorner.sheet, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1));\n    }\n    return undefined;\n  }\n  static fromCoordinates(sheet, x1, y1, x2, y2) {\n    return new AbsoluteCellRange(simpleCellAddress(sheet, x1, y1), simpleCellAddress(sheet, x2, y2));\n  }\n  isFinite() {\n    return Number.isFinite(this.size());\n  }\n  doesOverlap(other) {\n    if (this.start.sheet != other.start.sheet) {\n      return false;\n    }\n    if (this.end.row < other.start.row || this.start.row > other.end.row) {\n      return false;\n    }\n    if (this.end.col < other.start.col || this.start.col > other.end.col) {\n      return false;\n    }\n    return true;\n  }\n  addressInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row && this.start.col <= address.col && this.end.col >= address.col;\n  }\n  columnInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.col <= address.col && this.end.col >= address.col;\n  }\n  rowInRange(address) {\n    if (this.sheet !== address.sheet) {\n      return false;\n    }\n    return this.start.row <= address.row && this.end.row >= address.row;\n  }\n  containsRange(range) {\n    return this.addressInRange(range.start) && this.addressInRange(range.end);\n  }\n  intersectionWith(other) {\n    if (this.sheet !== other.start.sheet) {\n      return undefined;\n    }\n    const startRow = Math.max(this.start.row, other.start.row);\n    const endRow = Math.min(this.end.row, other.end.row);\n    const startCol = Math.max(this.start.col, other.start.col);\n    const endCol = Math.min(this.end.col, other.end.col);\n    if (startRow > endRow || startCol > endCol) {\n      return undefined;\n    }\n    return new AbsoluteCellRange(simpleCellAddress(this.sheet, startCol, startRow), simpleCellAddress(this.sheet, endCol, endRow));\n  }\n  includesRow(row) {\n    return this.start.row < row && this.end.row >= row;\n  }\n  includesColumn(column) {\n    return this.start.col < column && this.end.col >= column;\n  }\n  shiftByRows(numberOfRows) {\n    this.start.row += numberOfRows;\n    this.end.row += numberOfRows;\n  }\n  expandByRows(numberOfRows) {\n    this.end.row += numberOfRows;\n  }\n  shiftByColumns(numberOfColumns) {\n    this.start.col += numberOfColumns;\n    this.end.col += numberOfColumns;\n  }\n  shifted(byCols, byRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col + byCols, this.start.row + byRows), this.width(), this.height());\n  }\n  expandByColumns(numberOfColumns) {\n    this.end.col += numberOfColumns;\n  }\n  moveToSheet(toSheet) {\n    this.start.sheet = toSheet;\n    this.end.sheet = toSheet;\n  }\n  removeSpan(span) {\n    if (span instanceof RowsSpan) {\n      this.removeRows(span.start, span.end);\n    } else {\n      this.removeColumns(span.start, span.end);\n    }\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0 || this.height() <= 0;\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, this.start.col, startRow), this.width(), numberOfRows);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return AbsoluteCellRange.spanFrom(simpleCellAddress(this.sheet, startColumn, this.start.row), numberOfColumns, this.height());\n  }\n  toString() {\n    return `${this.start.sheet},${this.start.col},${this.start.row},${this.end.col},${this.end.row}`;\n  }\n  width() {\n    return this.end.col - this.start.col + 1;\n  }\n  height() {\n    return this.end.row - this.start.row + 1;\n  }\n  size() {\n    return this.height() * this.width();\n  }\n  arrayOfAddressesInRange() {\n    const result = [];\n    for (let y = 0; y < this.height(); ++y) {\n      result[y] = [];\n      for (let x = 0; x < this.width(); ++x) {\n        const value = simpleCellAddress(this.sheet, this.start.col + x, this.start.row + y);\n        result[y].push(value);\n      }\n    }\n    return result;\n  }\n  withStart(newStart) {\n    return new AbsoluteCellRange(newStart, this.end);\n  }\n  sameDimensionsAs(other) {\n    return this.width() === other.width() && this.height() === other.height();\n  }\n  sameAs(other) {\n    return equalSimpleCellAddress(this.start, other.start) && equalSimpleCellAddress(this.end, other.end);\n  }\n  addressesArrayMap(dependencyGraph, op) {\n    const ret = [];\n    let currentRow = this.start.row;\n    while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n      let currentColumn = this.start.col;\n      const tmp = [];\n      while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n        tmp.push(op(simpleCellAddress(this.start.sheet, currentColumn, currentRow)));\n        currentColumn++;\n      }\n      ret.push(tmp);\n      currentRow++;\n    }\n    return ret;\n  }\n  addresses(dependencyGraph) {\n    const ret = [];\n    let currentRow = this.start.row;\n    const limitRow = this.effectiveEndRow(dependencyGraph);\n    const limitColumn = this.effectiveEndColumn(dependencyGraph);\n    while (currentRow <= limitRow) {\n      let currentColumn = this.start.col;\n      while (currentColumn <= limitColumn) {\n        ret.push(simpleCellAddress(this.start.sheet, currentColumn, currentRow));\n        currentColumn++;\n      }\n      currentRow++;\n    }\n    return ret;\n  }\n  *addressesWithDirection(right, bottom, dependencyGraph) {\n    if (right > 0) {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.effectiveEndColumn(dependencyGraph);\n          while (currentColumn >= this.start.col) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn -= 1;\n          }\n          currentRow += 1;\n        }\n      }\n    } else {\n      if (bottom > 0) {\n        let currentRow = this.effectiveEndRow(dependencyGraph);\n        while (currentRow >= this.start.row) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow -= 1;\n        }\n      } else {\n        let currentRow = this.start.row;\n        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {\n          let currentColumn = this.start.col;\n          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {\n            yield simpleCellAddress(this.start.sheet, currentColumn, currentRow);\n            currentColumn += 1;\n          }\n          currentRow += 1;\n        }\n      }\n    }\n  }\n  getAddress(col, row) {\n    if (col < 0 || row < 0 || row > this.height() - 1 || col > this.width() - 1) {\n      throw Error('Index out of bound');\n    }\n    return simpleCellAddress(this.start.sheet, this.start.col + col, this.start.row + row);\n  }\n  exceedsSheetSizeLimits(maxColumns, maxRows) {\n    return this.end.col >= maxColumns || this.end.row >= maxRows;\n  }\n  effectiveEndColumn(_dependencyGraph) {\n    return this.end.col;\n  }\n  effectiveEndRow(_dependencyGraph) {\n    return this.end.row;\n  }\n  effectiveWidth(_dependencyGraph) {\n    return this.width();\n  }\n  effectiveHeight(_dependencyGraph) {\n    return this.height();\n  }\n  removeRows(rowStart, rowEnd) {\n    if (rowStart > this.end.row) {\n      return;\n    }\n    if (rowEnd < this.start.row) {\n      const numberOfRows = rowEnd - rowStart + 1;\n      return this.shiftByRows(-numberOfRows);\n    }\n    if (rowStart <= this.start.row) {\n      this.start.row = rowStart;\n    }\n    this.end.row -= Math.min(rowEnd, this.end.row) - rowStart + 1;\n  }\n  removeColumns(columnStart, columnEnd) {\n    if (columnStart > this.end.col) {\n      return;\n    }\n    if (columnEnd < this.start.col) {\n      const numberOfColumns = columnEnd - columnStart + 1;\n      return this.shiftByColumns(-numberOfColumns);\n    }\n    if (columnStart <= this.start.col) {\n      this.start.col = columnStart;\n    }\n    this.end.col -= Math.min(columnEnd, this.end.col) - columnStart + 1;\n  }\n}\nexport class AbsoluteColumnRange extends AbsoluteCellRange {\n  constructor(sheet, columnStart, columnEnd) {\n    super(simpleCellAddress(sheet, columnStart, 0), simpleCellAddress(sheet, columnEnd, Number.POSITIVE_INFINITY));\n  }\n  static fromColumnRange(x, baseAddress) {\n    const start = x.start.toSimpleColumnAddress(baseAddress);\n    const end = x.end.toSimpleColumnAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteColumnRange(start.sheet, start.col, end.col);\n  }\n  shouldBeRemoved() {\n    return this.width() <= 0;\n  }\n  shiftByRows(_numberOfRows) {\n    return;\n  }\n  expandByRows(_numberOfRows) {\n    return;\n  }\n  shifted(byCols, _byRows) {\n    return new AbsoluteColumnRange(this.sheet, this.start.col + byCols, this.end.col + byCols);\n  }\n  rangeWithSameHeight(startColumn, numberOfColumns) {\n    return new AbsoluteColumnRange(this.sheet, startColumn, startColumn + numberOfColumns - 1);\n  }\n  exceedsSheetSizeLimits(maxColumns, _maxRows) {\n    return this.end.col >= maxColumns;\n  }\n  effectiveEndRow(dependencyGraph) {\n    return this.effectiveHeight(dependencyGraph) - 1;\n  }\n  effectiveHeight(dependencyGraph) {\n    return dependencyGraph.getSheetHeight(this.sheet);\n  }\n  removeRows(_rowStart, _rowEnd) {\n    return;\n  }\n}\nexport class AbsoluteRowRange extends AbsoluteCellRange {\n  constructor(sheet, rowStart, rowEnd) {\n    super(simpleCellAddress(sheet, 0, rowStart), simpleCellAddress(sheet, Number.POSITIVE_INFINITY, rowEnd));\n  }\n  static fromRowRangeAst(x, baseAddress) {\n    const start = x.start.toSimpleRowAddress(baseAddress);\n    const end = x.end.toSimpleRowAddress(baseAddress);\n    if (start.sheet !== end.sheet) {\n      throw new SheetsNotEqual(start.sheet, end.sheet);\n    }\n    return new AbsoluteRowRange(start.sheet, start.row, end.row);\n  }\n  shouldBeRemoved() {\n    return this.height() <= 0;\n  }\n  shiftByColumns(_numberOfColumns) {\n    return;\n  }\n  expandByColumns(_numberOfColumns) {\n    return;\n  }\n  shifted(byCols, byRows) {\n    return new AbsoluteRowRange(this.sheet, this.start.row + byRows, this.end.row + byRows);\n  }\n  rangeWithSameWidth(startRow, numberOfRows) {\n    return new AbsoluteRowRange(this.sheet, startRow, startRow + numberOfRows - 1);\n  }\n  exceedsSheetSizeLimits(_maxColumns, maxRows) {\n    return this.end.row >= maxRows;\n  }\n  effectiveEndColumn(dependencyGraph) {\n    return this.effectiveWidth(dependencyGraph) - 1;\n  }\n  effectiveWidth(dependencyGraph) {\n    return dependencyGraph.getSheetWidth(this.sheet);\n  }\n  removeColumns(_columnStart, _columnEnd) {\n    return;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}