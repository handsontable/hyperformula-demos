{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ErrorType } from '../Cell';\nimport { MissingTranslationError, ProtectedFunctionTranslationError } from '../errors';\nimport { UIElement } from './index';\nexport class TranslationPackage {\n  constructor(functions, errors, ui) {\n    this.functions = functions;\n    this.errors = errors;\n    this.ui = ui;\n    this._protectedTranslations = {\n      'VERSION': 'VERSION'\n    };\n    this.checkUI();\n    this.checkErrors();\n    this.checkFunctionTranslations(this.functions);\n    Object.assign(this.functions, this._protectedTranslations);\n  }\n  extendFunctions(additionalFunctionTranslations) {\n    this.checkFunctionTranslations(additionalFunctionTranslations);\n    Object.assign(this.functions, additionalFunctionTranslations);\n  }\n  buildFunctionMapping() {\n    return Object.keys(this.functions).reduce((ret, key) => {\n      ret[this.functions[key]] = key;\n      return ret;\n    }, {});\n  }\n  buildErrorMapping() {\n    return Object.keys(this.errors).reduce((ret, key) => {\n      ret[this.errors[key]] = key;\n      return ret;\n    }, {});\n  }\n  isFunctionTranslated(key) {\n    return this.functions[key] !== undefined;\n  }\n  getFunctionTranslations(functionIds) {\n    const translations = [];\n    for (const functionId of functionIds) {\n      if (this.isFunctionTranslated(functionId)) {\n        translations.push(this.functions[functionId]);\n      }\n    }\n    return translations;\n  }\n  getFunctionTranslation(key) {\n    const val = this.functions[key];\n    if (val === undefined) {\n      throw new MissingTranslationError(`functions.${key}`);\n    } else {\n      return val;\n    }\n  }\n  getMaybeFunctionTranslation(key) {\n    return this.functions[key];\n  }\n  getErrorTranslation(key) {\n    if (key === ErrorType.LIC) {\n      return `#${ErrorType.LIC}!`;\n    }\n    const val = this.errors[key];\n    if (val === undefined) {\n      throw new MissingTranslationError(`errors.${key}`);\n    } else {\n      return val;\n    }\n  }\n  getUITranslation(key) {\n    const val = this.ui[key];\n    if (val === undefined) {\n      throw new MissingTranslationError(`ui.${key}`);\n    } else {\n      return val;\n    }\n  }\n  checkUI() {\n    for (const key of Object.values(UIElement)) {\n      if (!(key in this.ui)) {\n        throw new MissingTranslationError(`ui.${key}`);\n      }\n    }\n  }\n  checkErrors() {\n    for (const key of Object.values(ErrorType)) {\n      if (!(key in this.errors) && key !== ErrorType.LIC) {\n        throw new MissingTranslationError(`errors.${key}`);\n      }\n    }\n  }\n  checkFunctionTranslations(functions) {\n    const functionNames = new Set(Object.getOwnPropertyNames(functions));\n    for (const protectedTranslation of Object.getOwnPropertyNames(this._protectedTranslations)) {\n      if (functionNames.has(protectedTranslation)) {\n        throw new ProtectedFunctionTranslationError(protectedTranslation);\n      }\n    }\n  }\n}\nexport function buildTranslationPackage(rawTranslationPackage) {\n  return new TranslationPackage(Object.assign({}, rawTranslationPackage.functions), Object.assign({}, rawTranslationPackage.errors), Object.assign({}, rawTranslationPackage.ui));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}