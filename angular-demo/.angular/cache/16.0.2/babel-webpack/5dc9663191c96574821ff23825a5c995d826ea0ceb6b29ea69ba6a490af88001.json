{"ast":null,"code":"import { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, PROD_TYPE } from \"../../grammar/lookahead\";\nimport { forEach, has, isES2015MapSupported } from \"../../../utils/utils\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nimport { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX } from \"../../grammar/keys\";\nimport { collectMethods, getProductionDslName } from \"../../grammar/gast/gast\";\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nvar LooksAhead = /** @class */function () {\n  function LooksAhead() {}\n  LooksAhead.prototype.initLooksAhead = function (config) {\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n    this.maxLookahead = has(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n    this.lookAheadFuncsCache = isES2015MapSupported() ? new Map() : [];\n    // Performance optimization on newer engines that support ES6 Map\n    // For larger Maps this is slightly faster than using a plain object (array in our case).\n    /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */\n    if (isES2015MapSupported()) {\n      this.getLaFuncFromCache = this.getLaFuncFromMap;\n      this.setLaFuncCache = this.setLaFuncCacheUsingMap;\n    } else {\n      this.getLaFuncFromCache = this.getLaFuncFromObj;\n      this.setLaFuncCache = this.setLaFuncUsingObj;\n    }\n  };\n  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {\n    var _this = this;\n    forEach(rules, function (currRule) {\n      _this.TRACE_INIT(currRule.name + \" Rule Lookahead\", function () {\n        var _a = collectMethods(currRule),\n          alternation = _a.alternation,\n          repetition = _a.repetition,\n          option = _a.option,\n          repetitionMandatory = _a.repetitionMandatory,\n          repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,\n          repetitionWithSeparator = _a.repetitionWithSeparator;\n        forEach(alternation, function (currProd) {\n          var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n          _this.TRACE_INIT(\"\" + getProductionDslName(currProd) + prodIdx, function () {\n            var laFunc = buildLookaheadFuncForOr(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);\n            var key = getKeyForAutomaticLookahead(_this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n            _this.setLaFuncCache(key, laFunc);\n          });\n        });\n        forEach(repetition, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, PROD_TYPE.REPETITION, currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach(option, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, PROD_TYPE.OPTION, currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach(repetitionMandatory, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach(repetitionMandatoryWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, getProductionDslName(currProd));\n        });\n        forEach(repetitionWithSeparator, function (currProd) {\n          _this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, getProductionDslName(currProd));\n        });\n      });\n    });\n  };\n  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n    var _this = this;\n    this.TRACE_INIT(\"\" + dslMethodName + (prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n      var laFunc = buildLookaheadFuncForOptionalProd(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);\n      var key = getKeyForAutomaticLookahead(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n      _this.setLaFuncCache(key, laFunc);\n    });\n  };\n  LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {\n    return buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled);\n  };\n  LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    return buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n  };\n  // this actually returns a number, but it is always used as a string (object prop key)\n  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.getLaFuncFromCache = function (key) {\n    return undefined;\n  };\n  LooksAhead.prototype.getLaFuncFromMap = function (key) {\n    return this.lookAheadFuncsCache.get(key);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  LooksAhead.prototype.getLaFuncFromObj = function (key) {\n    return this.lookAheadFuncsCache[key];\n  };\n  /* istanbul ignore next */\n  LooksAhead.prototype.setLaFuncCache = function (key, value) {};\n  LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {\n    this.lookAheadFuncsCache.set(key, value);\n  };\n  /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */\n  LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {\n    this.lookAheadFuncsCache[key] = value;\n  };\n  return LooksAhead;\n}();\nexport { LooksAhead };\n//# sourceMappingURL=looksahead.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}