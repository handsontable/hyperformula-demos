{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { getRawValue } from '../interpreter/InterpreterValue';\nimport { forceNormalizeString } from '../interpreter/ArithmeticHelper';\nimport { findLastOccurrenceInOrderedRange } from '../interpreter/binarySearch';\nexport class AdvancedFind {\n  constructor(dependencyGraph) {\n    this.dependencyGraph = dependencyGraph;\n  }\n  advancedFind(keyMatcher, rangeValue) {\n    let values;\n    const range = rangeValue.range;\n    if (range === undefined) {\n      values = rangeValue.valuesFromTopLeftCorner();\n    } else {\n      values = this.dependencyGraph.computeListOfValuesInRange(range);\n    }\n    for (let i = 0; i < values.length; i++) {\n      if (keyMatcher(getRawValue(values[i]))) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /*\r\n   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true\r\n   */\n  basicFind(searchKey, rangeValue, searchCoordinate, {\n    ordering,\n    matchExactly\n  }) {\n    const normalizedSearchKey = typeof searchKey === 'string' ? forceNormalizeString(searchKey) : searchKey;\n    const range = rangeValue.range;\n    if (range === undefined) {\n      return this.findNormalizedValue(normalizedSearchKey, rangeValue.valuesFromTopLeftCorner());\n    }\n    if (ordering === 'none') {\n      return this.findNormalizedValue(normalizedSearchKey, this.dependencyGraph.computeListOfValuesInRange(range));\n    }\n    return findLastOccurrenceInOrderedRange(normalizedSearchKey, range, {\n      searchCoordinate,\n      orderingDirection: ordering,\n      matchExactly\n    }, this.dependencyGraph);\n  }\n  findNormalizedValue(searchKey, searchArray) {\n    return searchArray.map(getRawValue).map(val => typeof val === 'string' ? forceNormalizeString(val) : val).indexOf(searchKey);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}