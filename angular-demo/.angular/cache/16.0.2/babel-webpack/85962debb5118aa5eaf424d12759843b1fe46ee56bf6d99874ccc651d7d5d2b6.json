{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from '../../Cell';\n/**\r\n * Mapping from cell addresses to vertices\r\n *\r\n * Uses Map to store addresses, having minimal memory usage for sparse sheets but not necessarily constant set/lookup.\r\n */\nexport class SparseStrategy {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    /**\r\n     * Map of Maps in which actual data is stored.\r\n     *\r\n     * Key of map in first level is column number.\r\n     * Key of map in second level is row number.\r\n     */\n    this.mapping = new Map();\n  }\n  /** @inheritDoc */\n  getCell(address) {\n    var _a;\n    return (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row);\n  }\n  /** @inheritDoc */\n  setCell(address, newVertex) {\n    this.width = Math.max(this.width, address.col + 1);\n    this.height = Math.max(this.height, address.row + 1);\n    let colMapping = this.mapping.get(address.col);\n    if (!colMapping) {\n      colMapping = new Map();\n      this.mapping.set(address.col, colMapping);\n    }\n    colMapping.set(address.row, newVertex);\n  }\n  /** @inheritDoc */\n  has(address) {\n    var _a;\n    return !!((_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row));\n  }\n  /** @inheritDoc */\n  getHeight() {\n    return this.height;\n  }\n  /** @inheritDoc */\n  getWidth() {\n    return this.width;\n  }\n  removeCell(address) {\n    var _a;\n    (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.delete(address.row);\n  }\n  addRows(row, numberOfRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= row) {\n          tmpMapping.set(rowNumber + numberOfRows, vertex);\n          rowMapping.delete(rowNumber);\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    this.height += numberOfRows;\n  }\n  addColumns(column, numberOfColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= column) {\n        tmpMapping.set(colNumber + numberOfColumns, rowMapping);\n        this.mapping.delete(colNumber);\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    this.width += numberOfColumns;\n  }\n  removeRows(removedRows) {\n    this.mapping.forEach(rowMapping => {\n      const tmpMapping = new Map();\n      rowMapping.forEach((vertex, rowNumber) => {\n        if (rowNumber >= removedRows.rowStart) {\n          rowMapping.delete(rowNumber);\n          if (rowNumber > removedRows.rowEnd) {\n            tmpMapping.set(rowNumber - removedRows.numberOfRows, vertex);\n          }\n        }\n      });\n      tmpMapping.forEach((vertex, rowNumber) => {\n        rowMapping.set(rowNumber, vertex);\n      });\n    });\n    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);\n    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);\n    this.height = Math.max(0, this.height - numberOfRowsRemoved);\n  }\n  removeColumns(removedColumns) {\n    const tmpMapping = new Map();\n    this.mapping.forEach((rowMapping, colNumber) => {\n      if (colNumber >= removedColumns.columnStart) {\n        this.mapping.delete(colNumber);\n        if (colNumber > removedColumns.columnEnd) {\n          tmpMapping.set(colNumber - removedColumns.numberOfColumns, rowMapping);\n        }\n      }\n    });\n    tmpMapping.forEach((rowMapping, colNumber) => {\n      this.mapping.set(colNumber, rowMapping);\n    });\n    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);\n    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);\n    this.width = Math.max(0, this.width - numberOfColumnsRemoved);\n  }\n  *getEntries(sheet) {\n    for (const [colNumber, col] of this.mapping) {\n      for (const [rowNumber, value] of col) {\n        yield [simpleCellAddress(sheet, colNumber, rowNumber), value];\n      }\n    }\n  }\n  *verticesFromColumn(column) {\n    const colMapping = this.mapping.get(column);\n    if (colMapping === undefined) {\n      return;\n    }\n    for (const [_, vertex] of colMapping) {\n      yield vertex;\n    }\n  }\n  *verticesFromRow(row) {\n    for (const colMapping of this.mapping.values()) {\n      const rowVertex = colMapping.get(row);\n      if (rowVertex !== undefined) {\n        yield rowVertex;\n      }\n    }\n  }\n  *verticesFromColumnsSpan(columnsSpan) {\n    for (const column of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(column);\n      if (colMapping === undefined) {\n        continue;\n      }\n      for (const [_, vertex] of colMapping) {\n        yield vertex;\n      }\n    }\n  }\n  *verticesFromRowsSpan(rowsSpan) {\n    for (const colMapping of this.mapping.values()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield rowVertex;\n        }\n      }\n    }\n  }\n  *entriesFromRowsSpan(rowsSpan) {\n    for (const [col, colMapping] of this.mapping.entries()) {\n      for (const row of rowsSpan.rows()) {\n        const rowVertex = colMapping.get(row);\n        if (rowVertex !== undefined) {\n          yield [simpleCellAddress(rowsSpan.sheet, col, row), rowVertex];\n        }\n      }\n    }\n  }\n  *entriesFromColumnsSpan(columnsSpan) {\n    for (const col of columnsSpan.columns()) {\n      const colMapping = this.mapping.get(col);\n      if (colMapping !== undefined) {\n        for (const [row, vertex] of colMapping.entries()) {\n          yield [simpleCellAddress(columnsSpan.sheet, col, row), vertex];\n        }\n      }\n    }\n  }\n  *vertices() {\n    for (const [_, col] of this.mapping) {\n      for (const [_, value] of col) {\n        if (value !== undefined) {\n          yield value;\n        }\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}