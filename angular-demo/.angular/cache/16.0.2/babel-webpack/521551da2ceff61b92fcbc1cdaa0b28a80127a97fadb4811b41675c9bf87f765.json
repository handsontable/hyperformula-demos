{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from './Cell';\nimport { ArrayVertex, FormulaCellVertex, ParsingErrorVertex } from './DependencyGraph';\nimport { buildLexerConfig, Unparser } from './parser';\nexport class Serialization {\n  constructor(dependencyGraph, unparser, exporter) {\n    this.dependencyGraph = dependencyGraph;\n    this.unparser = unparser;\n    this.exporter = exporter;\n  }\n  getCellFormula(address, targetAddress) {\n    const formulaVertex = this.dependencyGraph.getCell(address);\n    if (formulaVertex instanceof FormulaCellVertex) {\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      return this.unparser.unparse(formula, targetAddress);\n    } else if (formulaVertex instanceof ArrayVertex) {\n      const arrayVertexAddress = formulaVertex.getAddress(this.dependencyGraph.lazilyTransformingAstService);\n      if (arrayVertexAddress.row !== address.row || arrayVertexAddress.col !== address.col || arrayVertexAddress.sheet !== address.sheet) {\n        return undefined;\n      }\n      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;\n      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);\n      if (formula !== undefined) {\n        return this.unparser.unparse(formula, targetAddress);\n      }\n    } else if (formulaVertex instanceof ParsingErrorVertex) {\n      return formulaVertex.getFormula();\n    }\n    return undefined;\n  }\n  getCellSerialized(address, targetAddress) {\n    var _a;\n    return (_a = this.getCellFormula(address, targetAddress)) !== null && _a !== void 0 ? _a : this.getRawValue(address);\n  }\n  getCellValue(address) {\n    return this.exporter.exportValue(this.dependencyGraph.getScalarValue(address));\n  }\n  getRawValue(address) {\n    return this.dependencyGraph.getRawValue(address);\n  }\n  getSheetValues(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellValue(arg));\n  }\n  getSheetFormulas(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellFormula(arg));\n  }\n  genericSheetGetter(sheet, getter) {\n    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);\n    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);\n    const arr = new Array(sheetHeight);\n    for (let i = 0; i < sheetHeight; i++) {\n      arr[i] = new Array(sheetWidth);\n      for (let j = 0; j < sheetWidth; j++) {\n        const address = simpleCellAddress(sheet, j, i);\n        arr[i][j] = getter(address);\n      }\n      for (let j = sheetWidth - 1; j >= 0; j--) {\n        if (arr[i][j] === null || arr[i][j] === undefined) {\n          arr[i].pop();\n        } else {\n          break;\n        }\n      }\n    }\n    for (let i = sheetHeight - 1; i >= 0; i--) {\n      if (arr[i].length === 0) {\n        arr.pop();\n      } else {\n        break;\n      }\n    }\n    return arr;\n  }\n  genericAllSheetsGetter(sheetGetter) {\n    const result = {};\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      result[sheetName] = sheetGetter(sheetId);\n    }\n    return result;\n  }\n  getSheetSerialized(sheet) {\n    return this.genericSheetGetter(sheet, arg => this.getCellSerialized(arg));\n  }\n  getAllSheetsValues() {\n    return this.genericAllSheetsGetter(arg => this.getSheetValues(arg));\n  }\n  getAllSheetsFormulas() {\n    return this.genericAllSheetsGetter(arg => this.getSheetFormulas(arg));\n  }\n  getAllSheetsSerialized() {\n    return this.genericAllSheetsGetter(arg => this.getSheetSerialized(arg));\n  }\n  getAllNamedExpressionsSerialized() {\n    const idMap = [];\n    let id = 0;\n    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {\n      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);\n      idMap[sheetId] = id;\n      id++;\n    }\n    return this.dependencyGraph.namedExpressions.getAllNamedExpressions().map(entry => {\n      return {\n        name: entry.expression.displayName,\n        expression: this.getCellSerialized(entry.expression.address),\n        scope: entry.scope !== undefined ? idMap[entry.scope] : undefined,\n        options: entry.expression.options\n      };\n    });\n  }\n  withNewConfig(newConfig, namedExpressions) {\n    const newUnparser = new Unparser(newConfig, buildLexerConfig(newConfig), this.dependencyGraph.sheetMapping.fetchDisplayName, namedExpressions);\n    return new Serialization(this.dependencyGraph, newUnparser, this.exporter);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}