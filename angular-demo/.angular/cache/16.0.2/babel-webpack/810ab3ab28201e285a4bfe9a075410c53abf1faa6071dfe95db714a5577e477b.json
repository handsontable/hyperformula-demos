{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { besseli, besselj, besselk, bessely } from './3rdparty/bessel/bessel';\nimport { beta, binomial, centralF, chisquare, erf, erfc, exponential, gamma, gammafn, gammaln, hypgeom, lognormal, negbin, normal, normalci, poisson, studentt, tci, weibull } from './3rdparty/jstat/jstat';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class StatisticalPlugin extends FunctionPlugin {\n  erf(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ERF'), (lowerBound, upperBound) => {\n      if (upperBound === undefined) {\n        return erf(lowerBound);\n      } else {\n        return erf(upperBound) - erf(lowerBound);\n      }\n    });\n  }\n  erfc(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('ERFC'), erfc);\n  }\n  expondist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('EXPON.DIST'), (x, lambda, cumulative) => {\n      if (cumulative) {\n        return exponential.cdf(x, lambda);\n      } else {\n        return exponential.pdf(x, lambda);\n      }\n    });\n  }\n  fisher(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FISHER'), x => Math.log((1 + x) / (1 - x)) / 2);\n  }\n  fisherinv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FISHERINV'), y => 1 - 2 / (Math.exp(2 * y) + 1));\n  }\n  gamma(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GAMMA'), gammafn);\n  }\n  gammadist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GAMMA.DIST'), (value, alphaVal, betaVal, cumulative) => {\n      if (cumulative) {\n        return gamma.cdf(value, alphaVal, betaVal);\n      } else {\n        return gamma.pdf(value, alphaVal, betaVal);\n      }\n    });\n  }\n  gammaln(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GAMMALN'), gammaln);\n  }\n  gammainv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GAMMA.INV'), gamma.inv);\n  }\n  gauss(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('GAUSS'), z => normal.cdf(z, 0, 1) - 0.5);\n  }\n  betadist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BETA.DIST'), (x, alphaVal, betaVal, cumulative, A, B) => {\n      if (x <= A) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueSmall);\n      } else if (x >= B) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      x = (x - A) / (B - A);\n      if (cumulative) {\n        return beta.cdf(x, alphaVal, betaVal);\n      } else {\n        return beta.pdf(x, alphaVal, betaVal);\n      }\n    });\n  }\n  betainv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BETA.INV'), (x, alphaVal, betaVal, A, B) => {\n      if (A >= B) {\n        return new CellError(ErrorType.NUM, ErrorMessage.WrongOrder);\n      } else {\n        return beta.inv(x, alphaVal, betaVal) * (B - A) + A;\n      }\n    });\n  }\n  binomialdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BINOM.DIST'), (succ, trials, prob, cumulative) => {\n      if (succ > trials) {\n        return new CellError(ErrorType.NUM, ErrorMessage.WrongOrder);\n      }\n      succ = Math.trunc(succ);\n      trials = Math.trunc(trials);\n      if (cumulative) {\n        return binomial.cdf(succ, trials, prob);\n      } else {\n        return binomial.pdf(succ, trials, prob);\n      }\n    });\n  }\n  binomialinv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BINOM.INV'), (trials, prob, alpha) => {\n      trials = Math.trunc(trials);\n      let lower = -1;\n      let upper = trials;\n      while (upper > lower + 1) {\n        const mid = Math.trunc((lower + upper) / 2);\n        if (binomial.cdf(mid, trials, prob) >= alpha) {\n          upper = mid;\n        } else {\n          lower = mid;\n        }\n      }\n      return upper;\n    });\n  }\n  besselifn(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BESSELI'), (x, n) => besseli(x, Math.trunc(n)));\n  }\n  besseljfn(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BESSELJ'), (x, n) => besselj(x, Math.trunc(n)));\n  }\n  besselkfn(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BESSELK'), (x, n) => besselk(x, Math.trunc(n)));\n  }\n  besselyfn(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('BESSELY'), (x, n) => bessely(x, Math.trunc(n)));\n  }\n  chisqdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST'), (x, deg, cumulative) => {\n      deg = Math.trunc(deg);\n      if (cumulative) {\n        return chisquare.cdf(x, deg);\n      } else {\n        return chisquare.pdf(x, deg);\n      }\n    });\n  }\n  chisqdistrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST.RT'), (x, deg) => 1 - chisquare.cdf(x, Math.trunc(deg)));\n  }\n  chisqinv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV'), (p, deg) => chisquare.inv(p, Math.trunc(deg)));\n  }\n  chisqinvrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV.RT'), (p, deg) => chisquare.inv(1.0 - p, Math.trunc(deg)));\n  }\n  fdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('F.DIST'), (x, deg1, deg2, cumulative) => {\n      deg1 = Math.trunc(deg1);\n      deg2 = Math.trunc(deg2);\n      if (cumulative) {\n        return centralF.cdf(x, deg1, deg2);\n      } else {\n        return centralF.pdf(x, deg1, deg2);\n      }\n    });\n  }\n  fdistrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('F.DIST.RT'), (x, deg1, deg2) => 1 - centralF.cdf(x, Math.trunc(deg1), Math.trunc(deg2)));\n  }\n  finv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('F.INV'), (p, deg1, deg2) => centralF.inv(p, Math.trunc(deg1), Math.trunc(deg2)));\n  }\n  finvrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('F.INV.RT'), (p, deg1, deg2) => centralF.inv(1.0 - p, Math.trunc(deg1), Math.trunc(deg2)));\n  }\n  weibulldist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('WEIBULL.DIST'), (x, shape, scale, cumulative) => {\n      if (cumulative) {\n        return weibull.cdf(x, scale, shape);\n      } else {\n        return weibull.pdf(x, scale, shape);\n      }\n    });\n  }\n  poissondist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('POISSON.DIST'), (x, mean, cumulative) => {\n      x = Math.trunc(x);\n      if (cumulative) {\n        return poisson.cdf(x, mean);\n      } else {\n        return poisson.pdf(x, mean);\n      }\n    });\n  }\n  hypgeomdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HYPGEOM.DIST'), (s, numberS, populationS, numberPop, cumulative) => {\n      if (s > numberS || s > populationS || numberS > numberPop || populationS > numberPop) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      if (s + numberPop < populationS + numberS) {\n        return new CellError(ErrorType.NUM, ErrorMessage.ValueLarge);\n      }\n      s = Math.trunc(s);\n      numberS = Math.trunc(numberS);\n      populationS = Math.trunc(populationS);\n      numberPop = Math.trunc(numberPop);\n      if (cumulative) {\n        return hypgeom.cdf(s, numberPop, populationS, numberS);\n      } else {\n        return hypgeom.pdf(s, numberPop, populationS, numberS);\n      }\n    });\n  }\n  tdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T.DIST'), (x, deg, cumulative) => {\n      deg = Math.trunc(deg);\n      if (cumulative) {\n        return studentt.cdf(x, deg);\n      } else {\n        return studentt.pdf(x, deg);\n      }\n    });\n  }\n  tdist2t(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T.DIST.2T'), (x, deg) => (1 - studentt.cdf(x, Math.trunc(deg))) * 2);\n  }\n  tdistrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T.DIST.RT'), (x, deg) => 1 - studentt.cdf(x, Math.trunc(deg)));\n  }\n  tdistold(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TDIST'), (x, deg, mode) => mode * (1 - studentt.cdf(x, Math.trunc(deg))));\n  }\n  tinv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T.INV'), (p, deg) => studentt.inv(p, Math.trunc(deg)));\n  }\n  tinv2t(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('T.INV.2T'), (p, deg) => studentt.inv(1 - p / 2, Math.trunc(deg)));\n  }\n  lognormdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LOGNORM.DIST'), (x, mean, stddev, cumulative) => {\n      if (cumulative) {\n        return lognormal.cdf(x, mean, stddev);\n      } else {\n        return lognormal.pdf(x, mean, stddev);\n      }\n    });\n  }\n  lognorminv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('LOGNORM.INV'), (p, mean, stddev) => lognormal.inv(p, mean, stddev));\n  }\n  normdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NORM.DIST'), (x, mean, stddev, cumulative) => {\n      if (cumulative) {\n        return normal.cdf(x, mean, stddev);\n      } else {\n        return normal.pdf(x, mean, stddev);\n      }\n    });\n  }\n  norminv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NORM.INV'), (p, mean, stddev) => normal.inv(p, mean, stddev));\n  }\n  normsdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NORM.S.DIST'), (x, cumulative) => {\n      if (cumulative) {\n        return normal.cdf(x, 0, 1);\n      } else {\n        return normal.pdf(x, 0, 1);\n      }\n    });\n  }\n  normsinv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NORM.S.INV'), p => normal.inv(p, 0, 1));\n  }\n  phi(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('PHI'), x => normal.pdf(x, 0, 1));\n  }\n  negbinomdist(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NEGBINOM.DIST'), (nf, ns, p, cumulative) => {\n      nf = Math.trunc(nf);\n      ns = Math.trunc(ns);\n      if (cumulative) {\n        return negbin.cdf(nf, ns, p);\n      } else {\n        return negbin.pdf(nf, ns, p);\n      }\n    });\n  }\n  confidencenorm(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.NORM'),\n    // eslint-disable-next-line\n    // @ts-ignore\n    (alpha, stddev, size) => normalci(1, alpha, stddev, Math.trunc(size))[1] - 1);\n  }\n  confidencet(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.T'), (alpha, stddev, size) => {\n      size = Math.trunc(size);\n      if (size === 1) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      // eslint-disable-next-line\n      // @ts-ignore\n      return tci(1, alpha, stddev, size)[1] - 1;\n    });\n  }\n  standardize(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('STANDARDIZE'), (x, mean, stddev) => (x - mean) / stddev);\n  }\n}\nStatisticalPlugin.implementedFunctions = {\n  'ERF': {\n    method: 'erf',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }]\n  },\n  'ERFC': {\n    method: 'erfc',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'EXPON.DIST': {\n    method: 'expondist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'FISHER': {\n    method: 'fisher',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: -1,\n      lessThan: 1\n    }]\n  },\n  'FISHERINV': {\n    method: 'fisherinv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'GAMMA': {\n    method: 'gamma',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'GAMMA.DIST': {\n    method: 'gammadist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'GAMMALN': {\n    method: 'gammaln',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  },\n  'GAMMA.INV': {\n    method: 'gammainv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  },\n  'GAUSS': {\n    method: 'gauss',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'BETA.DIST': {\n    method: 'betadist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'BETA.INV': {\n    method: 'betainv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  },\n  'BINOM.DIST': {\n    method: 'binomialdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'BINOM.INV': {\n    method: 'binomialinv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }]\n  },\n  'BESSELI': {\n    method: 'besselifn',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'BESSELJ': {\n    method: 'besseljfn',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'BESSELK': {\n    method: 'besselkfn',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'BESSELY': {\n    method: 'besselyfn',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }]\n  },\n  'CHISQ.DIST': {\n    method: 'chisqdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1,\n      maxValue: 1e10\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'CHISQ.DIST.RT': {\n    method: 'chisqdistrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1,\n      maxValue: 1e10\n    }]\n  },\n  'CHISQ.INV': {\n    method: 'chisqinv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1,\n      maxValue: 1e10\n    }]\n  },\n  'CHISQ.INV.RT': {\n    method: 'chisqinvrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'F.DIST': {\n    method: 'fdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'F.DIST.RT': {\n    method: 'fdistrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'F.INV': {\n    method: 'finv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'F.INV.RT': {\n    method: 'finvrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'WEIBULL.DIST': {\n    method: 'weibulldist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'POISSON.DIST': {\n    method: 'poissondist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'HYPGEOM.DIST': {\n    method: 'hypgeomdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'T.DIST': {\n    method: 'tdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'T.DIST.2T': {\n    method: 'tdist2t',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'T.DIST.RT': {\n    method: 'tdistrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'TDIST': {\n    method: 'tdistold',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1,\n      maxValue: 2\n    }]\n  },\n  'T.INV': {\n    method: 'tinv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'T.INV.2T': {\n    method: 'tinv2t',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'LOGNORM.DIST': {\n    method: 'lognormdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'LOGNORM.INV': {\n    method: 'lognorminv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  },\n  'NORM.DIST': {\n    method: 'normdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'NORM.INV': {\n    method: 'norminv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  },\n  'NORM.S.DIST': {\n    method: 'normsdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'NORM.S.INV': {\n    method: 'normsinv',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }]\n  },\n  'PHI': {\n    method: 'phi',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'NEGBINOM.DIST': {\n    method: 'negbinomdist',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'CONFIDENCE.NORM': {\n    method: 'confidencenorm',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'CONFIDENCE.T': {\n    method: 'confidencet',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0,\n      lessThan: 1\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      minValue: 1\n    }]\n  },\n  'STANDARDIZE': {\n    method: 'standardize',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      greaterThan: 0\n    }]\n  }\n};\nStatisticalPlugin.aliases = {\n  NEGBINOMDIST: 'NEGBINOM.DIST',\n  EXPONDIST: 'EXPON.DIST',\n  BETADIST: 'BETA.DIST',\n  NORMDIST: 'NORM.DIST',\n  NORMINV: 'NORM.INV',\n  NORMSDIST: 'NORM.S.DIST',\n  NORMSINV: 'NORM.S.INV',\n  LOGNORMDIST: 'LOGNORM.DIST',\n  LOGINV: 'LOGNORM.INV',\n  TINV: 'T.INV.2T',\n  HYPGEOMDIST: 'HYPGEOM.DIST',\n  POISSON: 'POISSON.DIST',\n  WEIBULL: 'WEIBULL.DIST',\n  FINV: 'F.INV.RT',\n  FDIST: 'F.DIST.RT',\n  CHIDIST: 'CHISQ.DIST.RT',\n  CHIINV: 'CHISQ.INV.RT',\n  GAMMADIST: 'GAMMA.DIST',\n  'GAMMALN.PRECISE': 'GAMMALN',\n  GAMMAINV: 'GAMMA.INV',\n  BETAINV: 'BETA.INV',\n  BINOMDIST: 'BINOM.DIST',\n  CONFIDENCE: 'CONFIDENCE.NORM',\n  CRITBINOM: 'BINOM.INV',\n  WEIBULLDIST: 'WEIBULL.DIST',\n  TINV2T: 'T.INV.2T',\n  TDISTRT: 'T.DIST.RT',\n  TDIST2T: 'T.DIST.2T',\n  FINVRT: 'F.INV.RT',\n  FDISTRT: 'F.DIST.RT',\n  CHIDISTRT: 'CHISQ.DIST.RT',\n  CHIINVRT: 'CHISQ.INV.RT',\n  LOGNORMINV: 'LOGNORM.INV',\n  POISSONDIST: 'POISSON.DIST'\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}