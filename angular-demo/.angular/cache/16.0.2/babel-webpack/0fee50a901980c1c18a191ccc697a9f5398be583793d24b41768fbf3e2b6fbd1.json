{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from './AbsoluteCellRange';\nimport { InterpreterState } from './interpreter/InterpreterState';\nimport { FunctionArgumentType } from './interpreter/plugin/FunctionPlugin';\nimport { AstNodeType } from './parser';\nexport class ArraySize {\n  constructor(width, height, isRef = false) {\n    this.width = width;\n    this.height = height;\n    this.isRef = isRef;\n    if (width <= 0 || height <= 0) {\n      throw Error('Incorrect array size');\n    }\n  }\n  static fromArray(array) {\n    return new ArraySize(array.length > 0 ? array[0].length : 0, array.length);\n  }\n  static error() {\n    return new ArraySize(1, 1, true);\n  }\n  static scalar() {\n    return new ArraySize(1, 1, false);\n  }\n  isScalar() {\n    return this.width <= 1 && this.height <= 1 || this.isRef;\n  }\n}\nfunction arraySizeForBinaryOp(leftArraySize, rightArraySize) {\n  return new ArraySize(Math.max(leftArraySize.width, rightArraySize.width), Math.max(leftArraySize.height, rightArraySize.height));\n}\nfunction arraySizeForUnaryOp(arraySize) {\n  return new ArraySize(arraySize.width, arraySize.height);\n}\nexport class ArraySizePredictor {\n  constructor(config, functionRegistry) {\n    this.config = config;\n    this.functionRegistry = functionRegistry;\n  }\n  checkArraySize(ast, formulaAddress) {\n    return this.checkArraySizeForAst(ast, {\n      formulaAddress,\n      arraysFlag: this.config.useArrayArithmetic\n    });\n  }\n  checkArraySizeForAst(ast, state) {\n    switch (ast.type) {\n      case AstNodeType.FUNCTION_CALL:\n        {\n          return this.checkArraySizeForFunction(ast, state);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          const range = AbsoluteCellRange.fromAstOrUndef(ast, state.formulaAddress);\n          if (range === undefined) {\n            return ArraySize.error();\n          } else {\n            return new ArraySize(range.width(), range.height(), true);\n          }\n        }\n      case AstNodeType.ARRAY:\n        {\n          const heights = [];\n          const widths = [];\n          for (const row of ast.args) {\n            const sizes = row.map(ast => this.checkArraySizeForAst(ast, state));\n            const h = Math.min(...sizes.map(size => size.height));\n            const w = sizes.reduce((total, size) => total + size.width, 0);\n            heights.push(h);\n            widths.push(w);\n          }\n          const height = heights.reduce((total, h) => total + h, 0);\n          const width = Math.min(...widths);\n          return new ArraySize(width, height);\n        }\n      case AstNodeType.STRING:\n      case AstNodeType.NUMBER:\n        return ArraySize.scalar();\n      case AstNodeType.CELL_REFERENCE:\n        return new ArraySize(1, 1, true);\n      case AstNodeType.DIV_OP:\n      case AstNodeType.CONCATENATE_OP:\n      case AstNodeType.EQUALS_OP:\n      case AstNodeType.GREATER_THAN_OP:\n      case AstNodeType.GREATER_THAN_OR_EQUAL_OP:\n      case AstNodeType.LESS_THAN_OP:\n      case AstNodeType.LESS_THAN_OR_EQUAL_OP:\n      case AstNodeType.MINUS_OP:\n      case AstNodeType.NOT_EQUAL_OP:\n      case AstNodeType.PLUS_OP:\n      case AstNodeType.POWER_OP:\n      case AstNodeType.TIMES_OP:\n        {\n          const left = this.checkArraySizeForAst(ast.left, state);\n          const right = this.checkArraySizeForAst(ast.right, state);\n          if (!state.arraysFlag && (left.height > 1 || left.width > 1 || right.height > 1 || right.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForBinaryOp(left, right);\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n      case AstNodeType.PLUS_UNARY_OP:\n      case AstNodeType.PERCENT_OP:\n        {\n          const val = this.checkArraySizeForAst(ast.value, state);\n          if (!state.arraysFlag && (val.height > 1 || val.width > 1)) {\n            return ArraySize.error();\n          }\n          return arraySizeForUnaryOp(val);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          return this.checkArraySizeForAst(ast.expression, state);\n        }\n      case AstNodeType.EMPTY:\n        return ArraySize.error();\n      default:\n        return ArraySize.error();\n    }\n  }\n  checkArraySizeForFunction(ast, state) {\n    const metadata = this.functionRegistry.getMetadata(ast.procedureName);\n    const pluginArraySizeFunction = this.functionRegistry.getArraySizeFunction(ast.procedureName);\n    if (pluginArraySizeFunction !== undefined) {\n      return pluginArraySizeFunction(ast, state);\n    }\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.checkArraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    if (metadata === undefined || metadata.expandRanges || !state.arraysFlag || metadata.vectorizationForbidden || metadata.parameters === undefined) {\n      return new ArraySize(1, 1);\n    }\n    const argumentDefinitions = [...metadata.parameters];\n    if (metadata.repeatLastArgs === undefined && argumentDefinitions.length < subChecks.length) {\n      return ArraySize.error();\n    }\n    if (metadata.repeatLastArgs !== undefined && argumentDefinitions.length < subChecks.length && (subChecks.length - argumentDefinitions.length) % metadata.repeatLastArgs !== 0) {\n      return ArraySize.error();\n    }\n    while (argumentDefinitions.length < subChecks.length) {\n      argumentDefinitions.push(...argumentDefinitions.slice(argumentDefinitions.length - metadata.repeatLastArgs));\n    }\n    let maxWidth = 1;\n    let maxHeight = 1;\n    for (let i = 0; i < subChecks.length; i++) {\n      if (argumentDefinitions[i].argumentType !== FunctionArgumentType.RANGE && argumentDefinitions[i].argumentType !== FunctionArgumentType.ANY) {\n        maxHeight = Math.max(maxHeight, subChecks[i].height);\n        maxWidth = Math.max(maxWidth, subChecks[i].width);\n      }\n    }\n    return new ArraySize(maxWidth, maxHeight);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}