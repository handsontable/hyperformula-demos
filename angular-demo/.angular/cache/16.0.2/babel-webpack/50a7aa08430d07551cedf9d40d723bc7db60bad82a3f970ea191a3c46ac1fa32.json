{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport unorm from 'unorm';\nimport { CellError, CellValueTypeOrd, ErrorType, getCellValueType } from '../Cell';\nimport { ErrorMessage } from '../error-message';\nimport { collatorFromConfig } from '../StringHelper';\nimport { cloneNumber, CurrencyNumber, DateNumber, DateTimeNumber, EmptyValue, getRawValue, getTypeFormatOfExtendedNumber, isExtendedNumber, NumberType, PercentNumber, TimeNumber } from './InterpreterValue';\nimport { SimpleRangeValue } from '../SimpleRangeValue';\nconst COMPLEX_NUMBER_SYMBOL = 'i';\nconst complexParsingRegexp = /^\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij]))\\s*(([+-])\\s*([+-]?)\\s*(([\\d\\.,]+(e[+-]?\\d+)?)\\s*([ij]?)|([ij])))?$/;\nexport class ArithmeticHelper {\n  constructor(config, dateTimeHelper, numberLiteralsHelper) {\n    this.config = config;\n    this.dateTimeHelper = dateTimeHelper;\n    this.numberLiteralsHelper = numberLiteralsHelper;\n    this.lt = (left, right) => {\n      return this.compare(left, right) < 0;\n    };\n    this.leq = (left, right) => {\n      return this.compare(left, right) <= 0;\n    };\n    this.gt = (left, right) => {\n      return this.compare(left, right) > 0;\n    };\n    this.geq = (left, right) => {\n      return this.compare(left, right) >= 0;\n    };\n    this.eq = (left, right) => {\n      return this.compare(left, right) === 0;\n    };\n    this.neq = (left, right) => {\n      return this.compare(left, right) !== 0;\n    };\n    this.pow = (left, right) => {\n      return Math.pow(getRawValue(left), getRawValue(right));\n    };\n    this.addWithEpsilonRaw = (left, right) => {\n      const ret = left + right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        return 0;\n      } else {\n        return ret;\n      }\n    };\n    this.addWithEpsilon = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(left, right);\n      return this.ExtendedNumberFactory(this.addWithEpsilonRaw(getRawValue(left), getRawValue(right)), typeOfResult);\n    };\n    this.unaryMinus = arg => {\n      return cloneNumber(arg, -getRawValue(arg));\n    };\n    this.unaryPlus = arg => arg;\n    this.unaryPercent = arg => {\n      return new PercentNumber(getRawValue(arg) / 100);\n    };\n    this.concat = (left, right) => {\n      return left.concat(right);\n    };\n    this.nonstrictadd = (left, right) => {\n      if (left instanceof CellError) {\n        return left;\n      } else if (right instanceof CellError) {\n        return right;\n      } else if (typeof left === 'number') {\n        if (typeof right === 'number') {\n          return this.addWithEpsilonRaw(left, right);\n        } else {\n          return left;\n        }\n      } else if (typeof right === 'number') {\n        return right;\n      } else {\n        return 0;\n      }\n    };\n    /**\r\n     * Subtracts two numbers\r\n     *\r\n     * Implementation of subtracting which is used in interpreter.\r\n     *\r\n     * @param left - left operand of subtraction\r\n     * @param right - right operand of subtraction\r\n     * @param eps - precision of comparison\r\n     */\n    this.subtract = (leftArg, rightArg) => {\n      const typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      let ret = left - right;\n      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {\n        ret = 0;\n      }\n      return this.ExtendedNumberFactory(ret, typeOfResult);\n    };\n    this.divide = (leftArg, rightArg) => {\n      const left = getRawValue(leftArg);\n      const right = getRawValue(rightArg);\n      if (right === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      } else {\n        const typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);\n        return this.ExtendedNumberFactory(left / right, typeOfResult);\n      }\n    };\n    this.multiply = (left, right) => {\n      const typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);\n      return this.ExtendedNumberFactory(getRawValue(left) * getRawValue(right), typeOfResult);\n    };\n    this.manyToExactComplex = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg) || typeof arg === 'string') {\n          const coerced = this.coerceScalarToComplex(arg);\n          if (!(coerced instanceof CellError)) {\n            ret.push(coerced);\n          }\n        }\n      }\n      return ret;\n    };\n    this.coerceNumbersExactRanges = args => this.manyToNumbers(args, this.manyToExactNumbers);\n    this.coerceNumbersCoerceRangesDropNulls = args => this.manyToNumbers(args, this.manyToCoercedNumbersDropNulls);\n    this.manyToExactNumbers = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        }\n      }\n      return ret;\n    };\n    this.manyToOnlyNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        } else if (isExtendedNumber(arg)) {\n          ret.push(getRawValue(arg));\n        } else if (arg !== EmptyValue) {\n          return new CellError(ErrorType.VALUE, ErrorMessage.NumberExpected);\n        }\n      }\n      return ret;\n    };\n    this.manyToCoercedNumbersDropNulls = args => {\n      const ret = [];\n      for (const arg of args) {\n        if (arg instanceof CellError) {\n          return arg;\n        }\n        if (arg === EmptyValue) {\n          continue;\n        }\n        const coerced = this.coerceScalarToNumberOrError(arg);\n        if (isExtendedNumber(coerced)) {\n          ret.push(getRawValue(coerced));\n        }\n      }\n      return ret;\n    };\n    this.collator = collatorFromConfig(config);\n    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;\n  }\n  eqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => typeof cellValue === 'string' && regexp.test(this.normalizeString(cellValue));\n  }\n  neqMatcherFunction(pattern) {\n    const regexp = this.buildRegex(pattern);\n    return cellValue => {\n      return !(typeof cellValue === 'string') || !regexp.test(this.normalizeString(cellValue));\n    };\n  }\n  searchString(pattern, text) {\n    var _a;\n    const regexp = this.buildRegex(pattern, false);\n    const result = regexp.exec(text);\n    return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;\n  }\n  requiresRegex(pattern) {\n    if (!this.config.useRegularExpressions && !this.config.useWildcards) {\n      return !this.config.matchWholeCell;\n    }\n    for (let i = 0; i < pattern.length; i++) {\n      const c = pattern.charAt(i);\n      if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  floatCmp(leftArg, rightArg) {\n    const left = getRawValue(leftArg);\n    const right = getRawValue(rightArg);\n    const mod = 1 + this.actualEps;\n    if (right >= 0 && left * mod >= right && left <= right * mod) {\n      return 0;\n    } else if (right <= 0 && left * mod <= right && left >= right * mod) {\n      return 0;\n    } else if (left > right) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  coerceScalarToNumberOrError(arg) {\n    var _a;\n    if (arg instanceof CellError) {\n      return arg;\n    }\n    return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new CellError(ErrorType.VALUE, ErrorMessage.NumberCoercion);\n  }\n  coerceToMaybeNumber(arg) {\n    var _a;\n    return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;\n  }\n  coerceNonDateScalarToMaybeNumber(arg) {\n    if (arg === EmptyValue) {\n      return 0;\n    } else if (typeof arg === 'string') {\n      if (arg === '') {\n        return 0;\n      }\n      const maybePercentNumber = this.coerceStringToMaybePercentNumber(arg);\n      if (maybePercentNumber !== undefined) {\n        return maybePercentNumber;\n      }\n      const maybeCurrencyNumber = this.coerceStringToMaybeCurrencyNumber(arg);\n      if (maybeCurrencyNumber !== undefined) {\n        return maybeCurrencyNumber;\n      }\n      return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());\n    } else if (isExtendedNumber(arg)) {\n      return arg;\n    } else if (typeof arg === 'boolean') {\n      return Number(arg);\n    } else {\n      return undefined;\n    }\n  }\n  coerceStringToMaybePercentNumber(input) {\n    const trimmedInput = input.trim();\n    if (trimmedInput.endsWith('%')) {\n      const numOfPercents = trimmedInput.slice(0, trimmedInput.length - 1).trim();\n      const parsedNumOfPercents = this.numberLiteralsHelper.numericStringToMaybeNumber(numOfPercents);\n      if (parsedNumOfPercents !== undefined) {\n        return new PercentNumber(parsedNumOfPercents / 100);\n      }\n    }\n    return undefined;\n  }\n  coerceStringToMaybeCurrencyNumber(input) {\n    const matchedCurrency = this.currencyMatcher(input.trim());\n    if (matchedCurrency !== undefined) {\n      const [currencySymbol, currencyValue] = matchedCurrency;\n      const parsedCurrencyValue = this.numberLiteralsHelper.numericStringToMaybeNumber(currencyValue);\n      if (parsedCurrencyValue !== undefined) {\n        return new CurrencyNumber(parsedCurrencyValue, currencySymbol);\n      }\n    }\n    return undefined;\n  }\n  currencyMatcher(token) {\n    for (const currency of this.config.currencySymbol) {\n      if (token.startsWith(currency)) {\n        return [currency, token.slice(currency.length).trim()];\n      }\n      if (token.endsWith(currency)) {\n        return [currency, token.slice(0, token.length - currency.length).trim()];\n      }\n    }\n    return undefined;\n  }\n  coerceComplexExactRanges(args) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else if (arg !== EmptyValue) {\n        const coerced = this.coerceScalarToComplex(arg);\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceScalarToComplex(arg) {\n    if (arg instanceof CellError) {\n      return arg;\n    } else if (arg === EmptyValue) {\n      return [0, 0];\n    } else if (isExtendedNumber(arg)) {\n      return [getRawValue(arg), 0];\n    } else if (typeof arg === 'string') {\n      return this.coerceStringToComplex(arg);\n    } else {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n  }\n  ExtendedNumberFactory(value, typeFormat) {\n    const {\n      type,\n      format\n    } = typeFormat;\n    switch (type) {\n      case NumberType.NUMBER_RAW:\n        return value;\n      case NumberType.NUMBER_CURRENCY:\n        {\n          return new CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);\n        }\n      case NumberType.NUMBER_DATE:\n        return new DateNumber(value, format);\n      case NumberType.NUMBER_DATETIME:\n        return new DateTimeNumber(value, format);\n      case NumberType.NUMBER_TIME:\n        return new TimeNumber(value, format);\n      case NumberType.NUMBER_PERCENT:\n        return new PercentNumber(value, format);\n    }\n  }\n  buildRegex(pattern, matchWholeCell = true) {\n    pattern = this.normalizeString(pattern);\n    let regexpStr;\n    let useWildcards = this.config.useWildcards;\n    let useRegularExpressions = this.config.useRegularExpressions;\n    if (useRegularExpressions) {\n      try {\n        RegExp(pattern);\n      } catch (e) {\n        useRegularExpressions = false;\n        useWildcards = false;\n      }\n    }\n    if (useRegularExpressions) {\n      regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);\n    } else if (useWildcards) {\n      regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);\n    } else {\n      regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);\n    }\n    if (this.config.matchWholeCell && matchWholeCell) {\n      return RegExp('^(' + regexpStr + ')$');\n    } else {\n      return RegExp(regexpStr);\n    }\n  }\n  normalizeString(str) {\n    if (!this.config.caseSensitive) {\n      str = str.toLowerCase();\n    }\n    if (!this.config.accentSensitive) {\n      str = normalizeString(str, 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n    }\n    return str;\n  }\n  compare(left, right) {\n    if (typeof left === 'string' || typeof right === 'string') {\n      const leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;\n      const rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;\n      if (isExtendedNumber(leftTmp) && isExtendedNumber(rightTmp)) {\n        return this.floatCmp(leftTmp, rightTmp);\n      }\n    }\n    if (left === EmptyValue) {\n      left = coerceEmptyToValue(right);\n    } else if (right === EmptyValue) {\n      right = coerceEmptyToValue(left);\n    }\n    if (typeof left === 'string' && typeof right === 'string') {\n      return this.stringCmp(left, right);\n    } else if (typeof left === 'boolean' && typeof right === 'boolean') {\n      return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));\n    } else if (isExtendedNumber(left) && isExtendedNumber(right)) {\n      return this.floatCmp(left, right);\n    } else if (left === EmptyValue && right === EmptyValue) {\n      return 0;\n    } else {\n      return numberCmp(CellValueTypeOrd(getCellValueType(left)), CellValueTypeOrd(getCellValueType(right)));\n    }\n  }\n  stringCmp(left, right) {\n    return this.collator.compare(left, right);\n  }\n  manyToNumbers(args, rangeFn) {\n    const vals = [];\n    for (const arg of args) {\n      if (arg instanceof SimpleRangeValue) {\n        vals.push(arg);\n      } else {\n        const coerced = getRawValue(this.coerceScalarToNumberOrError(arg));\n        if (coerced instanceof CellError) {\n          return coerced;\n        } else {\n          vals.push(coerced);\n        }\n      }\n    }\n    const expandedVals = [];\n    for (const val of vals) {\n      if (val instanceof SimpleRangeValue) {\n        const arr = rangeFn(val.valuesFromTopLeftCorner());\n        if (arr instanceof CellError) {\n          return arr;\n        } else {\n          expandedVals.push(...arr);\n        }\n      } else {\n        expandedVals.push(val);\n      }\n    }\n    return expandedVals;\n  }\n  coerceStringToComplex(arg) {\n    const match = complexParsingRegexp.exec(arg);\n    if (match === null) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    let val1;\n    if (match[6] !== undefined) {\n      val1 = match[1] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val1 = this.parseComplexToken(match[1] + match[3], match[5]);\n    }\n    if (val1 instanceof CellError) {\n      return val1;\n    }\n    if (match[8] === undefined) {\n      return val1;\n    }\n    let val2;\n    if (match[14] !== undefined) {\n      val2 = match[9] === '-' ? [0, -1] : [0, 1];\n    } else {\n      val2 = this.parseComplexToken(match[9] + match[11], match[13]);\n    }\n    if (val2 instanceof CellError) {\n      return val2;\n    }\n    if (match[5] !== '' || match[13] === '') {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (match[8] === '+') {\n      return [val1[0] + val2[0], val1[1] + val2[1]];\n    } else {\n      return [val1[0] - val2[0], val1[1] - val2[1]];\n    }\n  }\n  parseComplexToken(arg, mod) {\n    const val = getRawValue(this.coerceNonDateScalarToMaybeNumber(arg));\n    if (val === undefined) {\n      return new CellError(ErrorType.NUM, ErrorMessage.ComplexNumberExpected);\n    }\n    if (mod === '') {\n      return [val, 0];\n    } else {\n      return [0, val];\n    }\n  }\n}\nexport function coerceComplexToString([re, im], symb) {\n  if (!isFinite(re) || !isFinite(im)) {\n    return new CellError(ErrorType.NUM, ErrorMessage.NaN);\n  }\n  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;\n  if (im === 0) {\n    return `${re}`;\n  }\n  const imStr = `${im === -1 || im === 1 ? '' : Math.abs(im)}${symb}`;\n  if (re === 0) {\n    return `${im < 0 ? '-' : ''}${imStr}`;\n  }\n  return `${re}${im < 0 ? '-' : '+'}${imStr}`;\n}\nexport function coerceToRange(arg) {\n  if (arg instanceof SimpleRangeValue) {\n    return arg;\n  } else {\n    return SimpleRangeValue.fromScalar(arg);\n  }\n}\nexport function coerceToRangeNumbersOrError(arg) {\n  if (arg instanceof SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof CellError) {\n    return arg;\n  } else if (isExtendedNumber(arg)) {\n    return SimpleRangeValue.fromScalar(arg);\n  } else {\n    return null;\n  }\n}\nexport function coerceBooleanToNumber(arg) {\n  return Number(arg);\n}\nexport function coerceEmptyToValue(arg) {\n  if (typeof arg === 'string') {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return 0;\n  } else if (typeof arg === 'boolean') {\n    return false;\n  } else {\n    return EmptyValue;\n  }\n}\n/**\r\n * Coerce scalar value to boolean if possible, or error if value is an error\r\n *\r\n * @param arg\r\n */\nexport function coerceScalarToBoolean(arg) {\n  if (arg instanceof CellError || typeof arg === 'boolean') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return false;\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg) !== 0;\n  } else {\n    const argUppered = arg.toUpperCase();\n    if (argUppered === 'TRUE') {\n      return true;\n    } else if (argUppered === 'FALSE') {\n      return false;\n    } else if (argUppered === '') {\n      return false;\n    } else {\n      return undefined;\n    }\n  }\n}\nexport function coerceScalarToString(arg) {\n  if (arg instanceof CellError || typeof arg === 'string') {\n    return arg;\n  } else if (arg === EmptyValue) {\n    return '';\n  } else if (isExtendedNumber(arg)) {\n    return getRawValue(arg).toString();\n  } else {\n    return arg ? 'TRUE' : 'FALSE';\n  }\n}\nexport function zeroIfEmpty(arg) {\n  return arg === EmptyValue ? 0 : arg;\n}\nexport function numberCmp(leftArg, rightArg) {\n  const left = getRawValue(leftArg);\n  const right = getRawValue(rightArg);\n  if (left > right) {\n    return 1;\n  } else if (left < right) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nexport function isNumberOverflow(arg) {\n  return isNaN(arg) || arg === Infinity || arg === -Infinity;\n}\nexport function fixNegativeZero(arg) {\n  if (arg === 0) {\n    return 0;\n  } else {\n    return arg;\n  }\n}\nfunction isWildcard(c) {\n  return ['*', '?'].includes(c);\n}\nconst escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\\\', '$', '^', '!'];\nfunction needsEscape(c) {\n  return escapedCharacters.includes(c);\n}\nfunction escapeNonWildcards(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (c === '~') {\n      if (i == pattern.length - 1) {\n        str += '~';\n        continue;\n      }\n      const d = pattern.charAt(i + 1);\n      if (isWildcard(d) || needsEscape(d)) {\n        str += '\\\\' + d;\n        i++;\n      } else {\n        str += d;\n        i++;\n      }\n    } else if (isWildcard(c)) {\n      str += '.' + c;\n    } else if (needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeAllCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += '\\\\' + c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction escapeNoCharacters(pattern, caseSensitive) {\n  let str = '';\n  for (let i = 0; i < pattern.length; i++) {\n    const c = pattern.charAt(i);\n    if (isWildcard(c) || needsEscape(c)) {\n      str += c;\n    } else if (caseSensitive) {\n      str += c;\n    } else {\n      str += c.toLowerCase();\n    }\n  }\n  return str;\n}\nfunction inferExtendedNumberTypeAdditive(leftArg, rightArg) {\n  const {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  const {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  if ((leftType === NumberType.NUMBER_DATETIME || leftType === NumberType.NUMBER_DATE) && (rightType === NumberType.NUMBER_DATETIME || rightType === NumberType.NUMBER_DATE)) {\n    return {\n      type: NumberType.NUMBER_RAW\n    };\n  }\n  if (leftType === NumberType.NUMBER_TIME) {\n    if (rightType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: rightFormat + ' ' + leftFormat\n      };\n    }\n    if (rightType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: rightFormat\n      };\n    }\n  }\n  if (rightType === NumberType.NUMBER_TIME) {\n    if (leftType === NumberType.NUMBER_DATE) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: leftFormat + ' ' + rightFormat\n      };\n    }\n    if (leftType === NumberType.NUMBER_DATETIME) {\n      return {\n        type: NumberType.NUMBER_DATETIME,\n        format: leftFormat\n      };\n    }\n  }\n  return {\n    type: leftType,\n    format: leftFormat\n  };\n}\nfunction inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {\n  let {\n    type: leftType,\n    format: leftFormat\n  } = getTypeFormatOfExtendedNumber(leftArg);\n  let {\n    type: rightType,\n    format: rightFormat\n  } = getTypeFormatOfExtendedNumber(rightArg);\n  if (leftType === NumberType.NUMBER_PERCENT) {\n    leftType = NumberType.NUMBER_RAW;\n    leftFormat = undefined;\n  }\n  if (rightType === NumberType.NUMBER_PERCENT) {\n    rightType = NumberType.NUMBER_RAW;\n    rightFormat = undefined;\n  }\n  if (leftType === NumberType.NUMBER_RAW) {\n    return {\n      type: rightType,\n      format: rightFormat\n    };\n  }\n  if (rightType === NumberType.NUMBER_RAW) {\n    return {\n      type: leftType,\n      format: leftFormat\n    };\n  }\n  return {\n    type: NumberType.NUMBER_RAW\n  };\n}\nexport function forceNormalizeString(str) {\n  return normalizeString(str.toLowerCase(), 'nfd').replace(/[\\u0300-\\u036f]/g, '');\n}\nexport function coerceRangeToScalar(arg, state) {\n  var _a;\n  if (arg.isAdHoc()) {\n    return (_a = arg.data[0]) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  const range = arg.range;\n  if (state.formulaAddress.sheet === range.sheet) {\n    if (range.width() === 1) {\n      const offset = state.formulaAddress.row - range.start.row;\n      if (offset >= 0 && offset < range.height()) {\n        return arg.data[offset][0];\n      }\n    } else if (range.height() === 1) {\n      const offset = state.formulaAddress.col - range.start.col;\n      if (offset >= 0 && offset < range.width()) {\n        return arg.data[0][offset];\n      }\n    }\n  }\n  return undefined;\n}\nexport function normalizeString(str, form) {\n  return typeof str.normalize === 'function' ? str.normalize(form.toUpperCase()) : unorm[form](str);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}