{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\n/**\r\n * Interpreter plugin containing boolean functions\r\n */\nexport class BooleanPlugin extends FunctionPlugin {\n  /**\r\n   * Corresponds to TRUE()\r\n   *\r\n   * Returns the logical true\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  literalTrue(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TRUE'), () => true);\n  }\n  /**\r\n   * Corresponds to FALSE()\r\n   *\r\n   * Returns the logical false\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  literalFalse(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('FALSE'), () => false);\n  }\n  /**\r\n   * Corresponds to IF(expression, value_if_true, value_if_false)\r\n   *\r\n   * Returns value specified as second argument if expression is true and third argument if expression is false\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  conditionalIf(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IF'), (condition, arg2, arg3) => {\n      return condition ? arg2 : arg3;\n    });\n  }\n  /**\r\n   * Corresponds to AND(expression1, [expression2, ...])\r\n   *\r\n   * Returns true if all of the provided arguments are logically true, and false if any of it is logically false\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  and(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('AND'), (...args) => args.filter(arg => arg !== undefined).every(arg => !!arg));\n  }\n  /**\r\n   * Corresponds to OR(expression1, [expression2, ...])\r\n   *\r\n   * Returns true if any of the provided arguments are logically true, and false otherwise\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  or(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('OR'), (...args) => args.filter(arg => arg !== undefined).some(arg => arg));\n  }\n  not(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('NOT'), arg => !arg);\n  }\n  xor(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('XOR'), (...args) => {\n      let cnt = 0;\n      args.filter(arg => arg !== undefined).forEach(arg => {\n        if (arg) {\n          cnt++;\n        }\n      });\n      return cnt % 2 === 1;\n    });\n  }\n  switch(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('SWITCH'), (selector, ...args) => {\n      const n = args.length;\n      let i = 0;\n      for (; i + 1 < n; i += 2) {\n        if (args[i] instanceof CellError) {\n          continue;\n        }\n        if (this.arithmeticHelper.eq(selector, args[i])) {\n          return args[i + 1];\n        }\n      }\n      if (i < n) {\n        return args[i];\n      } else {\n        return new CellError(ErrorType.NA, ErrorMessage.NoDefault);\n      }\n    });\n  }\n  iferror(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IFERROR'), (arg1, arg2) => {\n      if (arg1 instanceof CellError) {\n        return arg2;\n      } else {\n        return arg1;\n      }\n    });\n  }\n  ifna(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IFNA'), (arg1, arg2) => {\n      if (arg1 instanceof CellError && arg1.type === ErrorType.NA) {\n        return arg2;\n      } else {\n        return arg1;\n      }\n    });\n  }\n  choose(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('CHOOSE'), (selector, ...args) => {\n      if (selector > args.length) {\n        return new CellError(ErrorType.NUM, ErrorMessage.Selector);\n      }\n      return args[selector - 1];\n    });\n  }\n}\nBooleanPlugin.implementedFunctions = {\n  'TRUE': {\n    method: 'literalTrue',\n    parameters: []\n  },\n  'FALSE': {\n    method: 'literalFalse',\n    parameters: []\n  },\n  'IF': {\n    method: 'conditionalIf',\n    parameters: [{\n      argumentType: FunctionArgumentType.BOOLEAN\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      defaultValue: false,\n      passSubtype: true\n    }]\n  },\n  'AND': {\n    method: 'and',\n    parameters: [{\n      argumentType: FunctionArgumentType.BOOLEAN\n    }],\n    repeatLastArgs: 1,\n    expandRanges: true\n  },\n  'OR': {\n    method: 'or',\n    parameters: [{\n      argumentType: FunctionArgumentType.BOOLEAN\n    }],\n    repeatLastArgs: 1,\n    expandRanges: true\n  },\n  'XOR': {\n    method: 'xor',\n    parameters: [{\n      argumentType: FunctionArgumentType.BOOLEAN\n    }],\n    repeatLastArgs: 1,\n    expandRanges: true\n  },\n  'NOT': {\n    method: 'not',\n    parameters: [{\n      argumentType: FunctionArgumentType.BOOLEAN\n    }]\n  },\n  'SWITCH': {\n    method: 'switch',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }],\n    repeatLastArgs: 1\n  },\n  'IFERROR': {\n    method: 'iferror',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }]\n  },\n  'IFNA': {\n    method: 'ifna',\n    parameters: [{\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }]\n  },\n  'CHOOSE': {\n    method: 'choose',\n    parameters: [{\n      argumentType: FunctionArgumentType.INTEGER,\n      minValue: 1\n    }, {\n      argumentType: FunctionArgumentType.SCALAR,\n      passSubtype: true\n    }],\n    repeatLastArgs: 1\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}