{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { coerceComplexToString } from '../ArithmeticHelper';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class ComplexPlugin extends FunctionPlugin {\n  complex(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('COMPLEX'), (re, im, unit) => {\n      if (unit !== 'i' && unit !== 'j') {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ShouldBeIorJ);\n      }\n      return coerceComplexToString([re, im], unit);\n    });\n  }\n  imabs(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMABS'), abs);\n  }\n  imaginary(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMAGINARY'), ([_re, im]) => im);\n  }\n  imreal(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMREAL'), ([re, _im]) => re);\n  }\n  imargument(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMARGUMENT'), ([re, im]) => {\n      if (re === 0 && im === 0) {\n        return new CellError(ErrorType.DIV_BY_ZERO);\n      }\n      return Math.atan2(im, re);\n    });\n  }\n  imconjugate(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCONJUGATE'), ([re, im]) => coerceComplexToString([re, -im]));\n  }\n  imcos(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCOS'), arg => coerceComplexToString(cos(arg)));\n  }\n  imcosh(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCOSH'), arg => coerceComplexToString(cosh(arg)));\n  }\n  imcot(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCOT'), arg => coerceComplexToString(div(cos(arg), sin(arg))));\n  }\n  imcsc(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCSC'), arg => coerceComplexToString(div([1, 0], sin(arg))));\n  }\n  imcsch(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMCSCH'), arg => coerceComplexToString(div([1, 0], sinh(arg))));\n  }\n  imsec(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSEC'), arg => coerceComplexToString(div([1, 0], cos(arg))));\n  }\n  imsech(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSECH'), arg => coerceComplexToString(div([1, 0], cosh(arg))));\n  }\n  imsin(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSIN'), arg => coerceComplexToString(sin(arg)));\n  }\n  imsinh(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSINH'), arg => coerceComplexToString(sinh(arg)));\n  }\n  imtan(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMTAN'), arg => coerceComplexToString(div(sin(arg), cos(arg))));\n  }\n  imdiv(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMDIV'), (arg1, arg2) => coerceComplexToString(div(arg1, arg2)));\n  }\n  improduct(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMPRODUCT'), (...args) => {\n      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);\n      if (coerced instanceof CellError) {\n        return coerced;\n      }\n      let prod = [1, 0];\n      for (const val of coerced) {\n        prod = mul(prod, val);\n      }\n      return coerceComplexToString(prod);\n    });\n  }\n  imsum(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSUM'), (...args) => {\n      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);\n      if (coerced instanceof CellError) {\n        return coerced;\n      }\n      let sum = [0, 0];\n      for (const val of coerced) {\n        sum = add(sum, val);\n      }\n      return coerceComplexToString(sum);\n    });\n  }\n  imsub(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSUB'), (arg1, arg2) => coerceComplexToString(sub(arg1, arg2)));\n  }\n  imexp(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMEXP'), arg => coerceComplexToString(exp(arg)));\n  }\n  imln(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMLN'), arg => coerceComplexToString(ln(arg)));\n  }\n  imlog10(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMLOG10'), arg => {\n      const [re, im] = ln(arg);\n      const c = Math.log(10);\n      return coerceComplexToString([re / c, im / c]);\n    });\n  }\n  imlog2(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMLOG2'), arg => {\n      const [re, im] = ln(arg);\n      const c = Math.log(2);\n      return coerceComplexToString([re / c, im / c]);\n    });\n  }\n  impower(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMPOWER'), (arg, n) => coerceComplexToString(power(arg, n)));\n  }\n  imsqrt(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('IMSQRT'), arg => coerceComplexToString(power(arg, 0.5)));\n  }\n}\nComplexPlugin.implementedFunctions = {\n  'COMPLEX': {\n    method: 'complex',\n    parameters: [{\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.STRING,\n      defaultValue: 'i'\n    }]\n  },\n  'IMABS': {\n    method: 'imabs',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMAGINARY': {\n    method: 'imaginary',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMREAL': {\n    method: 'imreal',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMARGUMENT': {\n    method: 'imargument',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCONJUGATE': {\n    method: 'imconjugate',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCOS': {\n    method: 'imcos',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCOSH': {\n    method: 'imcosh',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCOT': {\n    method: 'imcot',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCSC': {\n    method: 'imcsc',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMCSCH': {\n    method: 'imcsch',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMSEC': {\n    method: 'imsec',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMSECH': {\n    method: 'imsech',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMSIN': {\n    method: 'imsin',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMSINH': {\n    method: 'imsinh',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMTAN': {\n    method: 'imtan',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMDIV': {\n    method: 'imdiv',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }, {\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMPRODUCT': {\n    method: 'improduct',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'IMSUM': {\n    method: 'imsum',\n    parameters: [{\n      argumentType: FunctionArgumentType.ANY\n    }],\n    repeatLastArgs: 1\n  },\n  'IMSUB': {\n    method: 'imsub',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }, {\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMEXP': {\n    method: 'imexp',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMLN': {\n    method: 'imln',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMLOG10': {\n    method: 'imlog10',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMLOG2': {\n    method: 'imlog2',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  },\n  'IMPOWER': {\n    method: 'impower',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }]\n  },\n  'IMSQRT': {\n    method: 'imsqrt',\n    parameters: [{\n      argumentType: FunctionArgumentType.COMPLEX\n    }]\n  }\n};\nfunction add([re1, im1], [re2, im2]) {\n  return [re1 + re2, im1 + im2];\n}\nfunction sub([re1, im1], [re2, im2]) {\n  return [re1 - re2, im1 - im2];\n}\nfunction mul([re1, im1], [re2, im2]) {\n  return [re1 * re2 - im1 * im2, re1 * im2 + re2 * im1];\n}\nfunction div([re1, im1], [re2, im2]) {\n  const denom = Math.pow(re2, 2) + Math.pow(im2, 2);\n  const [nomRe, nomIm] = mul([re1, im1], [re2, -im2]);\n  return [nomRe / denom, nomIm / denom];\n}\nfunction cos([re, im]) {\n  return [Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im)];\n}\nfunction cosh([re, im]) {\n  return [Math.cosh(re) * Math.cos(im), Math.sinh(re) * Math.sin(im)];\n}\nfunction sin([re, im]) {\n  return [Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im)];\n}\nfunction sinh([re, im]) {\n  return [Math.sinh(re) * Math.cos(im), Math.cosh(re) * Math.sin(im)];\n}\nfunction exp([re, im]) {\n  return [Math.exp(re) * Math.cos(im), Math.exp(re) * Math.sin(im)];\n}\nfunction abs([re, im]) {\n  return Math.sqrt(re * re + im * im);\n}\nfunction ln([re, im]) {\n  return [Math.log(abs([re, im])), Math.atan2(im, re)];\n}\nfunction power(arg, n) {\n  const [re, im] = ln(arg);\n  return exp([n * re, n * im]);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}