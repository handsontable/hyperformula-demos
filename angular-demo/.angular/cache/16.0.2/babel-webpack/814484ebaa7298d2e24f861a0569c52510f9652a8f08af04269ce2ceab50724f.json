{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { equalSimpleCellAddress, simpleCellAddress } from './Cell';\nimport { AddColumnsCommand, AddRowsCommand, RemoveColumnsCommand, RemoveRowsCommand } from './Operations';\nexport class BaseUndoEntry {}\nexport class RemoveRowsUndoEntry extends BaseUndoEntry {\n  constructor(command, rowsRemovals) {\n    super();\n    this.command = command;\n    this.rowsRemovals = rowsRemovals;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoRemoveRows(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoRemoveRows(this);\n  }\n}\nexport class MoveCellsUndoEntry extends BaseUndoEntry {\n  constructor(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version) {\n    super();\n    this.sourceLeftCorner = sourceLeftCorner;\n    this.width = width;\n    this.height = height;\n    this.destinationLeftCorner = destinationLeftCorner;\n    this.overwrittenCellsData = overwrittenCellsData;\n    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;\n    this.version = version;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoMoveCells(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoMoveCells(this);\n  }\n}\nexport class AddRowsUndoEntry extends BaseUndoEntry {\n  constructor(command) {\n    super();\n    this.command = command;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoAddRows(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoAddRows(this);\n  }\n}\nexport class SetRowOrderUndoEntry extends BaseUndoEntry {\n  constructor(sheetId, rowMapping, oldContent) {\n    super();\n    this.sheetId = sheetId;\n    this.rowMapping = rowMapping;\n    this.oldContent = oldContent;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoSetRowOrder(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoSetRowOrder(this);\n  }\n}\nexport class SetColumnOrderUndoEntry extends BaseUndoEntry {\n  constructor(sheetId, columnMapping, oldContent) {\n    super();\n    this.sheetId = sheetId;\n    this.columnMapping = columnMapping;\n    this.oldContent = oldContent;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoSetColumnOrder(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoSetColumnOrder(this);\n  }\n}\nexport class SetSheetContentUndoEntry extends BaseUndoEntry {\n  constructor(sheetId, oldSheetContent, newSheetContent) {\n    super();\n    this.sheetId = sheetId;\n    this.oldSheetContent = oldSheetContent;\n    this.newSheetContent = newSheetContent;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoSetSheetContent(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoSetSheetContent(this);\n  }\n}\nexport class MoveRowsUndoEntry extends BaseUndoEntry {\n  constructor(sheet, startRow, numberOfRows, targetRow, version) {\n    super();\n    this.sheet = sheet;\n    this.startRow = startRow;\n    this.numberOfRows = numberOfRows;\n    this.targetRow = targetRow;\n    this.version = version;\n    this.undoStart = this.startRow < this.targetRow ? this.targetRow - this.numberOfRows : this.targetRow;\n    this.undoEnd = this.startRow > this.targetRow ? this.startRow + this.numberOfRows : this.startRow;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoMoveRows(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoMoveRows(this);\n  }\n}\nexport class MoveColumnsUndoEntry extends BaseUndoEntry {\n  constructor(sheet, startColumn, numberOfColumns, targetColumn, version) {\n    super();\n    this.sheet = sheet;\n    this.startColumn = startColumn;\n    this.numberOfColumns = numberOfColumns;\n    this.targetColumn = targetColumn;\n    this.version = version;\n    this.undoStart = this.startColumn < this.targetColumn ? this.targetColumn - this.numberOfColumns : this.targetColumn;\n    this.undoEnd = this.startColumn > this.targetColumn ? this.startColumn + this.numberOfColumns : this.startColumn;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoMoveColumns(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoMoveColumns(this);\n  }\n}\nexport class AddColumnsUndoEntry extends BaseUndoEntry {\n  constructor(command) {\n    super();\n    this.command = command;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoAddColumns(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoAddColumns(this);\n  }\n}\nexport class RemoveColumnsUndoEntry extends BaseUndoEntry {\n  constructor(command, columnsRemovals) {\n    super();\n    this.command = command;\n    this.columnsRemovals = columnsRemovals;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoRemoveColumns(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoRemoveColumns(this);\n  }\n}\nexport class AddSheetUndoEntry extends BaseUndoEntry {\n  constructor(sheetName) {\n    super();\n    this.sheetName = sheetName;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoAddSheet(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoAddSheet(this);\n  }\n}\nexport class RemoveSheetUndoEntry extends BaseUndoEntry {\n  constructor(sheetName, sheetId, oldSheetContent, scopedNamedExpressions, version) {\n    super();\n    this.sheetName = sheetName;\n    this.sheetId = sheetId;\n    this.oldSheetContent = oldSheetContent;\n    this.scopedNamedExpressions = scopedNamedExpressions;\n    this.version = version;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoRemoveSheet(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoRemoveSheet(this);\n  }\n}\nexport class RenameSheetUndoEntry extends BaseUndoEntry {\n  constructor(sheetId, oldName, newName) {\n    super();\n    this.sheetId = sheetId;\n    this.oldName = oldName;\n    this.newName = newName;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoRenameSheet(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoRenameSheet(this);\n  }\n}\nexport class ClearSheetUndoEntry extends BaseUndoEntry {\n  constructor(sheetId, oldSheetContent) {\n    super();\n    this.sheetId = sheetId;\n    this.oldSheetContent = oldSheetContent;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoClearSheet(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoClearSheet(this);\n  }\n}\nexport class SetCellContentsUndoEntry extends BaseUndoEntry {\n  constructor(cellContents) {\n    super();\n    this.cellContents = cellContents;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoSetCellContents(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoSetCellContents(this);\n  }\n}\nexport class PasteUndoEntry extends BaseUndoEntry {\n  constructor(targetLeftCorner, oldContent, newContent, addedGlobalNamedExpressions) {\n    super();\n    this.targetLeftCorner = targetLeftCorner;\n    this.oldContent = oldContent;\n    this.newContent = newContent;\n    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoPaste(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoPaste(this);\n  }\n}\nexport class AddNamedExpressionUndoEntry extends BaseUndoEntry {\n  constructor(name, newContent, scope, options) {\n    super();\n    this.name = name;\n    this.newContent = newContent;\n    this.scope = scope;\n    this.options = options;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoAddNamedExpression(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoAddNamedExpression(this);\n  }\n}\nexport class RemoveNamedExpressionUndoEntry extends BaseUndoEntry {\n  constructor(namedExpression, content, scope) {\n    super();\n    this.namedExpression = namedExpression;\n    this.content = content;\n    this.scope = scope;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoRemoveNamedExpression(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoRemoveNamedExpression(this);\n  }\n}\nexport class ChangeNamedExpressionUndoEntry extends BaseUndoEntry {\n  constructor(namedExpression, newContent, oldContent, scope, options) {\n    super();\n    this.namedExpression = namedExpression;\n    this.newContent = newContent;\n    this.oldContent = oldContent;\n    this.scope = scope;\n    this.options = options;\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoChangeNamedExpression(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoChangeNamedExpression(this);\n  }\n}\nexport class BatchUndoEntry extends BaseUndoEntry {\n  constructor() {\n    super(...arguments);\n    this.operations = [];\n  }\n  add(operation) {\n    this.operations.push(operation);\n  }\n  *reversedOperations() {\n    for (let i = this.operations.length - 1; i >= 0; i--) {\n      yield this.operations[i];\n    }\n  }\n  doUndo(undoRedo) {\n    undoRedo.undoBatch(this);\n  }\n  doRedo(undoRedo) {\n    undoRedo.redoBatch(this);\n  }\n}\nexport class UndoRedo {\n  constructor(config, operations) {\n    this.operations = operations;\n    this.oldData = new Map();\n    this.undoStack = [];\n    this.redoStack = [];\n    this.undoLimit = config.undoLimit;\n  }\n  saveOperation(operation) {\n    if (this.batchUndoEntry !== undefined) {\n      this.batchUndoEntry.add(operation);\n    } else {\n      this.addUndoEntry(operation);\n    }\n  }\n  beginBatchMode() {\n    this.batchUndoEntry = new BatchUndoEntry();\n  }\n  commitBatchMode() {\n    if (this.batchUndoEntry === undefined) {\n      throw Error('Batch mode wasn\\'t started');\n    }\n    this.addUndoEntry(this.batchUndoEntry);\n    this.batchUndoEntry = undefined;\n  }\n  storeDataForVersion(version, address, astHash) {\n    if (!this.oldData.has(version)) {\n      this.oldData.set(version, []);\n    }\n    const currentOldData = this.oldData.get(version);\n    currentOldData.push([address, astHash]);\n  }\n  clearRedoStack() {\n    this.redoStack = [];\n  }\n  clearUndoStack() {\n    this.undoStack = [];\n  }\n  isUndoStackEmpty() {\n    return this.undoStack.length === 0;\n  }\n  isRedoStackEmpty() {\n    return this.redoStack.length === 0;\n  }\n  undo() {\n    const operation = this.undoStack.pop();\n    if (!operation) {\n      throw Error('Attempted to undo without operation on stack');\n    }\n    this.undoEntry(operation);\n    this.redoStack.push(operation);\n  }\n  undoBatch(batchOperation) {\n    for (const operation of batchOperation.reversedOperations()) {\n      this.undoEntry(operation);\n    }\n  }\n  undoRemoveRows(operation) {\n    this.operations.forceApplyPostponedTransformations();\n    const {\n      command: {\n        sheet\n      },\n      rowsRemovals\n    } = operation;\n    for (let i = rowsRemovals.length - 1; i >= 0; --i) {\n      const rowsRemoval = rowsRemovals[i];\n      this.operations.addRows(new AddRowsCommand(sheet, [[rowsRemoval.rowFrom, rowsRemoval.rowCount]]));\n      for (const {\n        address,\n        cellType\n      } of rowsRemoval.removedCells) {\n        this.operations.restoreCell(address, cellType);\n      }\n      this.restoreOldDataFromVersion(rowsRemoval.version - 1);\n    }\n  }\n  undoRemoveColumns(operation) {\n    this.operations.forceApplyPostponedTransformations();\n    const {\n      command: {\n        sheet\n      },\n      columnsRemovals\n    } = operation;\n    for (let i = columnsRemovals.length - 1; i >= 0; --i) {\n      const columnsRemoval = columnsRemovals[i];\n      this.operations.addColumns(new AddColumnsCommand(sheet, [[columnsRemoval.columnFrom, columnsRemoval.columnCount]]));\n      for (const {\n        address,\n        cellType\n      } of columnsRemoval.removedCells) {\n        this.operations.restoreCell(address, cellType);\n      }\n      this.restoreOldDataFromVersion(columnsRemoval.version - 1);\n    }\n  }\n  undoAddRows(operation) {\n    const addedRowsSpans = operation.command.rowsSpans();\n    for (let i = addedRowsSpans.length - 1; i >= 0; --i) {\n      const addedRows = addedRowsSpans[i];\n      this.operations.removeRows(new RemoveRowsCommand(operation.command.sheet, [[addedRows.rowStart, addedRows.numberOfRows]]));\n    }\n  }\n  undoAddColumns(operation) {\n    const addedColumnsSpans = operation.command.columnsSpans();\n    for (let i = addedColumnsSpans.length - 1; i >= 0; --i) {\n      const addedColumns = addedColumnsSpans[i];\n      this.operations.removeColumns(new RemoveColumnsCommand(operation.command.sheet, [[addedColumns.columnStart, addedColumns.numberOfColumns]]));\n    }\n  }\n  undoSetCellContents(operation) {\n    for (const cellContentData of operation.cellContents) {\n      const address = cellContentData.address;\n      const [oldContentAddress, oldContent] = cellContentData.oldContent;\n      if (!equalSimpleCellAddress(address, oldContentAddress)) {\n        this.operations.setCellEmpty(address);\n      }\n      this.operations.restoreCell(oldContentAddress, oldContent);\n    }\n  }\n  undoPaste(operation) {\n    this.restoreOperationOldContent(operation.oldContent);\n    for (const namedExpression of operation.addedGlobalNamedExpressions) {\n      this.operations.removeNamedExpression(namedExpression);\n    }\n  }\n  undoMoveRows(operation) {\n    const {\n      sheet\n    } = operation;\n    this.operations.moveRows(sheet, operation.undoStart, operation.numberOfRows, operation.undoEnd);\n    this.restoreOldDataFromVersion(operation.version - 1);\n  }\n  undoMoveColumns(operation) {\n    const {\n      sheet\n    } = operation;\n    this.operations.moveColumns(sheet, operation.undoStart, operation.numberOfColumns, operation.undoEnd);\n    this.restoreOldDataFromVersion(operation.version - 1);\n  }\n  undoMoveCells(operation) {\n    this.operations.forceApplyPostponedTransformations();\n    this.operations.moveCells(operation.destinationLeftCorner, operation.width, operation.height, operation.sourceLeftCorner);\n    this.restoreOperationOldContent(operation.overwrittenCellsData);\n    this.restoreOldDataFromVersion(operation.version - 1);\n    for (const namedExpression of operation.addedGlobalNamedExpressions) {\n      this.operations.removeNamedExpression(namedExpression);\n    }\n  }\n  undoAddSheet(operation) {\n    const {\n      sheetName\n    } = operation;\n    this.operations.removeSheetByName(sheetName);\n  }\n  undoRemoveSheet(operation) {\n    this.operations.forceApplyPostponedTransformations();\n    const {\n      oldSheetContent,\n      sheetId\n    } = operation;\n    this.operations.addSheet(operation.sheetName);\n    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {\n      const row = oldSheetContent[rowIndex];\n      for (let col = 0; col < row.length; col++) {\n        const cellType = row[col];\n        const address = simpleCellAddress(sheetId, col, rowIndex);\n        this.operations.restoreCell(address, cellType);\n      }\n    }\n    for (const [namedexpression, content] of operation.scopedNamedExpressions) {\n      this.operations.restoreNamedExpression(namedexpression, content, sheetId);\n    }\n    this.restoreOldDataFromVersion(operation.version - 1);\n  }\n  undoRenameSheet(operation) {\n    this.operations.renameSheet(operation.sheetId, operation.oldName);\n  }\n  undoClearSheet(operation) {\n    const {\n      oldSheetContent,\n      sheetId\n    } = operation;\n    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {\n      const row = oldSheetContent[rowIndex];\n      for (let col = 0; col < row.length; col++) {\n        const cellType = row[col];\n        const address = simpleCellAddress(sheetId, col, rowIndex);\n        this.operations.restoreCell(address, cellType);\n      }\n    }\n  }\n  undoSetSheetContent(operation) {\n    const {\n      oldSheetContent,\n      sheetId\n    } = operation;\n    this.operations.clearSheet(sheetId);\n    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {\n      const row = oldSheetContent[rowIndex];\n      for (let col = 0; col < row.length; col++) {\n        const cellType = row[col];\n        const address = simpleCellAddress(sheetId, col, rowIndex);\n        this.operations.restoreCell(address, cellType);\n      }\n    }\n  }\n  undoAddNamedExpression(operation) {\n    this.operations.removeNamedExpression(operation.name, operation.scope);\n  }\n  undoRemoveNamedExpression(operation) {\n    this.operations.restoreNamedExpression(operation.namedExpression, operation.content, operation.scope);\n  }\n  undoChangeNamedExpression(operation) {\n    this.operations.restoreNamedExpression(operation.namedExpression, operation.oldContent, operation.scope);\n  }\n  undoSetRowOrder(operation) {\n    this.restoreOperationOldContent(operation.oldContent);\n  }\n  undoSetColumnOrder(operation) {\n    this.restoreOperationOldContent(operation.oldContent);\n  }\n  redo() {\n    const operation = this.redoStack.pop();\n    if (!operation) {\n      throw Error('Attempted to redo without operation on stack');\n    }\n    this.redoEntry(operation);\n    this.undoStack.push(operation);\n  }\n  redoBatch(batchOperation) {\n    for (const operation of batchOperation.operations) {\n      this.redoEntry(operation);\n    }\n  }\n  redoRemoveRows(operation) {\n    this.operations.removeRows(operation.command);\n  }\n  redoMoveCells(operation) {\n    this.operations.moveCells(operation.sourceLeftCorner, operation.width, operation.height, operation.destinationLeftCorner);\n  }\n  redoRemoveColumns(operation) {\n    this.operations.removeColumns(operation.command);\n  }\n  redoPaste(operation) {\n    const {\n      targetLeftCorner,\n      newContent\n    } = operation;\n    const height = newContent.length;\n    const width = newContent[0].length;\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        const address = simpleCellAddress(targetLeftCorner.sheet, targetLeftCorner.col + x, targetLeftCorner.row + y);\n        this.operations.restoreCell(address, newContent[y][x]);\n      }\n    }\n  }\n  redoSetCellContents(operation) {\n    for (const cellContentData of operation.cellContents) {\n      this.operations.setCellContent(cellContentData.address, cellContentData.newContent);\n    }\n  }\n  redoAddRows(operation) {\n    this.operations.addRows(operation.command);\n  }\n  redoAddColumns(operation) {\n    this.operations.addColumns(operation.command);\n  }\n  redoRemoveSheet(operation) {\n    this.operations.removeSheetByName(operation.sheetName);\n  }\n  redoAddSheet(operation) {\n    this.operations.addSheet(operation.sheetName);\n  }\n  redoRenameSheet(operation) {\n    this.operations.renameSheet(operation.sheetId, operation.newName);\n  }\n  redoMoveRows(operation) {\n    this.operations.moveRows(operation.sheet, operation.startRow, operation.numberOfRows, operation.targetRow);\n  }\n  redoMoveColumns(operation) {\n    this.operations.moveColumns(operation.sheet, operation.startColumn, operation.numberOfColumns, operation.targetColumn);\n  }\n  redoClearSheet(operation) {\n    this.operations.clearSheet(operation.sheetId);\n  }\n  redoSetSheetContent(operation) {\n    const {\n      sheetId,\n      newSheetContent\n    } = operation;\n    this.operations.setSheetContent(sheetId, newSheetContent);\n  }\n  redoAddNamedExpression(operation) {\n    this.operations.addNamedExpression(operation.name, operation.newContent, operation.scope, operation.options);\n  }\n  redoRemoveNamedExpression(operation) {\n    this.operations.removeNamedExpression(operation.namedExpression.displayName, operation.scope);\n  }\n  redoChangeNamedExpression(operation) {\n    this.operations.changeNamedExpressionExpression(operation.namedExpression.displayName, operation.newContent, operation.scope, operation.options);\n  }\n  redoSetRowOrder(operation) {\n    this.operations.setRowOrder(operation.sheetId, operation.rowMapping);\n  }\n  redoSetColumnOrder(operation) {\n    this.operations.setColumnOrder(operation.sheetId, operation.columnMapping);\n  }\n  addUndoEntry(operation) {\n    this.undoStack.push(operation);\n    this.undoStack.splice(0, Math.max(0, this.undoStack.length - this.undoLimit));\n  }\n  undoEntry(operation) {\n    operation.doUndo(this);\n  }\n  restoreOperationOldContent(oldContent) {\n    for (const [address, clipboardCell] of oldContent) {\n      this.operations.restoreCell(address, clipboardCell);\n    }\n  }\n  redoEntry(operation) {\n    operation.doRedo(this);\n  }\n  restoreOldDataFromVersion(version) {\n    const oldDataToRestore = this.oldData.get(version) || [];\n    for (const entryToRestore of oldDataToRestore) {\n      const [address, hash] = entryToRestore;\n      this.operations.setFormulaToCellFromCache(hash, address);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}