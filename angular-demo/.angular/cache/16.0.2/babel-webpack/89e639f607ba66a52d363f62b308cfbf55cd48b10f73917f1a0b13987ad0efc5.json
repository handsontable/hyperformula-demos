{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { EmptyValue, getRawValue } from './InterpreterValue';\nexport var CriterionType = /*#__PURE__*/(() => {\n  CriterionType = CriterionType || {};\n  CriterionType[\"GREATER_THAN\"] = \"GREATER_THAN\";\n  CriterionType[\"GREATER_THAN_OR_EQUAL\"] = \"GREATER_THAN_OR_EQUAL\";\n  CriterionType[\"LESS_THAN\"] = \"LESS_THAN\";\n  CriterionType[\"LESS_THAN_OR_EQUAL\"] = \"LESS_THAN_OR_EQUAL\";\n  CriterionType[\"NOT_EQUAL\"] = \"NOT_EQUAL\";\n  CriterionType[\"EQUAL\"] = \"EQUAL\";\n  return CriterionType;\n})();\nexport const buildCriterion = (operator, value) => ({\n  operator,\n  value\n});\nexport class CriterionBuilder {\n  constructor(config) {\n    var _a, _b, _c, _d;\n    this.trueString = (_b = (_a = config.translationPackage.getMaybeFunctionTranslation('TRUE')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'true';\n    this.falseString = (_d = (_c = config.translationPackage.getMaybeFunctionTranslation('FALSE')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== null && _d !== void 0 ? _d : 'false';\n  }\n  fromCellValue(raw, arithmeticHelper) {\n    if (typeof raw !== 'string' && typeof raw !== 'boolean' && typeof raw !== 'number') {\n      return undefined;\n    }\n    const criterion = this.parseCriterion(raw, arithmeticHelper);\n    if (criterion === undefined) {\n      return undefined;\n    }\n    return {\n      raw,\n      lambda: buildCriterionLambda(criterion, arithmeticHelper)\n    };\n  }\n  parseCriterion(criterion, arithmeticHelper) {\n    if (typeof criterion === 'number' || typeof criterion === 'boolean') {\n      return buildCriterion(CriterionType.EQUAL, criterion);\n    } else if (typeof criterion === 'string') {\n      const regexResult = ANY_CRITERION_REGEX.exec(criterion);\n      let criterionValue;\n      let criterionType;\n      if (regexResult) {\n        criterionType = StrToCriterionType(regexResult[1]);\n        criterionValue = regexResult[2];\n      } else {\n        criterionType = CriterionType.EQUAL;\n        criterionValue = criterion;\n      }\n      const value = arithmeticHelper.coerceToMaybeNumber(criterionValue);\n      const boolvalue = criterionValue.toLowerCase() === this.trueString ? true : criterionValue.toLowerCase() === this.falseString ? false : undefined;\n      if (criterionType === undefined) {\n        return undefined;\n      }\n      if (criterionValue === '') {\n        return buildCriterion(criterionType, null);\n      } else if (value === undefined) {\n        if (criterionType === CriterionType.EQUAL || criterionType === CriterionType.NOT_EQUAL) {\n          return buildCriterion(criterionType, boolvalue !== null && boolvalue !== void 0 ? boolvalue : criterionValue);\n        }\n      } else {\n        return buildCriterion(criterionType, getRawValue(value));\n      }\n    }\n    return undefined;\n  }\n}\nconst ANY_CRITERION_REGEX = /([<>=]+)(.*)/;\nfunction StrToCriterionType(str) {\n  switch (str) {\n    case '>':\n      return CriterionType.GREATER_THAN;\n    case '>=':\n      return CriterionType.GREATER_THAN_OR_EQUAL;\n    case '<':\n      return CriterionType.LESS_THAN;\n    case '<=':\n      return CriterionType.LESS_THAN_OR_EQUAL;\n    case '<>':\n      return CriterionType.NOT_EQUAL;\n    case '=':\n      return CriterionType.EQUAL;\n    default:\n      return undefined;\n  }\n}\nexport const buildCriterionLambda = (criterion, arithmeticHelper) => {\n  switch (criterion.operator) {\n    case CriterionType.GREATER_THAN:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) > 0;\n        } else {\n          return _cellValue => false;\n        }\n      }\n    case CriterionType.GREATER_THAN_OR_EQUAL:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) >= 0;\n        } else {\n          return _cellValue => false;\n        }\n      }\n    case CriterionType.LESS_THAN:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) < 0;\n        } else {\n          return _cellValue => false;\n        }\n      }\n    case CriterionType.LESS_THAN_OR_EQUAL:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) <= 0;\n        } else {\n          return _cellValue => false;\n        }\n      }\n    case CriterionType.EQUAL:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => {\n            if (typeof cellValue === 'number') {\n              return arithmeticHelper.floatCmp(cellValue, criterion.value) === 0;\n            } else if (typeof cellValue === 'string') {\n              if (cellValue === '') {\n                return false;\n              }\n              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);\n              if (val === undefined) {\n                return false;\n              }\n              return arithmeticHelper.floatCmp(val, criterion.value) === 0;\n            } else {\n              return false;\n            }\n          };\n        } else if (typeof criterion.value === 'string') {\n          return arithmeticHelper.eqMatcherFunction(criterion.value);\n        } else if (typeof criterion.value === 'boolean') {\n          return cellValue => typeof cellValue === 'boolean' && cellValue === criterion.value;\n        } else {\n          return cellValue => cellValue === EmptyValue;\n        }\n      }\n    case CriterionType.NOT_EQUAL:\n      {\n        if (typeof criterion.value === 'number') {\n          return cellValue => {\n            if (typeof cellValue === 'number') {\n              return arithmeticHelper.floatCmp(cellValue, criterion.value) !== 0;\n            } else if (typeof cellValue === 'string') {\n              if (cellValue === '') {\n                return true;\n              }\n              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);\n              if (val === undefined) {\n                return true;\n              }\n              return arithmeticHelper.floatCmp(val, criterion.value) !== 0;\n            } else {\n              return true;\n            }\n          };\n        } else if (typeof criterion.value === 'string') {\n          return arithmeticHelper.neqMatcherFunction(criterion.value);\n        } else if (typeof criterion.value === 'boolean') {\n          return cellValue => typeof cellValue !== 'boolean' || cellValue !== criterion.value;\n        } else {\n          return cellValue => cellValue !== EmptyValue;\n        }\n      }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}