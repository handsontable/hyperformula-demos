{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { addressKey } from '../Cell';\nexport class ArrayMapping {\n  constructor() {\n    this.arrayMapping = new Map();\n  }\n  getArray(range) {\n    const array = this.getArrayByCorner(range.start);\n    if (array === null || array === void 0 ? void 0 : array.getRange().sameAs(range)) {\n      return array;\n    }\n    return;\n  }\n  getArrayByCorner(address) {\n    return this.arrayMapping.get(addressKey(address));\n  }\n  setArray(range, vertex) {\n    this.arrayMapping.set(addressKey(range.start), vertex);\n  }\n  removeArray(range) {\n    if (typeof range === 'string') {\n      this.arrayMapping.delete(range);\n    } else {\n      this.arrayMapping.delete(addressKey(range.start));\n    }\n  }\n  count() {\n    return this.arrayMapping.size;\n  }\n  *arraysInRows(rowsSpan) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetRows(rowsSpan.sheet, rowsSpan.rowStart, rowsSpan.rowEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  *arraysInCols(col) {\n    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {\n      if (mtx.spansThroughSheetColumn(col.sheet, col.columnStart, col.columnEnd)) {\n        yield [mtxKey, mtx];\n      }\n    }\n  }\n  isFormulaArrayInRow(sheet, row) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetRows(sheet, row)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllRows(span) {\n    let result = true;\n    for (const row of span.rows()) {\n      if (!this.isFormulaArrayInRow(span.sheet, row)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInColumn(sheet, column) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.spansThroughSheetColumn(sheet, column)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayInAllColumns(span) {\n    let result = true;\n    for (const col of span.columns()) {\n      if (!this.isFormulaArrayInColumn(span.sheet, col)) {\n        result = false;\n      }\n    }\n    return result;\n  }\n  isFormulaArrayInRange(range) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().doesOverlap(range)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  isFormulaArrayAtAddress(address) {\n    for (const mtx of this.arrayMapping.values()) {\n      if (mtx.getRange().addressInRange(address)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  moveArrayVerticesAfterRowByRows(sheet, row, numberOfRows) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return row <= range.start.row ? [range.shifted(0, numberOfRows), vertex] : undefined;\n    });\n  }\n  moveArrayVerticesAfterColumnByColumns(sheet, column, numberOfColumns) {\n    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {\n      const range = vertex.getRange();\n      return column <= range.start.col ? [range.shifted(numberOfColumns, 0), vertex] : undefined;\n    });\n  }\n  updateArrayVerticesInSheet(sheet, fn) {\n    const updated = Array();\n    for (const [key, vertex] of this.arrayMapping.entries()) {\n      if (vertex.sheet !== sheet) {\n        continue;\n      }\n      const result = fn(key, vertex);\n      if (result !== undefined) {\n        this.removeArray(key);\n        updated.push(result);\n      }\n    }\n    updated.forEach(([range, array]) => {\n      this.setArray(range, array);\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}