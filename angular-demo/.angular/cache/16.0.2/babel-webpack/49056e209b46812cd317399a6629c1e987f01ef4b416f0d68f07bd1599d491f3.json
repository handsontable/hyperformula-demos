{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nconst dateFormatRegex = /(\\\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\\.(0+|s+))?|s|AM\\/PM|am\\/pm|A\\/P|a\\/p|\\[mm]|\\[MM]|\\[hh]|\\[HH])/g;\nconst numberFormatRegex = /(\\\\.|[#0]+(\\.[#0]*)?)/g;\nexport var TokenType = /*#__PURE__*/(() => {\n  TokenType = TokenType || {};\n  TokenType[\"FORMAT\"] = \"FORMAT\";\n  TokenType[\"FREE_TEXT\"] = \"FREE_TEXT\";\n  return TokenType;\n})();\nexport function formatToken(type, value) {\n  return {\n    type,\n    value\n  };\n}\nexport var FormatExpressionType = /*#__PURE__*/(() => {\n  FormatExpressionType = FormatExpressionType || {};\n  FormatExpressionType[\"DATE\"] = \"DATE\";\n  FormatExpressionType[\"NUMBER\"] = \"NUMBER\";\n  FormatExpressionType[\"STRING\"] = \"STRING\";\n  return FormatExpressionType;\n})();\nfunction matchDateFormat(str) {\n  dateFormatRegex.lastIndex = 0;\n  const tokens = [];\n  let m;\n  do {\n    m = dateFormatRegex.exec(str);\n    if (m !== null) {\n      tokens.push(m);\n    }\n  } while (m);\n  return tokens;\n}\nfunction matchNumberFormat(str) {\n  numberFormatRegex.lastIndex = 0;\n  const numberFormatToken = numberFormatRegex.exec(str);\n  if (numberFormatToken !== null) {\n    return [numberFormatToken];\n  } else {\n    return [];\n  }\n}\nfunction createTokens(regexTokens, str) {\n  const tokens = [];\n  let start = 0;\n  for (let i = 0; i < regexTokens.length; ++i) {\n    const token = regexTokens[i];\n    if (token.index !== start) {\n      const beforeToken = str.substr(start, token.index - start);\n      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));\n    }\n    if (token[0].startsWith('\\\\')) {\n      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));\n    } else {\n      tokens.push(formatToken(TokenType.FORMAT, token[0]));\n    }\n    start = token.index + token[0].length;\n  }\n  const lastToken = regexTokens[regexTokens.length - 1];\n  if (lastToken.index + lastToken[0].length < str.length) {\n    const afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);\n    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));\n  }\n  return tokens;\n}\nexport function parseForDateTimeFormat(str) {\n  const dateFormatTokens = matchDateFormat(str);\n  if (dateFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.DATE,\n      tokens: createTokens(dateFormatTokens, str)\n    };\n  }\n}\nexport function parseForNumberFormat(str) {\n  const numberFormatTokens = matchNumberFormat(str);\n  if (numberFormatTokens.every(elem => isEscapeToken(elem))) {\n    return undefined;\n  } else {\n    return {\n      type: FormatExpressionType.NUMBER,\n      tokens: createTokens(numberFormatTokens, str)\n    };\n  }\n}\nexport function parse(str) {\n  var _a, _b;\n  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {\n    type: FormatExpressionType.STRING,\n    tokens: [{\n      type: TokenType.FREE_TEXT,\n      value: str\n    }]\n  };\n}\nexport function isEscapeToken(token) {\n  return token[0].startsWith('\\\\');\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}