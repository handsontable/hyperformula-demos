{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { simpleCellAddress } from '../Cell';\nimport { CellAddress } from '../parser';\nimport { RowAddress } from '../parser/RowAddress';\nimport { Transformer } from './Transformer';\nexport class MoveCellsTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n    this.dependentFormulaTransformer = new DependentFormulaTransformer(sourceRange, toRight, toBottom, toSheet);\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  transformSingleAst(ast, address) {\n    if (this.sourceRange.addressInRange(address)) {\n      const newAst = this.transformAst(ast, address);\n      return [newAst, this.fixNodeAddress(address)];\n    } else {\n      return this.dependentFormulaTransformer.transformSingleAst(ast, address);\n    }\n  }\n  fixNodeAddress(address) {\n    return simpleCellAddress(this.toSheet, address.col + this.toRight, address.row + this.toBottom);\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    return this.transformAddress(dependencyAddress, formulaAddress);\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformAddress(dependencyAddress, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (dependencyAddress instanceof CellAddress) {\n      const absoluteDependencyAddress = dependencyAddress.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteDependencyAddress)) {\n        // If dependency is internal, move only absolute dimensions\n        return dependencyAddress.shiftAbsoluteDimensions(this.toRight, this.toBottom);\n      }\n    }\n    return dependencyAddress.shiftRelativeDimensions(-this.toRight, -this.toBottom);\n  }\n  transformRange(start, end, formulaAddress) {\n    const sourceRange = this.sourceRange;\n    if (start instanceof CellAddress && end instanceof CellAddress) {\n      const absoluteStart = start.toSimpleCellAddress(formulaAddress);\n      const absoluteEnd = end.toSimpleCellAddress(formulaAddress);\n      if (sourceRange.addressInRange(absoluteStart) && sourceRange.addressInRange(absoluteEnd)) {\n        return [start.shiftAbsoluteDimensions(this.toRight, this.toBottom), end.shiftAbsoluteDimensions(this.toRight, this.toBottom)];\n      }\n    }\n    return [start.shiftRelativeDimensions(-this.toRight, -this.toBottom), end.shiftRelativeDimensions(-this.toRight, -this.toBottom)];\n  }\n}\nexport class DependentFormulaTransformer extends Transformer {\n  constructor(sourceRange, toRight, toBottom, toSheet) {\n    super();\n    this.sourceRange = sourceRange;\n    this.toRight = toRight;\n    this.toBottom = toBottom;\n    this.toSheet = toSheet;\n  }\n  get sheet() {\n    return this.sourceRange.sheet;\n  }\n  isIrreversible() {\n    return true;\n  }\n  fixNodeAddress(address) {\n    return address;\n  }\n  transformCellAddress(dependencyAddress, formulaAddress) {\n    if (this.shouldMove(dependencyAddress, formulaAddress)) {\n      return dependencyAddress.moved(this.toSheet, this.toRight, this.toBottom);\n    }\n    return false;\n  }\n  transformCellRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformColumnRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  transformRowRange(start, end, formulaAddress) {\n    return this.transformRange(start, end, formulaAddress);\n  }\n  shouldMove(dependencyAddress, formulaAddress) {\n    if (dependencyAddress instanceof CellAddress) {\n      return this.sourceRange.addressInRange(dependencyAddress.toSimpleCellAddress(formulaAddress));\n    } else if (dependencyAddress instanceof RowAddress) {\n      return this.sourceRange.rowInRange(dependencyAddress.toSimpleRowAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    } else {\n      return this.sourceRange.columnInRange(dependencyAddress.toSimpleColumnAddress(formulaAddress)) && !this.sourceRange.isFinite();\n    }\n  }\n  transformRange(start, end, formulaAddress) {\n    const newStart = this.transformCellAddress(start, formulaAddress);\n    const newEnd = this.transformCellAddress(end, formulaAddress);\n    if (newStart && newEnd) {\n      return [newStart, newEnd];\n    }\n    return false;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}