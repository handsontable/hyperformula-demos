{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ErrorType } from '../Cell';\nimport { NoSheetWithIdError } from '../index';\nimport { sheetIndexToString } from './addressRepresentationConverters';\nimport { AstNodeType, imageWithWhitespace, RangeSheetReferenceType } from './Ast';\nimport { binaryOpTokenMap } from './binaryOpTokenMap';\nexport class Unparser {\n  constructor(config, lexerConfig, sheetMappingFn, namedExpressions) {\n    this.config = config;\n    this.lexerConfig = lexerConfig;\n    this.sheetMappingFn = sheetMappingFn;\n    this.namedExpressions = namedExpressions;\n  }\n  unparse(ast, address) {\n    return '=' + this.unparseAst(ast, address);\n  }\n  unparseAst(ast, address) {\n    var _a, _b;\n    switch (ast.type) {\n      case AstNodeType.EMPTY:\n        {\n          return imageWithWhitespace('', ast.leadingWhitespace);\n        }\n      case AstNodeType.NUMBER:\n        {\n          return imageWithWhitespace(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);\n        }\n      case AstNodeType.STRING:\n        {\n          return imageWithWhitespace('\"' + ast.value + '\"', ast.leadingWhitespace);\n        }\n      case AstNodeType.FUNCTION_CALL:\n        {\n          const args = ast.args.map(arg => arg !== undefined ? this.unparseAst(arg, address) : '').join(this.config.functionArgSeparator);\n          const procedureName = this.config.translationPackage.isFunctionTranslated(ast.procedureName) ? this.config.translationPackage.getFunctionTranslation(ast.procedureName) : ast.procedureName;\n          const rightPart = procedureName + '(' + args + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.NAMED_EXPRESSION:\n        {\n          const originalNamedExpressionName = (_a = this.namedExpressions.nearestNamedExpression(ast.expressionName, address.sheet)) === null || _a === void 0 ? void 0 : _a.displayName;\n          return imageWithWhitespace(originalNamedExpressionName || ast.expressionName, ast.leadingWhitespace);\n        }\n      case AstNodeType.CELL_REFERENCE:\n        {\n          let image;\n          if (ast.reference.sheet !== undefined) {\n            image = this.unparseSheetName(ast.reference.sheet) + '!';\n          } else {\n            image = '';\n          }\n          image += (_b = ast.reference.unparse(address)) !== null && _b !== void 0 ? _b : this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.COLUMN_RANGE:\n      case AstNodeType.ROW_RANGE:\n      case AstNodeType.CELL_RANGE:\n        {\n          return imageWithWhitespace(this.formatRange(ast, address), ast.leadingWhitespace);\n        }\n      case AstNodeType.PLUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('+', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.MINUS_UNARY_OP:\n        {\n          const unparsedExpr = this.unparseAst(ast.value, address);\n          return imageWithWhitespace('-', ast.leadingWhitespace) + unparsedExpr;\n        }\n      case AstNodeType.PERCENT_OP:\n        {\n          return this.unparseAst(ast.value, address) + imageWithWhitespace('%', ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR:\n        {\n          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : ErrorType.ERROR);\n          return imageWithWhitespace(image, ast.leadingWhitespace);\n        }\n      case AstNodeType.ERROR_WITH_RAW_INPUT:\n        {\n          return imageWithWhitespace(ast.rawInput, ast.leadingWhitespace);\n        }\n      case AstNodeType.PARENTHESIS:\n        {\n          const expression = this.unparseAst(ast.expression, address);\n          const rightPart = '(' + expression + imageWithWhitespace(')', ast.internalWhitespace);\n          return imageWithWhitespace(rightPart, ast.leadingWhitespace);\n        }\n      case AstNodeType.ARRAY:\n        {\n          const ret = '{' + ast.args.map(row => row.map(val => this.unparseAst(val, address)).join(this.config.arrayColumnSeparator)).join(this.config.arrayRowSeparator) + imageWithWhitespace('}', ast.internalWhitespace);\n          return imageWithWhitespace(ret, ast.leadingWhitespace);\n        }\n      default:\n        {\n          const left = this.unparseAst(ast.left, address);\n          const right = this.unparseAst(ast.right, address);\n          return left + imageWithWhitespace(binaryOpTokenMap[ast.type], ast.leadingWhitespace) + right;\n        }\n    }\n  }\n  unparseSheetName(sheetId) {\n    const sheetName = sheetIndexToString(sheetId, this.sheetMappingFn);\n    if (sheetName === undefined) {\n      throw new NoSheetWithIdError(sheetId);\n    }\n    return sheetName;\n  }\n  formatRange(ast, baseAddress) {\n    let startSheeet = '';\n    let endSheet = '';\n    if (ast.start.sheet !== undefined && ast.sheetReferenceType !== RangeSheetReferenceType.RELATIVE) {\n      startSheeet = this.unparseSheetName(ast.start.sheet) + '!';\n    }\n    if (ast.end.sheet !== undefined && ast.sheetReferenceType === RangeSheetReferenceType.BOTH_ABSOLUTE) {\n      endSheet = this.unparseSheetName(ast.end.sheet) + '!';\n    }\n    const unparsedStart = ast.start.unparse(baseAddress);\n    const unparsedEnd = ast.end.unparse(baseAddress);\n    if (unparsedStart === undefined || unparsedEnd === undefined) {\n      return this.config.translationPackage.getErrorTranslation(ErrorType.REF);\n    }\n    return `${startSheeet}${unparsedStart}:${endSheet}${unparsedEnd}`;\n  }\n}\nexport function formatNumber(number, decimalSeparator) {\n  const numericString = number.toString();\n  return numericString.replace('.', decimalSeparator);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}