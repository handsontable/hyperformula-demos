{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { ArraySize } from '../../ArraySize';\nimport { CellError, ErrorType } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { AstNodeType } from '../../parser';\nimport { InterpreterState } from '../InterpreterState';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nfunction arraySizeForMultiplication(leftArraySize, rightArraySize) {\n  return new ArraySize(rightArraySize.width, leftArraySize.height);\n}\nfunction arraySizeForPoolFunction(inputArray, windowSize, stride) {\n  return new ArraySize(1 + (inputArray.width - windowSize) / stride, 1 + (inputArray.height - windowSize) / stride);\n}\nexport class MatrixPlugin extends FunctionPlugin {\n  mmult(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MMULT'), (leftMatrix, rightMatrix) => {\n      if (!leftMatrix.hasOnlyNumbers() || !rightMatrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      if (rightMatrix.height() !== leftMatrix.width()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.ArrayDimensions);\n      }\n      const outputSize = arraySizeForMultiplication(leftMatrix.size, rightMatrix.size);\n      const result = this.createKernel(function (a, b, width) {\n        let sum = 0;\n        for (let i = 0; i < width; ++i) {\n          sum += a[this.thread.y][i] * b[i][this.thread.x];\n        }\n        return sum;\n      }, outputSize)(leftMatrix.rawNumbers(), rightMatrix.rawNumbers(), leftMatrix.width());\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  mmultArraySize(ast, state) {\n    if (ast.args.length !== 2) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MMULT');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [left, right] = subChecks;\n    return arraySizeForMultiplication(left, right);\n  }\n  maxpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MAXPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        return currentMax;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  medianpool(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MEDIANPOOL'), (matrix, windowSize, stride = windowSize) => {\n      if (!matrix.hasOnlyNumbers()) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.NumberRange);\n      }\n      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);\n      const result = this.createKernel(function (a, windowSize, stride) {\n        const leftCornerX = this.thread.x * stride;\n        const leftCornerY = this.thread.y * stride;\n        let currentMax = a[leftCornerY][leftCornerX];\n        for (let i = 0; i < windowSize; i++) {\n          for (let j = 0; j < windowSize; j++) {\n            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);\n          }\n        }\n        let currentMin = a[leftCornerY][leftCornerX];\n        for (let i2 = 0; i2 < windowSize; i2++) {\n          for (let j2 = 0; j2 < windowSize; j2++) {\n            currentMin = Math.min(currentMin, a[leftCornerY + i2][leftCornerX + j2]);\n          }\n        }\n        const numberOfElements = windowSize * windowSize;\n        let leftEnd = currentMin;\n        let rightEnd = currentMax;\n        let result = 42;\n        for (let iter = 0; iter < 32; iter++) {\n          const medianGuess = (leftEnd + rightEnd) / 2;\n          let medianGuessCount = 0;\n          for (let i3 = 0; i3 < windowSize; i3++) {\n            for (let j3 = 0; j3 < windowSize; j3++) {\n              if (a[leftCornerY + i3][leftCornerX + j3] > medianGuess) {\n                medianGuessCount++;\n              }\n            }\n          }\n          if (windowSize % 2 === 0) {\n            if (medianGuessCount === numberOfElements / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > numberOfElements / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          } else {\n            if (medianGuessCount === (numberOfElements - 1) / 2) {\n              result = medianGuess;\n              break;\n            } else if (medianGuessCount > (numberOfElements - 1) / 2) {\n              leftEnd = medianGuess;\n            } else {\n              rightEnd = medianGuess;\n            }\n          }\n        }\n        return result;\n      }, outputSize)(matrix.rawNumbers(), windowSize, stride);\n      return SimpleRangeValue.onlyNumbers(result);\n    });\n  }\n  maxpoolArraySize(ast, state) {\n    if (ast.args.length < 2 || ast.args.length > 3) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MAXPOOL');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const array = subChecks[0];\n    const windowArg = ast.args[1];\n    let window;\n    if (windowArg.type === AstNodeType.NUMBER) {\n      window = windowArg.value;\n    } else {\n      window = 1;\n    }\n    let stride = window;\n    if (ast.args.length === 3) {\n      const strideArg = ast.args[2];\n      if (strideArg.type === AstNodeType.NUMBER) {\n        stride = strideArg.value;\n      } else {\n        stride = 1;\n      }\n    }\n    if (window > array.width || window > array.height || stride > window || (array.width - window) % stride !== 0 || (array.height - window) % stride !== 0) {\n      return ArraySize.error();\n    }\n    return arraySizeForPoolFunction(array, window, stride);\n  }\n  medianpoolArraySize(ast, state) {\n    return this.maxpoolArraySize(ast, state);\n  }\n  transpose(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('TRANSPOSE'), matrix => {\n      const input = matrix.rawData();\n      const inputSize = matrix.size;\n      const result = [];\n      for (let i = 0; i < inputSize.width; ++i) {\n        result[i] = [];\n        for (let j = 0; j < inputSize.height; ++j) {\n          result[i][j] = input[j][i];\n        }\n      }\n      return SimpleRangeValue.onlyValues(result);\n    });\n  }\n  transposeArraySize(ast, state) {\n    if (ast.args.length !== 1) {\n      return ArraySize.error();\n    }\n    const metadata = this.metadata('MMULT');\n    const subChecks = ast.args.map(arg => {\n      var _a;\n      return this.arraySizeForAst(arg, new InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));\n    });\n    const [size] = subChecks;\n    return new ArraySize(size.height, size.width);\n  }\n  createKernel(kernel, outputSize) {\n    return function (...args) {\n      const result = [];\n      for (let y = 0; y < outputSize.height; ++y) {\n        result.push([]);\n        for (let x = 0; x < outputSize.width; ++x) {\n          result[y][x] = kernel.apply({\n            thread: {\n              x,\n              y\n            }\n          }, args);\n        }\n      }\n      return result;\n    };\n  }\n}\nMatrixPlugin.implementedFunctions = {\n  'MMULT': {\n    method: 'mmult',\n    arraySizeMethod: 'mmultArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'TRANSPOSE': {\n    method: 'transpose',\n    arraySizeMethod: 'transposeArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }],\n    vectorizationForbidden: true\n  },\n  'MAXPOOL': {\n    method: 'maxpool',\n    arraySizeMethod: 'maxpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  },\n  'MEDIANPOOL': {\n    method: 'medianpool',\n    arraySizeMethod: 'medianpoolArraySize',\n    parameters: [{\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      optionalArg: true\n    }],\n    vectorizationForbidden: true\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}