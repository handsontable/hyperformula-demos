{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { CellError } from '../Cell';\nexport const parsingError = (type, message) => ({\n  type,\n  message\n});\nexport var ParsingErrorType = /*#__PURE__*/(() => {\n  ParsingErrorType = ParsingErrorType || {};\n  ParsingErrorType[\"LexingError\"] = \"LexingError\";\n  ParsingErrorType[\"ParserError\"] = \"ParsingError\";\n  ParsingErrorType[\"StaticOffsetError\"] = \"StaticOffsetError\";\n  ParsingErrorType[\"StaticOffsetOutOfRangeError\"] = \"StaticOffsetOutOfRangeError\";\n  ParsingErrorType[\"RangeOffsetNotAllowed\"] = \"RangeOffsetNotAllowed\";\n  return ParsingErrorType;\n})();\nexport var AstNodeType = /*#__PURE__*/(() => {\n  AstNodeType = AstNodeType || {};\n  AstNodeType[\"EMPTY\"] = \"EMPTY\";\n  AstNodeType[\"NUMBER\"] = \"NUMBER\";\n  AstNodeType[\"STRING\"] = \"STRING\";\n  AstNodeType[\"MINUS_UNARY_OP\"] = \"MINUS_UNARY_OP\";\n  AstNodeType[\"PLUS_UNARY_OP\"] = \"PLUS_UNARY_OP\";\n  AstNodeType[\"PERCENT_OP\"] = \"PERCENT_OP\";\n  AstNodeType[\"CONCATENATE_OP\"] = \"CONCATENATE_OP\";\n  AstNodeType[\"EQUALS_OP\"] = \"EQUALS_OP\";\n  AstNodeType[\"NOT_EQUAL_OP\"] = \"NOT_EQUAL_OP\";\n  AstNodeType[\"GREATER_THAN_OP\"] = \"GREATER_THAN_OP\";\n  AstNodeType[\"LESS_THAN_OP\"] = \"LESS_THAN_OP\";\n  AstNodeType[\"GREATER_THAN_OR_EQUAL_OP\"] = \"GREATER_THAN_OR_EQUAL_OP\";\n  AstNodeType[\"LESS_THAN_OR_EQUAL_OP\"] = \"LESS_THAN_OR_EQUAL_OP\";\n  AstNodeType[\"PLUS_OP\"] = \"PLUS_OP\";\n  AstNodeType[\"MINUS_OP\"] = \"MINUS_OP\";\n  AstNodeType[\"TIMES_OP\"] = \"TIMES_OP\";\n  AstNodeType[\"DIV_OP\"] = \"DIV_OP\";\n  AstNodeType[\"POWER_OP\"] = \"POWER_OP\";\n  AstNodeType[\"FUNCTION_CALL\"] = \"FUNCTION_CALL\";\n  AstNodeType[\"NAMED_EXPRESSION\"] = \"NAMED_EXPRESSION\";\n  AstNodeType[\"PARENTHESIS\"] = \"PARENTHESES\";\n  AstNodeType[\"CELL_REFERENCE\"] = \"CELL_REFERENCE\";\n  AstNodeType[\"CELL_RANGE\"] = \"CELL_RANGE\";\n  AstNodeType[\"COLUMN_RANGE\"] = \"COLUMN_RANGE\";\n  AstNodeType[\"ROW_RANGE\"] = \"ROW_RANGE\";\n  AstNodeType[\"ERROR\"] = \"ERROR\";\n  AstNodeType[\"ERROR_WITH_RAW_INPUT\"] = \"ERROR_WITH_RAW_INPUT\";\n  AstNodeType[\"ARRAY\"] = \"ARRAY\";\n  return AstNodeType;\n})();\nexport var RangeSheetReferenceType = /*#__PURE__*/(() => {\n  RangeSheetReferenceType = RangeSheetReferenceType || {};\n  RangeSheetReferenceType[RangeSheetReferenceType[\"RELATIVE\"] = 0] = \"RELATIVE\";\n  RangeSheetReferenceType[RangeSheetReferenceType[\"START_ABSOLUTE\"] = 1] = \"START_ABSOLUTE\";\n  RangeSheetReferenceType[RangeSheetReferenceType[\"BOTH_ABSOLUTE\"] = 2] = \"BOTH_ABSOLUTE\";\n  return RangeSheetReferenceType;\n})();\nexport const buildEmptyArgAst = leadingWhitespace => ({\n  type: AstNodeType.EMPTY,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildNumberAst = (value, leadingWhitespace) => ({\n  type: AstNodeType.NUMBER,\n  value: value,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildStringAst = token => {\n  var _a;\n  return {\n    type: AstNodeType.STRING,\n    value: token.image.slice(1, -1),\n    leadingWhitespace: (_a = token.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image\n  };\n};\nexport const buildCellReferenceAst = (reference, leadingWhitespace) => ({\n  type: AstNodeType.CELL_REFERENCE,\n  reference,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildCellRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {\n  assertRangeConsistency(start, end, sheetReferenceType);\n  return {\n    type: AstNodeType.CELL_RANGE,\n    start,\n    end,\n    sheetReferenceType,\n    leadingWhitespace\n  };\n};\nexport const buildColumnRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {\n  assertRangeConsistency(start, end, sheetReferenceType);\n  return {\n    type: AstNodeType.COLUMN_RANGE,\n    start,\n    end,\n    sheetReferenceType,\n    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n  };\n};\nexport const buildRowRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {\n  assertRangeConsistency(start, end, sheetReferenceType);\n  return {\n    type: AstNodeType.ROW_RANGE,\n    start,\n    end,\n    sheetReferenceType,\n    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n  };\n};\nexport const buildConcatenateOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.CONCATENATE_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildEqualsOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.EQUALS_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildNotEqualOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.NOT_EQUAL_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildGreaterThanOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.GREATER_THAN_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildLessThanOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.LESS_THAN_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildGreaterThanOrEqualOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.GREATER_THAN_OR_EQUAL_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildLessThanOrEqualOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.LESS_THAN_OR_EQUAL_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildPlusOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.PLUS_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildMinusOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.MINUS_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildTimesOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.TIMES_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildDivOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.DIV_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildPowerOpAst = (left, right, leadingWhitespace) => ({\n  type: AstNodeType.POWER_OP,\n  left,\n  right,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildMinusUnaryOpAst = (value, leadingWhitespace) => ({\n  type: AstNodeType.MINUS_UNARY_OP,\n  value,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildPlusUnaryOpAst = (value, leadingWhitespace) => ({\n  type: AstNodeType.PLUS_UNARY_OP,\n  value,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildPercentOpAst = (value, leadingWhitespace) => ({\n  type: AstNodeType.PERCENT_OP,\n  value,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildProcedureAst = (procedureName, args, leadingWhitespace, internalWhitespace) => ({\n  type: AstNodeType.FUNCTION_CALL,\n  procedureName,\n  args,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,\n  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image\n});\nexport const buildArrayAst = (args, leadingWhitespace, internalWhitespace) => ({\n  type: AstNodeType.ARRAY,\n  args,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,\n  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image\n});\nexport const buildNamedExpressionAst = (expressionName, leadingWhitespace) => ({\n  type: AstNodeType.NAMED_EXPRESSION,\n  expressionName,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildParenthesisAst = (expression, leadingWhitespace, internalWhitespace) => ({\n  type: AstNodeType.PARENTHESIS,\n  expression,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,\n  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image\n});\nexport const buildCellErrorAst = (error, leadingWhitespace) => ({\n  type: AstNodeType.ERROR,\n  error,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildErrorWithRawInputAst = (rawInput, error, leadingWhitespace) => ({\n  type: AstNodeType.ERROR_WITH_RAW_INPUT,\n  error,\n  rawInput,\n  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image\n});\nexport const buildParsingErrorAst = () => ({\n  type: AstNodeType.ERROR,\n  error: CellError.parsingError()\n});\nfunction assertRangeConsistency(start, end, sheetReferenceType) {\n  if (start.sheet !== undefined && end.sheet === undefined || start.sheet === undefined && end.sheet !== undefined) {\n    throw new Error('Start address inconsistent with end address');\n  }\n  if (start.sheet === undefined && sheetReferenceType !== RangeSheetReferenceType.RELATIVE || start.sheet !== undefined && sheetReferenceType === RangeSheetReferenceType.RELATIVE) {\n    throw new Error('Sheet address inconsistent with sheet reference type');\n  }\n}\nexport function imageWithWhitespace(image, leadingWhitespace) {\n  return (leadingWhitespace !== null && leadingWhitespace !== void 0 ? leadingWhitespace : '') + image;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}