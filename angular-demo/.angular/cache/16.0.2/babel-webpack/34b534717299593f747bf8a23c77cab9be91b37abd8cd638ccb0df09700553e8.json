{"ast":null,"code":"/**\r\n * @license\r\n * Copyright (c) 2023 Handsoncode. All rights reserved.\r\n */\nimport { AbsoluteCellRange } from '../../AbsoluteCellRange';\nimport { CellError, ErrorType, simpleCellAddress } from '../../Cell';\nimport { ErrorMessage } from '../../error-message';\nimport { RowSearchStrategy } from '../../Lookup/RowSearchStrategy';\nimport { StatType } from '../../statistics';\nimport { zeroIfEmpty } from '../ArithmeticHelper';\nimport { SimpleRangeValue } from '../../SimpleRangeValue';\nimport { FunctionArgumentType, FunctionPlugin } from './FunctionPlugin';\nexport class LookupPlugin extends FunctionPlugin {\n  constructor() {\n    super(...arguments);\n    this.rowSearch = new RowSearchStrategy(this.dependencyGraph);\n  }\n  /**\r\n   * Corresponds to VLOOKUP(key, range, index, [sorted])\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  vlookup(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('VLOOKUP'), (key, rangeValue, index, sorted) => {\n      const range = rangeValue.range;\n      if (range === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n      if (index < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (index > range.width()) {\n        return new CellError(ErrorType.REF, ErrorMessage.IndexLarge);\n      }\n      return this.doVlookup(zeroIfEmpty(key), rangeValue, index - 1, sorted);\n    });\n  }\n  /**\r\n   * Corresponds to HLOOKUP(key, range, index, [sorted])\r\n   *\r\n   * @param ast\r\n   * @param state\r\n   */\n  hlookup(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('HLOOKUP'), (key, rangeValue, index, sorted) => {\n      const range = rangeValue.range;\n      if (range === undefined) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n      }\n      if (index < 1) {\n        return new CellError(ErrorType.VALUE, ErrorMessage.LessThanOne);\n      }\n      if (index > range.height()) {\n        return new CellError(ErrorType.REF, ErrorMessage.IndexLarge);\n      }\n      return this.doHlookup(zeroIfEmpty(key), rangeValue, index - 1, sorted);\n    });\n  }\n  match(ast, state) {\n    return this.runFunction(ast.args, state, this.metadata('MATCH'), (key, rangeValue, type) => {\n      return this.doMatch(zeroIfEmpty(key), rangeValue, type);\n    });\n  }\n  searchInRange(key, range, sorted, searchStrategy) {\n    if (!sorted && typeof key === 'string' && this.arithmeticHelper.requiresRegex(key)) {\n      return searchStrategy.advancedFind(this.arithmeticHelper.eqMatcherFunction(key), range);\n    } else {\n      const searchOptions = sorted ? {\n        ordering: 'asc'\n      } : {\n        ordering: 'none',\n        matchExactly: true\n      };\n      return searchStrategy.find(key, range, searchOptions);\n    }\n  }\n  doVlookup(key, rangeValue, index, sorted) {\n    this.dependencyGraph.stats.start(StatType.VLOOKUP);\n    const range = rangeValue.range;\n    let searchedRange;\n    if (range === undefined) {\n      searchedRange = SimpleRangeValue.onlyValues(rangeValue.data.map(arg => [arg[0]]));\n    } else {\n      searchedRange = SimpleRangeValue.onlyRange(AbsoluteCellRange.spanFrom(range.start, 1, range.height()), this.dependencyGraph);\n    }\n    const rowIndex = this.searchInRange(key, searchedRange, sorted, this.columnSearch);\n    this.dependencyGraph.stats.end(StatType.VLOOKUP);\n    if (rowIndex === -1) {\n      return new CellError(ErrorType.NA, ErrorMessage.ValueNotFound);\n    }\n    let value;\n    if (range === undefined) {\n      value = rangeValue.data[rowIndex][index];\n    } else {\n      const address = simpleCellAddress(range.sheet, range.start.col + index, range.start.row + rowIndex);\n      value = this.dependencyGraph.getCellValue(address);\n    }\n    if (value instanceof SimpleRangeValue) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n    }\n    return value;\n  }\n  doHlookup(key, rangeValue, index, sorted) {\n    const range = rangeValue.range;\n    let searchedRange;\n    if (range === undefined) {\n      searchedRange = SimpleRangeValue.onlyValues([rangeValue.data[0]]);\n    } else {\n      searchedRange = SimpleRangeValue.onlyRange(AbsoluteCellRange.spanFrom(range.start, range.width(), 1), this.dependencyGraph);\n    }\n    const colIndex = this.searchInRange(key, searchedRange, sorted, this.rowSearch);\n    if (colIndex === -1) {\n      return new CellError(ErrorType.NA, ErrorMessage.ValueNotFound);\n    }\n    let value;\n    if (range === undefined) {\n      value = rangeValue.data[index][colIndex];\n    } else {\n      const address = simpleCellAddress(range.sheet, range.start.col + colIndex, range.start.row + index);\n      value = this.dependencyGraph.getCellValue(address);\n    }\n    if (value instanceof SimpleRangeValue) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.WrongType);\n    }\n    return value;\n  }\n  doMatch(key, rangeValue, type) {\n    if (![-1, 0, 1].includes(type)) {\n      return new CellError(ErrorType.VALUE, ErrorMessage.BadMode);\n    }\n    if (rangeValue.width() > 1 && rangeValue.height() > 1) {\n      return new CellError(ErrorType.NA);\n    }\n    const searchStrategy = rangeValue.width() === 1 ? this.columnSearch : this.rowSearch;\n    const searchOptions = type === 0 ? {\n      ordering: 'none',\n      matchExactly: true\n    } : {\n      ordering: type === -1 ? 'desc' : 'asc'\n    };\n    const index = searchStrategy.find(key, rangeValue, searchOptions);\n    if (index === -1) {\n      return new CellError(ErrorType.NA, ErrorMessage.ValueNotFound);\n    }\n    return index + 1;\n  }\n}\nLookupPlugin.implementedFunctions = {\n  'VLOOKUP': {\n    method: 'vlookup',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN,\n      defaultValue: true\n    }]\n  },\n  'HLOOKUP': {\n    method: 'hlookup',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER\n    }, {\n      argumentType: FunctionArgumentType.BOOLEAN,\n      defaultValue: true\n    }]\n  },\n  'MATCH': {\n    method: 'match',\n    parameters: [{\n      argumentType: FunctionArgumentType.NOERROR\n    }, {\n      argumentType: FunctionArgumentType.RANGE\n    }, {\n      argumentType: FunctionArgumentType.NUMBER,\n      defaultValue: 1\n    }]\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}